---
layout: post
title: Hardware Intrinsics APIs for ARM64 - Part 2
subtitle: With examples
tags: [work, arm64, intrinsics]
---

### Introduction

In my [last post](../2019-01-01-Vectorization-APIs), I describe SIMD datatypes `Vector64<T>` and `Vector128<T>` that operates on 'hardware intrisic' APIs. In this post I will describe the intrinsic APIs for ARM64 and how you can use them to optimize your code if you are writing a .NET API targetting ARM64. This is 3 post series TODO.


### API list

[ConvertToUInt32RoundToZeroScalar](#1-converttouint32roundtozeroscalar), [DivideScalar](#2-dividescalar), [DuplicateSelectedScalarToVector64](#3-duplicateselectedscalartovector64), [DuplicateSelectedScalarToVector128](#4-duplicateselectedscalartovector128), [DuplicateToVector64](#5-duplicatetovector64), [DuplicateToVector128](#6-duplicatetovector128), [Extract](#7-extract), [ExtractNarrowingLower](#8-extractnarrowinglower), [ExtractNarrowingSaturateLower](#9-extractnarrowingsaturatelower), [ExtractNarrowingSaturateUnsignedLower](#10-extractnarrowingsaturateunsignedlower), [ExtractNarrowingSaturateUnsignedUpper](#11-extractnarrowingsaturateunsignedupper), [ExtractNarrowingSaturateUpper](#12-extractnarrowingsaturateupper), [ExtractNarrowingUpper](#13-extractnarrowingupper), [ExtractVector64](#14-extractvector64), [ExtractVector128](#15-extractvector128), [Floor](#16-floor), [FloorScalar](#17-floorscalar), [FusedAddHalving](#18-fusedaddhalving), [FusedAddRoundedHalving](#19-fusedaddroundedhalving), [FusedMultiplyAdd](#20-fusedmultiplyadd), [FusedMultiplyAddNegatedScalar](#21-fusedmultiplyaddnegatedscalar), [FusedMultiplyAddScalar](#22-fusedmultiplyaddscalar), [FusedMultiplySubtract](#23-fusedmultiplysubtract), [FusedMultiplySubtractNegatedScalar](#24-fusedmultiplysubtractnegatedscalar), [FusedMultiplySubtractScalar](#25-fusedmultiplysubtractscalar), [FusedSubtractHalving](#26-fusedsubtracthalving), [Insert](#27-insert), [InsertScalar](#28-insertscalar), [LeadingSignCount](#29-leadingsigncount), [LeadingZeroCount](#30-leadingzerocount), [LoadAndInsertScalar](#31-loadandinsertscalar), [LoadAndReplicateToVector64](#32-loadandreplicatetovector64), [LoadAndReplicateToVector128](#33-loadandreplicatetovector128), [LoadVector64](#34-loadvector64), [LoadVector128](#35-loadvector128), [Max](#36-max), [MaxNumber](#37-maxnumber), [MaxNumberScalar](#38-maxnumberscalar), [MaxPairwise](#39-maxpairwise), [Min](#40-min), [MinNumber](#41-minnumber), [MinNumberScalar](#42-minnumberscalar), [MinPairwise](#43-minpairwise), [Multiply](#44-multiply), [MultiplyAdd](#45-multiplyadd), [MultiplyAddByScalar](#46-multiplyaddbyscalar), [MultiplyAddBySelectedScalar](#47-multiplyaddbyselectedscalar), [MultiplyByScalar](#48-multiplybyscalar), [MultiplyBySelectedScalar](#49-multiplybyselectedscalar), [MultiplyBySelectedScalarWideningLower](#50-multiplybyselectedscalarwideninglower), [MultiplyBySelectedScalarWideningLowerAndAdd](#51-multiplybyselectedscalarwideninglowerandadd), [MultiplyBySelectedScalarWideningLowerAndSubtract](#52-multiplybyselectedscalarwideninglowerandsubtract), [MultiplyBySelectedScalarWideningUpper](#53-multiplybyselectedscalarwideningupper), [MultiplyBySelectedScalarWideningUpperAndAdd](#54-multiplybyselectedscalarwideningupperandadd), [MultiplyBySelectedScalarWideningUpperAndSubtract](#55-multiplybyselectedscalarwideningupperandsubtract), [MultiplyDoublingByScalarSaturateHigh](#56-multiplydoublingbyscalarsaturatehigh), [MultiplyDoublingBySelectedScalarSaturateHigh](#57-multiplydoublingbyselectedscalarsaturatehigh), [MultiplyDoublingSaturateHigh](#58-multiplydoublingsaturatehigh), [MultiplyDoublingWideningLowerAndAddSaturate](#59-multiplydoublingwideninglowerandaddsaturate), [MultiplyDoublingWideningLowerAndSubtractSaturate](#60-multiplydoublingwideninglowerandsubtractsaturate),[...](Part2.md)






### 1. ConvertToUInt32RoundToZeroScalar

`Vector64<uint> ConvertToUInt32RoundToZeroScalar(Vector64<float> value)`

Performs 'ConvertToUInt32RoundToZeroScalar' operation.

```csharp
private Vector64<uint> ConvertToUInt32RoundToZeroScalarTest(Vector64<float> value)
{
  return AdvSimd.ConvertToUInt32RoundToZeroScalar(value);
}
// value = <11.5, 12.5>
// Result = <11, 0>

```



See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.converttouint32roundtozeroscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ConvertToUInt32RoundToZeroScalarTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[UInt32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M37154_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M37154_IG02:
            ldr     d16, [fp,#24]
            fcvtzu  s16, s16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 4.50
G_M37154_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 12.20, (MethodHash=e6616edd) for method AdvSimdMethods:ConvertToUInt32RoundToZeroScalarTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[UInt32]
; ============================================================


```
------------------------------------------------

### 2. DivideScalar

`Vector64<double> DivideScalar(Vector64<double> left, Vector64<double> right)`

Performs 'DivideScalar' operation.

```csharp
private Vector64<double> DivideScalarTest(Vector64<double> left, Vector64<double> right)
{
  return AdvSimd.DivideScalar(left, right);
}
// left = <11.5>
// right = <11.5>
// Result = <1>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<float> DivideScalar(Vector64<float> left, Vector64<float> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.dividescalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:DivideScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M11794_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M11794_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            fdiv    d16, d16, d17
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 18.50
G_M11794_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 28.00, (MethodHash=8a8cd1ed) for method AdvSimdMethods:DivideScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 3. DuplicateSelectedScalarToVector64

`Vector64<byte> DuplicateSelectedScalarToVector64(Vector64<byte> value, byte index)`

Performs 'DuplicateSelectedScalarToVector64' operation.

```csharp
private Vector64<byte> DuplicateSelectedScalarToVector64Test(Vector64<byte> value, byte index)
{
  return AdvSimd.DuplicateSelectedScalarToVector64(value, index);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// index = 0
// Result = <11, 11, 11, 11, 11, 11, 11, 11>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> DuplicateSelectedScalarToVector64(Vector64<short> value, byte index)
Vector64<int> DuplicateSelectedScalarToVector64(Vector64<int> value, byte index)
Vector64<float> DuplicateSelectedScalarToVector64(Vector64<float> value, byte index)
Vector64<sbyte> DuplicateSelectedScalarToVector64(Vector64<sbyte> value, byte index)
Vector64<ushort> DuplicateSelectedScalarToVector64(Vector64<ushort> value, byte index)
Vector64<uint> DuplicateSelectedScalarToVector64(Vector64<uint> value, byte index)
Vector64<byte> DuplicateSelectedScalarToVector64(Vector128<byte> value, byte index)
Vector64<short> DuplicateSelectedScalarToVector64(Vector128<short> value, byte index)
Vector64<int> DuplicateSelectedScalarToVector64(Vector128<int> value, byte index)
Vector64<float> DuplicateSelectedScalarToVector64(Vector128<float> value, byte index)
Vector64<sbyte> DuplicateSelectedScalarToVector64(Vector128<sbyte> value, byte index)
Vector64<ushort> DuplicateSelectedScalarToVector64(Vector128<ushort> value, byte index)
Vector64<uint> DuplicateSelectedScalarToVector64(Vector128<uint> value, byte index)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.duplicateselectedscalartovector64?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:DuplicateSelectedScalarToVector64Test(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M29602_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M29602_IG02:
            ldr     d0, [fp,#24]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:DuplicateSelectedScalarToVector64(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
						;; bbWeight=1    PerfScore 3.50
G_M29602_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=9c238c5d) for method AdvSimdMethods:DuplicateSelectedScalarToVector64Test(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 4. DuplicateSelectedScalarToVector128

`Vector128<byte> DuplicateSelectedScalarToVector128(Vector64<byte> value, byte index)`

Performs 'DuplicateSelectedScalarToVector128' operation.

```csharp
private Vector128<byte> DuplicateSelectedScalarToVector128Test(Vector64<byte> value, byte index)
{
  return AdvSimd.DuplicateSelectedScalarToVector128(value, index);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// index = 0
// Result = <11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<short> DuplicateSelectedScalarToVector128(Vector64<short> value, byte index)
Vector128<int> DuplicateSelectedScalarToVector128(Vector64<int> value, byte index)
Vector128<float> DuplicateSelectedScalarToVector128(Vector64<float> value, byte index)
Vector128<sbyte> DuplicateSelectedScalarToVector128(Vector64<sbyte> value, byte index)
Vector128<ushort> DuplicateSelectedScalarToVector128(Vector64<ushort> value, byte index)
Vector128<uint> DuplicateSelectedScalarToVector128(Vector64<uint> value, byte index)
Vector128<byte> DuplicateSelectedScalarToVector128(Vector128<byte> value, byte index)
Vector128<short> DuplicateSelectedScalarToVector128(Vector128<short> value, byte index)
Vector128<int> DuplicateSelectedScalarToVector128(Vector128<int> value, byte index)
Vector128<float> DuplicateSelectedScalarToVector128(Vector128<float> value, byte index)
Vector128<sbyte> DuplicateSelectedScalarToVector128(Vector128<sbyte> value, byte index)
Vector128<ushort> DuplicateSelectedScalarToVector128(Vector128<ushort> value, byte index)
Vector128<uint> DuplicateSelectedScalarToVector128(Vector128<uint> value, byte index)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> DuplicateSelectedScalarToVector128(Vector128<double> value, byte index)
Vector128<long> DuplicateSelectedScalarToVector128(Vector128<long> value, byte index)
Vector128<ulong> DuplicateSelectedScalarToVector128(Vector128<ulong> value, byte index)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.duplicateselectedscalartovector128?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.duplicateselectedscalartovector128?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:DuplicateSelectedScalarToVector128Test(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector128`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M33154_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M33154_IG02:
            ldr     d0, [fp,#24]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:DuplicateSelectedScalarToVector128(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector128`1[Byte]
						;; bbWeight=1    PerfScore 3.50
G_M33154_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=c5e67e7d) for method AdvSimdMethods:DuplicateSelectedScalarToVector128Test(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector128`1[Byte]
; ============================================================


```
------------------------------------------------

### 5. DuplicateToVector64

`Vector64<byte> DuplicateToVector64(byte value)`

Performs 'DuplicateToVector64' operation.

```csharp
private Vector64<byte> DuplicateToVector64Test(byte value)
{
  return AdvSimd.DuplicateToVector64(value);
}
// value = 0
// Result = <0, 0, 0, 0, 0, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> DuplicateToVector64(short value)
Vector64<int> DuplicateToVector64(int value)
Vector64<sbyte> DuplicateToVector64(sbyte value)
Vector64<float> DuplicateToVector64(float value)
Vector64<ushort> DuplicateToVector64(ushort value)
Vector64<uint> DuplicateToVector64(uint value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.duplicatetovector64?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:DuplicateToVector64Test(ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00,T00] (  3,  3   )   ubyte  ->   x0        
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 0

G_M1236_IG01:
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M1236_IG02:
            uxtb    w0, w0
            dup     v16.8b, w0
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 3.00
G_M1236_IG03:
            ldp     fp, lr, [sp],#16
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 28, prolog size 8, PerfScore 9.30, (MethodHash=37f0fb2b) for method AdvSimdMethods:DuplicateToVector64Test(ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 6. DuplicateToVector128

`Vector128<byte> DuplicateToVector128(byte value)`

Performs 'DuplicateToVector128' operation.

```csharp
private Vector128<byte> DuplicateToVector128Test(byte value)
{
  return AdvSimd.DuplicateToVector128(value);
}
// value = 0
// Result = <0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<short> DuplicateToVector128(short value)
Vector128<int> DuplicateToVector128(int value)
Vector128<sbyte> DuplicateToVector128(sbyte value)
Vector128<float> DuplicateToVector128(float value)
Vector128<ushort> DuplicateToVector128(ushort value)
Vector128<uint> DuplicateToVector128(uint value)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> DuplicateToVector128(double value)
Vector128<long> DuplicateToVector128(long value)
Vector128<ulong> DuplicateToVector128(ulong value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.duplicatetovector128?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.duplicatetovector128?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:DuplicateToVector128Test(ubyte):System.Runtime.Intrinsics.Vector128`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00,T00] (  3,  3   )   ubyte  ->   x0        
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 0

G_M20148_IG01:
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M20148_IG02:
            uxtb    w0, w0
            dup     v16.16b, w0
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 3.00
G_M20148_IG03:
            ldp     fp, lr, [sp],#16
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 28, prolog size 8, PerfScore 9.30, (MethodHash=c39ab14b) for method AdvSimdMethods:DuplicateToVector128Test(ubyte):System.Runtime.Intrinsics.Vector128`1[Byte]
; ============================================================


```
------------------------------------------------

### 7. Extract

`byte Extract(Vector64<byte> vector, byte index)`

Performs 'Extract' operation.

```csharp
private byte ExtractTest(Vector64<byte> vector, byte index)
{
  return AdvSimd.Extract(vector, index);
}
// vector = <11, 12, 13, 14, 15, 16, 17, 18>
// index = 0
// Result = 11

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
short Extract(Vector64<short> vector, byte index)
int Extract(Vector64<int> vector, byte index)
sbyte Extract(Vector64<sbyte> vector, byte index)
float Extract(Vector64<float> vector, byte index)
ushort Extract(Vector64<ushort> vector, byte index)
uint Extract(Vector64<uint> vector, byte index)
byte Extract(Vector128<byte> vector, byte index)
double Extract(Vector128<double> vector, byte index)
short Extract(Vector128<short> vector, byte index)
int Extract(Vector128<int> vector, byte index)
long Extract(Vector128<long> vector, byte index)
sbyte Extract(Vector128<sbyte> vector, byte index)
float Extract(Vector128<float> vector, byte index)
ushort Extract(Vector128<ushort> vector, byte index)
uint Extract(Vector128<uint> vector, byte index)
ulong Extract(Vector128<ulong> vector, byte index)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.extract?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ExtractTest(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):ubyte
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M47581_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M47581_IG02:
            ldr     d0, [fp,#24]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:Extract(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):ubyte
            uxtb    w0, w0
						;; bbWeight=1    PerfScore 4.00
G_M47581_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 36, prolog size 8, PerfScore 12.10, (MethodHash=7c894622) for method AdvSimdMethods:ExtractTest(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):ubyte
; ============================================================


```
------------------------------------------------

### 8. ExtractNarrowingLower

`Vector64<byte> ExtractNarrowingLower(Vector128<ushort> value)`

Performs 'ExtractNarrowingLower' operation.

```csharp
private Vector64<byte> ExtractNarrowingLowerTest(Vector128<ushort> value)
{
  return AdvSimd.ExtractNarrowingLower(value);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// Result = <11, 12, 13, 14, 15, 16, 17, 18>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> ExtractNarrowingLower(Vector128<int> value)
Vector64<int> ExtractNarrowingLower(Vector128<long> value)
Vector64<sbyte> ExtractNarrowingLower(Vector128<short> value)
Vector64<ushort> ExtractNarrowingLower(Vector128<uint> value)
Vector64<uint> ExtractNarrowingLower(Vector128<ulong> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.extractnarrowinglower?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ExtractNarrowingLowerTest(System.Runtime.Intrinsics.Vector128`1[UInt16]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M51242_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     q0, [fp,#16]
						;; bbWeight=1    PerfScore 2.50
G_M51242_IG02:
            ldr     q16, [fp,#16]
            xtn     v16.8b, v16.8h
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 3.50
G_M51242_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=9eb937d5) for method AdvSimdMethods:ExtractNarrowingLowerTest(System.Runtime.Intrinsics.Vector128`1[UInt16]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 9. ExtractNarrowingSaturateLower

`Vector64<byte> ExtractNarrowingSaturateLower(Vector128<ushort> value)`

Performs 'ExtractNarrowingSaturateLower' operation.

```csharp
private Vector64<byte> ExtractNarrowingSaturateLowerTest(Vector128<ushort> value)
{
  return AdvSimd.ExtractNarrowingSaturateLower(value);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// Result = <11, 12, 13, 14, 15, 16, 17, 18>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> ExtractNarrowingSaturateLower(Vector128<int> value)
Vector64<int> ExtractNarrowingSaturateLower(Vector128<long> value)
Vector64<sbyte> ExtractNarrowingSaturateLower(Vector128<short> value)
Vector64<ushort> ExtractNarrowingSaturateLower(Vector128<uint> value)
Vector64<uint> ExtractNarrowingSaturateLower(Vector128<ulong> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.extractnarrowingsaturatelower?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ExtractNarrowingSaturateLowerTest(System.Runtime.Intrinsics.Vector128`1[UInt16]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M37147_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     q0, [fp,#16]
						;; bbWeight=1    PerfScore 2.50
G_M37147_IG02:
            ldr     q16, [fp,#16]
            uqxtn   v16.8b, v16.8h
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M37147_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=3ad86ee4) for method AdvSimdMethods:ExtractNarrowingSaturateLowerTest(System.Runtime.Intrinsics.Vector128`1[UInt16]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 10. ExtractNarrowingSaturateUnsignedLower

`Vector64<byte> ExtractNarrowingSaturateUnsignedLower(Vector128<short> value)`

Performs 'ExtractNarrowingSaturateUnsignedLower' operation.

```csharp
private Vector64<byte> ExtractNarrowingSaturateUnsignedLowerTest(Vector128<short> value)
{
  return AdvSimd.ExtractNarrowingSaturateUnsignedLower(value);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// Result = <11, 12, 13, 14, 15, 16, 17, 18>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<ushort> ExtractNarrowingSaturateUnsignedLower(Vector128<int> value)
Vector64<uint> ExtractNarrowingSaturateUnsignedLower(Vector128<long> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.extractnarrowingsaturateunsignedlower?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ExtractNarrowingSaturateUnsignedLowerTest(System.Runtime.Intrinsics.Vector128`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M43367_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     q0, [fp,#16]
						;; bbWeight=1    PerfScore 2.50
G_M43367_IG02:
            ldr     q16, [fp,#16]
            sqxtun  v16.8b, v16.8h
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M43367_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=cfe95698) for method AdvSimdMethods:ExtractNarrowingSaturateUnsignedLowerTest(System.Runtime.Intrinsics.Vector128`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 11. ExtractNarrowingSaturateUnsignedUpper

`Vector128<byte> ExtractNarrowingSaturateUnsignedUpper(Vector64<byte> lower, Vector128<short> value)`

Performs 'ExtractNarrowingSaturateUnsignedUpper' operation.

```csharp
private Vector128<byte> ExtractNarrowingSaturateUnsignedUpperTest(Vector64<byte> lower, Vector128<short> value)
{
  return AdvSimd.ExtractNarrowingSaturateUnsignedUpper(lower, value);
}
// lower = <11, 12, 13, 14, 15, 16, 17, 18>
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// Result = <11, 12, 13, 14, 15, 16, 17, 18, 11, 12, 13, 14, 15, 16, 17, 18>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<ushort> ExtractNarrowingSaturateUnsignedUpper(Vector64<ushort> lower, Vector128<int> value)
Vector128<uint> ExtractNarrowingSaturateUnsignedUpper(Vector64<uint> lower, Vector128<long> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.extractnarrowingsaturateunsignedupper?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ExtractNarrowingSaturateUnsignedUpperTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[Int16]):System.Runtime.Intrinsics.Vector128`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M10990_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     q1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M10990_IG02:
            ldr     d16, [fp,#40]
            ldr     q17, [fp,#16]
            sqxtun2 v16.16b, v17.8h
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 7.50
G_M10990_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=eacbd511) for method AdvSimdMethods:ExtractNarrowingSaturateUnsignedUpperTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[Int16]):System.Runtime.Intrinsics.Vector128`1[Byte]
; ============================================================


```
------------------------------------------------

### 12. ExtractNarrowingSaturateUpper

`Vector128<byte> ExtractNarrowingSaturateUpper(Vector64<byte> lower, Vector128<ushort> value)`

Performs 'ExtractNarrowingSaturateUpper' operation.

```csharp
private Vector128<byte> ExtractNarrowingSaturateUpperTest(Vector64<byte> lower, Vector128<ushort> value)
{
  return AdvSimd.ExtractNarrowingSaturateUpper(lower, value);
}
// lower = <11, 12, 13, 14, 15, 16, 17, 18>
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// Result = <11, 12, 13, 14, 15, 16, 17, 18, 11, 12, 13, 14, 15, 16, 17, 18>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<short> ExtractNarrowingSaturateUpper(Vector64<short> lower, Vector128<int> value)
Vector128<int> ExtractNarrowingSaturateUpper(Vector64<int> lower, Vector128<long> value)
Vector128<sbyte> ExtractNarrowingSaturateUpper(Vector64<sbyte> lower, Vector128<short> value)
Vector128<ushort> ExtractNarrowingSaturateUpper(Vector64<ushort> lower, Vector128<uint> value)
Vector128<uint> ExtractNarrowingSaturateUpper(Vector64<uint> lower, Vector128<ulong> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.extractnarrowingsaturateupper?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ExtractNarrowingSaturateUpperTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[UInt16]):System.Runtime.Intrinsics.Vector128`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M36722_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     q1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M36722_IG02:
            ldr     d16, [fp,#40]
            ldr     q17, [fp,#16]
            uqxtn2  v16.16b, v17.8h
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 7.50
G_M36722_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=9b6c708d) for method AdvSimdMethods:ExtractNarrowingSaturateUpperTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[UInt16]):System.Runtime.Intrinsics.Vector128`1[Byte]
; ============================================================


```
------------------------------------------------

### 13. ExtractNarrowingUpper

`Vector128<byte> ExtractNarrowingUpper(Vector64<byte> lower, Vector128<ushort> value)`

Performs 'ExtractNarrowingUpper' operation.

```csharp
private Vector128<byte> ExtractNarrowingUpperTest(Vector64<byte> lower, Vector128<ushort> value)
{
  return AdvSimd.ExtractNarrowingUpper(lower, value);
}
// lower = <11, 12, 13, 14, 15, 16, 17, 18>
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// Result = <11, 12, 13, 14, 15, 16, 17, 18, 11, 12, 13, 14, 15, 16, 17, 18>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<short> ExtractNarrowingUpper(Vector64<short> lower, Vector128<int> value)
Vector128<int> ExtractNarrowingUpper(Vector64<int> lower, Vector128<long> value)
Vector128<sbyte> ExtractNarrowingUpper(Vector64<sbyte> lower, Vector128<short> value)
Vector128<ushort> ExtractNarrowingUpper(Vector64<ushort> lower, Vector128<uint> value)
Vector128<uint> ExtractNarrowingUpper(Vector64<uint> lower, Vector128<ulong> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.extractnarrowingupper?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ExtractNarrowingUpperTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[UInt16]):System.Runtime.Intrinsics.Vector128`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M41795_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     q1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M41795_IG02:
            ldr     d16, [fp,#40]
            ldr     q17, [fp,#16]
            xtn2    v16.16b, v17.8h
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 5.50
G_M41795_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=03b25cbc) for method AdvSimdMethods:ExtractNarrowingUpperTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[UInt16]):System.Runtime.Intrinsics.Vector128`1[Byte]
; ============================================================


```
------------------------------------------------

### 14. ExtractVector64

`Vector64<byte> ExtractVector64(Vector64<byte> upper, Vector64<byte> lower, byte index)`

Performs 'ExtractVector64' operation.

```csharp
private Vector64<byte> ExtractVector64Test(Vector64<byte> upper, Vector64<byte> lower, byte index)
{
  return AdvSimd.ExtractVector64(upper, lower, index);
}
// upper = <11, 12, 13, 14, 15, 16, 17, 18>
// lower = <21, 22, 23, 24, 25, 26, 27, 28>
// index = 0
// Result = <11, 12, 13, 14, 15, 16, 17, 18>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> ExtractVector64(Vector64<short> upper, Vector64<short> lower, byte index)
Vector64<int> ExtractVector64(Vector64<int> upper, Vector64<int> lower, byte index)
Vector64<sbyte> ExtractVector64(Vector64<sbyte> upper, Vector64<sbyte> lower, byte index)
Vector64<float> ExtractVector64(Vector64<float> upper, Vector64<float> lower, byte index)
Vector64<ushort> ExtractVector64(Vector64<ushort> upper, Vector64<ushort> lower, byte index)
Vector64<uint> ExtractVector64(Vector64<uint> upper, Vector64<uint> lower, byte index)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.extractvector64?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ExtractVector64Test(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M32949_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M32949_IG02:
            ldr     d0, [fp,#24]
            ldr     d1, [fp,#16]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:ExtractVector64(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
						;; bbWeight=1    PerfScore 5.50
G_M32949_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=bab07f4a) for method AdvSimdMethods:ExtractVector64Test(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 15. ExtractVector128

`Vector128<byte> ExtractVector128(Vector128<byte> upper, Vector128<byte> lower, byte index)`

Performs 'ExtractVector128' operation.

```csharp
private Vector128<byte> ExtractVector128Test(Vector128<byte> upper, Vector128<byte> lower, byte index)
{
  return AdvSimd.ExtractVector128(upper, lower, index);
}
// upper = <11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26>
// lower = <21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36>
// index = 0
// Result = <11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<double> ExtractVector128(Vector128<double> upper, Vector128<double> lower, byte index)
Vector128<short> ExtractVector128(Vector128<short> upper, Vector128<short> lower, byte index)
Vector128<int> ExtractVector128(Vector128<int> upper, Vector128<int> lower, byte index)
Vector128<long> ExtractVector128(Vector128<long> upper, Vector128<long> lower, byte index)
Vector128<sbyte> ExtractVector128(Vector128<sbyte> upper, Vector128<sbyte> lower, byte index)
Vector128<float> ExtractVector128(Vector128<float> upper, Vector128<float> lower, byte index)
Vector128<ushort> ExtractVector128(Vector128<ushort> upper, Vector128<ushort> lower, byte index)
Vector128<uint> ExtractVector128(Vector128<uint> upper, Vector128<uint> lower, byte index)
Vector128<ulong> ExtractVector128(Vector128<ulong> upper, Vector128<ulong> lower, byte index)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.extractvector128?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ExtractVector128Test(System.Runtime.Intrinsics.Vector128`1[Byte],System.Runtime.Intrinsics.Vector128`1[Byte],ubyte):System.Runtime.Intrinsics.Vector128`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T01] (  2,  4   )  simd16  ->   d0         HFA(simd16)  "Inlining Arg"
;  V05 tmp2         [V05,T02] (  2,  4   )  simd16  ->   d1         HFA(simd16)  "Inlining Arg"
;
; Lcl frame size = 32

G_M41909_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     q0, [fp,#32]
            str     q1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M41909_IG02:
            ldr     q0, [fp,#32]
            ldr     q1, [fp,#16]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:ExtractVector128(System.Runtime.Intrinsics.Vector128`1[Byte],System.Runtime.Intrinsics.Vector128`1[Byte],ubyte):System.Runtime.Intrinsics.Vector128`1[Byte]
						;; bbWeight=1    PerfScore 5.50
G_M41909_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=5d495c4a) for method AdvSimdMethods:ExtractVector128Test(System.Runtime.Intrinsics.Vector128`1[Byte],System.Runtime.Intrinsics.Vector128`1[Byte],ubyte):System.Runtime.Intrinsics.Vector128`1[Byte]
; ============================================================


```
------------------------------------------------

### 16. Floor

`Vector64<float> Floor(Vector64<float> value)`

Performs 'Floor' operation.

```csharp
private Vector64<float> FloorTest(Vector64<float> value)
{
  return AdvSimd.Floor(value);
}
// value = <11.5, 12.5>
// Result = <11, 12>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<float> Floor(Vector128<float> value)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> Floor(Vector128<double> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.floor?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.floor?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:FloorTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M8345_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M8345_IG02:
            ldr     d16, [fp,#24]
            frintm  v16.2s, v16.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M8345_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=4a61df66) for method AdvSimdMethods:FloorTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 17. FloorScalar

`Vector64<double> FloorScalar(Vector64<double> value)`

Performs 'FloorScalar' operation.

```csharp
private Vector64<double> FloorScalarTest(Vector64<double> value)
{
  return AdvSimd.FloorScalar(value);
}
// value = <11.5>
// Result = <11>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<float> FloorScalar(Vector64<float> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.floorscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:FloorScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M28439_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M28439_IG02:
            ldr     d16, [fp,#24]
            frintm  d16, d16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 4.50
G_M28439_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 12.20, (MethodHash=c0b490e8) for method AdvSimdMethods:FloorScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 18. FusedAddHalving

`Vector64<byte> FusedAddHalving(Vector64<byte> left, Vector64<byte> right)`

Performs 'FusedAddHalving' operation.

```csharp
private Vector64<byte> FusedAddHalvingTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.FusedAddHalving(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <16, 17, 18, 19, 20, 21, 22, 23>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> FusedAddHalving(Vector64<short> left, Vector64<short> right)
Vector64<int> FusedAddHalving(Vector64<int> left, Vector64<int> right)
Vector64<sbyte> FusedAddHalving(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<ushort> FusedAddHalving(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> FusedAddHalving(Vector64<uint> left, Vector64<uint> right)
Vector128<byte> FusedAddHalving(Vector128<byte> left, Vector128<byte> right)
Vector128<short> FusedAddHalving(Vector128<short> left, Vector128<short> right)
Vector128<int> FusedAddHalving(Vector128<int> left, Vector128<int> right)
Vector128<sbyte> FusedAddHalving(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<ushort> FusedAddHalving(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> FusedAddHalving(Vector128<uint> left, Vector128<uint> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.fusedaddhalving?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:FusedAddHalvingTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M25187_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M25187_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            uhadd   v16.8b, v16.8b, v17.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M25187_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=d1569d9c) for method AdvSimdMethods:FusedAddHalvingTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 19. FusedAddRoundedHalving

`Vector64<byte> FusedAddRoundedHalving(Vector64<byte> left, Vector64<byte> right)`

Performs 'FusedAddRoundedHalving' operation.

```csharp
private Vector64<byte> FusedAddRoundedHalvingTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.FusedAddRoundedHalving(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <16, 17, 18, 19, 20, 21, 22, 23>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> FusedAddRoundedHalving(Vector64<short> left, Vector64<short> right)
Vector64<int> FusedAddRoundedHalving(Vector64<int> left, Vector64<int> right)
Vector64<sbyte> FusedAddRoundedHalving(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<ushort> FusedAddRoundedHalving(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> FusedAddRoundedHalving(Vector64<uint> left, Vector64<uint> right)
Vector128<byte> FusedAddRoundedHalving(Vector128<byte> left, Vector128<byte> right)
Vector128<short> FusedAddRoundedHalving(Vector128<short> left, Vector128<short> right)
Vector128<int> FusedAddRoundedHalving(Vector128<int> left, Vector128<int> right)
Vector128<sbyte> FusedAddRoundedHalving(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<ushort> FusedAddRoundedHalving(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> FusedAddRoundedHalving(Vector128<uint> left, Vector128<uint> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.fusedaddroundedhalving?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:FusedAddRoundedHalvingTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M54048_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M54048_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            urhadd  v16.8b, v16.8b, v17.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M54048_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=e9b12cdf) for method AdvSimdMethods:FusedAddRoundedHalvingTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 20. FusedMultiplyAdd

`Vector64<float> FusedMultiplyAdd(Vector64<float> addend, Vector64<float> left, Vector64<float> right)`

Performs 'FusedMultiplyAdd' operation.

```csharp
private Vector64<float> FusedMultiplyAddTest(Vector64<float> addend, Vector64<float> left, Vector64<float> right)
{
  return AdvSimd.FusedMultiplyAdd(addend, left, right);
}
// addend = <11.5, 12.5>
// left = <21.5, 22.5>
// right = <11.5, 12.5>
// Result = <258.75, 293.75>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<float> FusedMultiplyAdd(Vector128<float> addend, Vector128<float> left, Vector128<float> right)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> FusedMultiplyAdd(Vector128<double> addend, Vector128<double> left, Vector128<double> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.fusedmultiplyadd?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.fusedmultiplyadd?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:FusedMultiplyAddTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x20]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M52653_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     d1, [fp,#32]
            str     d2, [fp,#24]
						;; bbWeight=1    PerfScore 4.50
G_M52653_IG02:
            ldr     d16, [fp,#40]
            ldr     d17, [fp,#32]
            ldr     d18, [fp,#24]
            fmla    v16.2s, v17.2s, v18.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 9.50
G_M52653_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 20.80, (MethodHash=51473252) for method AdvSimdMethods:FusedMultiplyAddTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 21. FusedMultiplyAddNegatedScalar

`Vector64<double> FusedMultiplyAddNegatedScalar(Vector64<double> addend, Vector64<double> left, Vector64<double> right)`

Performs 'FusedMultiplyAddNegatedScalar' operation.

```csharp
private Vector64<double> FusedMultiplyAddNegatedScalarTest(Vector64<double> addend, Vector64<double> left, Vector64<double> right)
{
  return AdvSimd.FusedMultiplyAddNegatedScalar(addend, left, right);
}
// addend = <11.5>
// left = <11.5>
// right = <11>
// Result = <-138>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<float> FusedMultiplyAddNegatedScalar(Vector64<float> addend, Vector64<float> left, Vector64<float> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.fusedmultiplyaddnegatedscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:FusedMultiplyAddNegatedScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x20]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M22555_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     d1, [fp,#32]
            str     d2, [fp,#24]
						;; bbWeight=1    PerfScore 4.50
G_M22555_IG02:
            ldr     d16, [fp,#40]
            ldr     d17, [fp,#32]
            ldr     d18, [fp,#24]
            fnmadd  d16, d17, d18, d16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 9.50
G_M22555_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 20.80, (MethodHash=ed4ba7e4) for method AdvSimdMethods:FusedMultiplyAddNegatedScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 22. FusedMultiplyAddScalar

`Vector64<double> FusedMultiplyAddScalar(Vector64<double> addend, Vector64<double> left, Vector64<double> right)`

Performs 'FusedMultiplyAddScalar' operation.

```csharp
private Vector64<double> FusedMultiplyAddScalarTest(Vector64<double> addend, Vector64<double> left, Vector64<double> right)
{
  return AdvSimd.FusedMultiplyAddScalar(addend, left, right);
}
// addend = <11.5>
// left = <11.5>
// right = <11>
// Result = <138>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<float> FusedMultiplyAddScalar(Vector64<float> addend, Vector64<float> left, Vector64<float> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.fusedmultiplyaddscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:FusedMultiplyAddScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x20]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M58563_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     d1, [fp,#32]
            str     d2, [fp,#24]
						;; bbWeight=1    PerfScore 4.50
G_M58563_IG02:
            ldr     d16, [fp,#40]
            ldr     d17, [fp,#32]
            ldr     d18, [fp,#24]
            fmadd   d16, d17, d18, d16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 9.50
G_M58563_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 20.80, (MethodHash=6a061b3c) for method AdvSimdMethods:FusedMultiplyAddScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 23. FusedMultiplySubtract

`Vector64<float> FusedMultiplySubtract(Vector64<float> minuend, Vector64<float> left, Vector64<float> right)`

Performs 'FusedMultiplySubtract' operation.

```csharp
private Vector64<float> FusedMultiplySubtractTest(Vector64<float> minuend, Vector64<float> left, Vector64<float> right)
{
  return AdvSimd.FusedMultiplySubtract(minuend, left, right);
}
// minuend = <11.5, 12.5>
// left = <21.5, 22.5>
// right = <11.5, 12.5>
// Result = <-235.75, -268.75>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<float> FusedMultiplySubtract(Vector128<float> minuend, Vector128<float> left, Vector128<float> right)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> FusedMultiplySubtract(Vector128<double> minuend, Vector128<double> left, Vector128<double> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.fusedmultiplysubtract?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.fusedmultiplysubtract?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:FusedMultiplySubtractTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x20]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M28216_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     d1, [fp,#32]
            str     d2, [fp,#24]
						;; bbWeight=1    PerfScore 4.50
G_M28216_IG02:
            ldr     d16, [fp,#40]
            ldr     d17, [fp,#32]
            ldr     d18, [fp,#24]
            fmls    v16.2s, v17.2s, v18.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 9.50
G_M28216_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 20.80, (MethodHash=c63191c7) for method AdvSimdMethods:FusedMultiplySubtractTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 24. FusedMultiplySubtractNegatedScalar

`Vector64<double> FusedMultiplySubtractNegatedScalar(Vector64<double> minuend, Vector64<double> left, Vector64<double> right)`

Performs 'FusedMultiplySubtractNegatedScalar' operation.

```csharp
private Vector64<double> FusedMultiplySubtractNegatedScalarTest(Vector64<double> minuend, Vector64<double> left, Vector64<double> right)
{
  return AdvSimd.FusedMultiplySubtractNegatedScalar(minuend, left, right);
}
// minuend = <11.5>
// left = <11.5>
// right = <11>
// Result = <115>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<float> FusedMultiplySubtractNegatedScalar(Vector64<float> minuend, Vector64<float> left, Vector64<float> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.fusedmultiplysubtractnegatedscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:FusedMultiplySubtractNegatedScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x20]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M57774_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     d1, [fp,#32]
            str     d2, [fp,#24]
						;; bbWeight=1    PerfScore 4.50
G_M57774_IG02:
            ldr     d16, [fp,#40]
            ldr     d17, [fp,#32]
            ldr     d18, [fp,#24]
            fnmsub  d16, d17, d18, d16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 9.50
G_M57774_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 20.80, (MethodHash=19331e51) for method AdvSimdMethods:FusedMultiplySubtractNegatedScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 25. FusedMultiplySubtractScalar

`Vector64<double> FusedMultiplySubtractScalar(Vector64<double> minuend, Vector64<double> left, Vector64<double> right)`

Performs 'FusedMultiplySubtractScalar' operation.

```csharp
private Vector64<double> FusedMultiplySubtractScalarTest(Vector64<double> minuend, Vector64<double> left, Vector64<double> right)
{
  return AdvSimd.FusedMultiplySubtractScalar(minuend, left, right);
}
// minuend = <11.5>
// left = <11.5>
// right = <11>
// Result = <-115>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<float> FusedMultiplySubtractScalar(Vector64<float> minuend, Vector64<float> left, Vector64<float> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.fusedmultiplysubtractscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:FusedMultiplySubtractScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x20]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M12118_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     d1, [fp,#32]
            str     d2, [fp,#24]
						;; bbWeight=1    PerfScore 4.50
G_M12118_IG02:
            ldr     d16, [fp,#40]
            ldr     d17, [fp,#32]
            ldr     d18, [fp,#24]
            fmsub   d16, d17, d18, d16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 9.50
G_M12118_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 20.80, (MethodHash=f4a5d0a9) for method AdvSimdMethods:FusedMultiplySubtractScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 26. FusedSubtractHalving

`Vector64<byte> FusedSubtractHalving(Vector64<byte> left, Vector64<byte> right)`

Performs 'FusedSubtractHalving' operation.

```csharp
private Vector64<byte> FusedSubtractHalvingTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.FusedSubtractHalving(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <251, 251, 251, 251, 251, 251, 251, 251>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> FusedSubtractHalving(Vector64<short> left, Vector64<short> right)
Vector64<int> FusedSubtractHalving(Vector64<int> left, Vector64<int> right)
Vector64<sbyte> FusedSubtractHalving(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<ushort> FusedSubtractHalving(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> FusedSubtractHalving(Vector64<uint> left, Vector64<uint> right)
Vector128<byte> FusedSubtractHalving(Vector128<byte> left, Vector128<byte> right)
Vector128<short> FusedSubtractHalving(Vector128<short> left, Vector128<short> right)
Vector128<int> FusedSubtractHalving(Vector128<int> left, Vector128<int> right)
Vector128<sbyte> FusedSubtractHalving(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<ushort> FusedSubtractHalving(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> FusedSubtractHalving(Vector128<uint> left, Vector128<uint> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.fusedsubtracthalving?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:FusedSubtractHalvingTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M34166_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M34166_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            uhsub   v16.8b, v16.8b, v17.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M34166_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=c42c7a89) for method AdvSimdMethods:FusedSubtractHalvingTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 27. Insert

`Vector64<byte> Insert(Vector64<byte> vector, byte index, byte data)`

Performs 'Insert' operation.

```csharp
private Vector64<byte> InsertTest(Vector64<byte> vector, byte index, byte data)
{
  return AdvSimd.Insert(vector, index, data);
}
// vector = <11, 12, 13, 14, 15, 16, 17, 18>
// index = 0
// data = 1
// Result = <1, 12, 13, 14, 15, 16, 17, 18>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> Insert(Vector64<short> vector, byte index, short data)
Vector64<int> Insert(Vector64<int> vector, byte index, int data)
Vector64<sbyte> Insert(Vector64<sbyte> vector, byte index, sbyte data)
Vector64<float> Insert(Vector64<float> vector, byte index, float data)
Vector64<ushort> Insert(Vector64<ushort> vector, byte index, ushort data)
Vector64<uint> Insert(Vector64<uint> vector, byte index, uint data)
Vector128<byte> Insert(Vector128<byte> vector, byte index, byte data)
Vector128<double> Insert(Vector128<double> vector, byte index, double data)
Vector128<short> Insert(Vector128<short> vector, byte index, short data)
Vector128<int> Insert(Vector128<int> vector, byte index, int data)
Vector128<long> Insert(Vector128<long> vector, byte index, long data)
Vector128<sbyte> Insert(Vector128<sbyte> vector, byte index, sbyte data)
Vector128<float> Insert(Vector128<float> vector, byte index, float data)
Vector128<ushort> Insert(Vector128<ushort> vector, byte index, ushort data)
Vector128<uint> Insert(Vector128<uint> vector, byte index, uint data)
Vector128<ulong> Insert(Vector128<ulong> vector, byte index, ulong data)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.insert?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:InsertTest(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte,ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;  V02 arg2         [V02,T01] (  3,  3   )   ubyte  ->   x1        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T02] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M53206_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M53206_IG02:
            ldr     d0, [fp,#24]
            uxtb    w1, w1
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:Insert(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte,ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
						;; bbWeight=1    PerfScore 4.00
G_M53206_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 36, prolog size 8, PerfScore 12.10, (MethodHash=d2fd3029) for method AdvSimdMethods:InsertTest(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte,ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 28. InsertScalar

`Vector128<double> InsertScalar(Vector128<double> result, byte resultIndex, Vector64<double> value)`

Performs 'InsertScalar' operation.

```csharp
private Vector128<double> InsertScalarTest(Vector128<double> result, byte resultIndex, Vector64<double> value)
{
  return AdvSimd.InsertScalar(result, resultIndex, value);
}
// result = <11.5, 12.5>
// resultIndex = 0
// value = <11.5>
// Result = <11.5, 12.5>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<long> InsertScalar(Vector128<long> result, byte resultIndex, Vector64<long> value)
Vector128<ulong> InsertScalar(Vector128<ulong> result, byte resultIndex, Vector64<ulong> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.insertscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:InsertScalarTest(System.Runtime.Intrinsics.Vector128`1[Double],ubyte,System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector128`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T01] (  2,  4   )  simd16  ->   d0         HFA(simd16)  "Inlining Arg"
;  V05 tmp2         [V05,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 32

G_M45221_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     q0, [fp,#32]
            str     d1, [fp,#24]
						;; bbWeight=1    PerfScore 3.50
G_M45221_IG02:
            ldr     q0, [fp,#32]
            ldr     d1, [fp,#24]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:InsertScalar(System.Runtime.Intrinsics.Vector128`1[Double],ubyte,System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector128`1[Double]
						;; bbWeight=1    PerfScore 5.50
G_M45221_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=5a654f5a) for method AdvSimdMethods:InsertScalarTest(System.Runtime.Intrinsics.Vector128`1[Double],ubyte,System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector128`1[Double]
; ============================================================


```
------------------------------------------------

### 29. LeadingSignCount

`Vector64<short> LeadingSignCount(Vector64<short> value)`

Performs 'LeadingSignCount' operation.

```csharp
private Vector64<short> LeadingSignCountTest(Vector64<short> value)
{
  return AdvSimd.LeadingSignCount(value);
}
// value = <11, 12, 13, 14>
// Result = <11, 11, 11, 11>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<int> LeadingSignCount(Vector64<int> value)
Vector64<sbyte> LeadingSignCount(Vector64<sbyte> value)
Vector128<short> LeadingSignCount(Vector128<short> value)
Vector128<int> LeadingSignCount(Vector128<int> value)
Vector128<sbyte> LeadingSignCount(Vector128<sbyte> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.leadingsigncount?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:LeadingSignCountTest(System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M58653_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M58653_IG02:
            ldr     d16, [fp,#24]
            cls     v16.4h, v16.4h
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 4.50
G_M58653_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 12.20, (MethodHash=a26c1ae2) for method AdvSimdMethods:LeadingSignCountTest(System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 30. LeadingZeroCount

`Vector64<byte> LeadingZeroCount(Vector64<byte> value)`

Performs 'LeadingZeroCount' operation.

```csharp
private Vector64<byte> LeadingZeroCountTest(Vector64<byte> value)
{
  return AdvSimd.LeadingZeroCount(value);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// Result = <4, 4, 4, 4, 4, 3, 3, 3>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> LeadingZeroCount(Vector64<short> value)
Vector64<int> LeadingZeroCount(Vector64<int> value)
Vector64<sbyte> LeadingZeroCount(Vector64<sbyte> value)
Vector64<ushort> LeadingZeroCount(Vector64<ushort> value)
Vector64<uint> LeadingZeroCount(Vector64<uint> value)
Vector128<byte> LeadingZeroCount(Vector128<byte> value)
Vector128<short> LeadingZeroCount(Vector128<short> value)
Vector128<int> LeadingZeroCount(Vector128<int> value)
Vector128<sbyte> LeadingZeroCount(Vector128<sbyte> value)
Vector128<ushort> LeadingZeroCount(Vector128<ushort> value)
Vector128<uint> LeadingZeroCount(Vector128<uint> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.leadingzerocount?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:LeadingZeroCountTest(System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M41676_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M41676_IG02:
            ldr     d16, [fp,#24]
            clz     v16.8b, v16.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 3.50
G_M41676_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=2cdb5d33) for method AdvSimdMethods:LeadingZeroCountTest(System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 31. LoadAndInsertScalar

`Vector64<byte> LoadAndInsertScalar(Vector64<byte> value, byte index, byte* address)`

Performs 'LoadAndInsertScalar' operation.

```csharp
private Vector64<byte> LoadAndInsertScalarTest(Vector64<byte> value, byte index, byte* address)
{
  return AdvSimd.LoadAndInsertScalar(value, index, address);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// index = 0
// address = <address>
// Result = <11, 12, 13, 14, 15, 16, 17, 18>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> LoadAndInsertScalar(Vector64<short> value, byte index, short* address)
Vector64<int> LoadAndInsertScalar(Vector64<int> value, byte index, int* address)
Vector64<sbyte> LoadAndInsertScalar(Vector64<sbyte> value, byte index, sbyte* address)
Vector64<float> LoadAndInsertScalar(Vector64<float> value, byte index, float* address)
Vector64<ushort> LoadAndInsertScalar(Vector64<ushort> value, byte index, ushort* address)
Vector64<uint> LoadAndInsertScalar(Vector64<uint> value, byte index, uint* address)
Vector128<byte> LoadAndInsertScalar(Vector128<byte> value, byte index, byte* address)
Vector128<double> LoadAndInsertScalar(Vector128<double> value, byte index, double* address)
Vector128<short> LoadAndInsertScalar(Vector128<short> value, byte index, short* address)
Vector128<int> LoadAndInsertScalar(Vector128<int> value, byte index, int* address)
Vector128<long> LoadAndInsertScalar(Vector128<long> value, byte index, long* address)
Vector128<sbyte> LoadAndInsertScalar(Vector128<sbyte> value, byte index, sbyte* address)
Vector128<float> LoadAndInsertScalar(Vector128<float> value, byte index, float* address)
Vector128<ushort> LoadAndInsertScalar(Vector128<ushort> value, byte index, ushort* address)
Vector128<uint> LoadAndInsertScalar(Vector128<uint> value, byte index, uint* address)
Vector128<ulong> LoadAndInsertScalar(Vector128<ulong> value, byte index, ulong* address)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.loadandinsertscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:LoadAndInsertScalarTest(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte,long):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;  V02 arg2         [V02,T01] (  3,  3   )    long  ->   x1        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T02] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M13568_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M13568_IG02:
            ldr     d0, [fp,#24]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:LoadAndInsertScalar(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte,long):System.Runtime.Intrinsics.Vector64`1[Byte]
						;; bbWeight=1    PerfScore 3.50
G_M13568_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=084fcaff) for method AdvSimdMethods:LoadAndInsertScalarTest(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte,long):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 32. LoadAndReplicateToVector64

`Vector64<byte> LoadAndReplicateToVector64(byte* address)`

Performs 'LoadAndReplicateToVector64' operation.

```csharp
private Vector64<byte> LoadAndReplicateToVector64Test(byte* address)
{
  return AdvSimd.LoadAndReplicateToVector64(address);
}
// address = <address>
// Result = <11, 11, 11, 11, 11, 11, 11, 11>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> LoadAndReplicateToVector64(short* address)
Vector64<int> LoadAndReplicateToVector64(int* address)
Vector64<sbyte> LoadAndReplicateToVector64(sbyte* address)
Vector64<float> LoadAndReplicateToVector64(float* address)
Vector64<ushort> LoadAndReplicateToVector64(ushort* address)
Vector64<uint> LoadAndReplicateToVector64(uint* address)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.loadandreplicatetovector64?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:LoadAndReplicateToVector64Test(long):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00,T00] (  3,  3   )    long  ->   x0        
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 0

G_M33418_IG01:
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M33418_IG02:
            ld1r    {v16.8b}, [x0]
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 2.50
G_M33418_IG03:
            ldp     fp, lr, [sp],#16
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 8.40, (MethodHash=c5ef7d75) for method AdvSimdMethods:LoadAndReplicateToVector64Test(long):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 33. LoadAndReplicateToVector128

`Vector128<byte> LoadAndReplicateToVector128(byte* address)`

Performs 'LoadAndReplicateToVector128' operation.

```csharp
private Vector128<byte> LoadAndReplicateToVector128Test(byte* address)
{
  return AdvSimd.LoadAndReplicateToVector128(address);
}
// address = <address>
// Result = <11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<short> LoadAndReplicateToVector128(short* address)
Vector128<int> LoadAndReplicateToVector128(int* address)
Vector128<sbyte> LoadAndReplicateToVector128(sbyte* address)
Vector128<float> LoadAndReplicateToVector128(float* address)
Vector128<ushort> LoadAndReplicateToVector128(ushort* address)
Vector128<uint> LoadAndReplicateToVector128(uint* address)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> LoadAndReplicateToVector128(double* address)
Vector128<long> LoadAndReplicateToVector128(long* address)
Vector128<ulong> LoadAndReplicateToVector128(ulong* address)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.loadandreplicatetovector128?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.loadandreplicatetovector128?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:LoadAndReplicateToVector128Test(long):System.Runtime.Intrinsics.Vector128`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00,T00] (  3,  3   )    long  ->   x0        
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 0

G_M4778_IG01:
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M4778_IG02:
            ld1r    {v16.16b}, [x0]
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 2.50
G_M4778_IG03:
            ldp     fp, lr, [sp],#16
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 8.40, (MethodHash=98e5ed55) for method AdvSimdMethods:LoadAndReplicateToVector128Test(long):System.Runtime.Intrinsics.Vector128`1[Byte]
; ============================================================


```
------------------------------------------------

### 34. LoadVector64

`Vector64<byte> LoadVector64(byte* address)`

Performs 'LoadVector64' operation.

```csharp
private Vector64<byte> LoadVector64Test(byte* address)
{
  return AdvSimd.LoadVector64(address);
}
// address = <address>
// Result = <11, 12, 13, 14, 15, 16, 17, 18>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<double> LoadVector64(double* address)
Vector64<short> LoadVector64(short* address)
Vector64<int> LoadVector64(int* address)
Vector64<long> LoadVector64(long* address)
Vector64<sbyte> LoadVector64(sbyte* address)
Vector64<float> LoadVector64(float* address)
Vector64<ushort> LoadVector64(ushort* address)
Vector64<uint> LoadVector64(uint* address)
Vector64<ulong> LoadVector64(ulong* address)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.loadvector64?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:LoadVector64Test(long):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00,T00] (  3,  3   )    long  ->   x0        
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 0

G_M60075_IG01:
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M60075_IG02:
            ld1     {v16.8b}, [x0]
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 2.50
G_M60075_IG03:
            ldp     fp, lr, [sp],#16
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 8.40, (MethodHash=e0841554) for method AdvSimdMethods:LoadVector64Test(long):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 35. LoadVector128

`Vector128<byte> LoadVector128(byte* address)`

Performs 'LoadVector128' operation.

```csharp
private Vector128<byte> LoadVector128Test(byte* address)
{
  return AdvSimd.LoadVector128(address);
}
// address = <address>
// Result = <11, 12, 13, 14, 15, 16, 17, 18, 0, 0, 0, 0, 0, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<double> LoadVector128(double* address)
Vector128<short> LoadVector128(short* address)
Vector128<int> LoadVector128(int* address)
Vector128<long> LoadVector128(long* address)
Vector128<sbyte> LoadVector128(sbyte* address)
Vector128<float> LoadVector128(float* address)
Vector128<ushort> LoadVector128(ushort* address)
Vector128<uint> LoadVector128(uint* address)
Vector128<ulong> LoadVector128(ulong* address)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.loadvector128?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:LoadVector128Test(long):System.Runtime.Intrinsics.Vector128`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00,T00] (  3,  3   )    long  ->   x0        
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 0

G_M62411_IG01:
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M62411_IG02:
            ld1     {v16.16b}, [x0]
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 3.50
G_M62411_IG03:
            ldp     fp, lr, [sp],#16
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 9.40, (MethodHash=75110c34) for method AdvSimdMethods:LoadVector128Test(long):System.Runtime.Intrinsics.Vector128`1[Byte]
; ============================================================


```
------------------------------------------------

### 36. Max

`Vector64<byte> Max(Vector64<byte> left, Vector64<byte> right)`

Performs 'Max' operation.

```csharp
private Vector64<byte> MaxTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.Max(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <21, 22, 23, 24, 25, 26, 27, 28>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> Max(Vector64<short> left, Vector64<short> right)
Vector64<int> Max(Vector64<int> left, Vector64<int> right)
Vector64<sbyte> Max(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<float> Max(Vector64<float> left, Vector64<float> right)
Vector64<ushort> Max(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> Max(Vector64<uint> left, Vector64<uint> right)
Vector128<byte> Max(Vector128<byte> left, Vector128<byte> right)
Vector128<short> Max(Vector128<short> left, Vector128<short> right)
Vector128<int> Max(Vector128<int> left, Vector128<int> right)
Vector128<sbyte> Max(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<float> Max(Vector128<float> left, Vector128<float> right)
Vector128<ushort> Max(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> Max(Vector128<uint> left, Vector128<uint> right)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> Max(Vector128<double> left, Vector128<double> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.max?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.max?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MaxTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M53508_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M53508_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            umax    v16.8b, v16.8b, v17.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M53508_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=016a2efb) for method AdvSimdMethods:MaxTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 37. MaxNumber

`Vector64<float> MaxNumber(Vector64<float> left, Vector64<float> right)`

Performs 'MaxNumber' operation.

```csharp
private Vector64<float> MaxNumberTest(Vector64<float> left, Vector64<float> right)
{
  return AdvSimd.MaxNumber(left, right);
}
// left = <11.5, 12.5>
// right = <21.5, 22.5>
// Result = <21.5, 22.5>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<float> MaxNumber(Vector128<float> left, Vector128<float> right)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> MaxNumber(Vector128<double> left, Vector128<double> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.maxnumber?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.maxnumber?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MaxNumberTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M56215_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M56215_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            fmaxnm  v16.2s, v16.2s, v17.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M56215_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=06372468) for method AdvSimdMethods:MaxNumberTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 38. MaxNumberScalar

`Vector64<double> MaxNumberScalar(Vector64<double> left, Vector64<double> right)`

Performs 'MaxNumberScalar' operation.

```csharp
private Vector64<double> MaxNumberScalarTest(Vector64<double> left, Vector64<double> right)
{
  return AdvSimd.MaxNumberScalar(left, right);
}
// left = <11.5>
// right = <11.5>
// Result = <11.5>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<float> MaxNumberScalar(Vector64<float> left, Vector64<float> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.maxnumberscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MaxNumberScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M62230_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M62230_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            fmaxnm  d16, d16, d17
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M62230_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=ec8d0ce9) for method AdvSimdMethods:MaxNumberScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 39. MaxPairwise

`Vector64<byte> MaxPairwise(Vector64<byte> left, Vector64<byte> right)`

Performs 'MaxPairwise' operation.

```csharp
private Vector64<byte> MaxPairwiseTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.MaxPairwise(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <12, 14, 16, 18, 22, 24, 26, 28>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> MaxPairwise(Vector64<short> left, Vector64<short> right)
Vector64<int> MaxPairwise(Vector64<int> left, Vector64<int> right)
Vector64<sbyte> MaxPairwise(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<float> MaxPairwise(Vector64<float> left, Vector64<float> right)
Vector64<ushort> MaxPairwise(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> MaxPairwise(Vector64<uint> left, Vector64<uint> right)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<byte> MaxPairwise(Vector128<byte> left, Vector128<byte> right)
Vector128<double> MaxPairwise(Vector128<double> left, Vector128<double> right)
Vector128<short> MaxPairwise(Vector128<short> left, Vector128<short> right)
Vector128<int> MaxPairwise(Vector128<int> left, Vector128<int> right)
Vector128<sbyte> MaxPairwise(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<float> MaxPairwise(Vector128<float> left, Vector128<float> right)
Vector128<ushort> MaxPairwise(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> MaxPairwise(Vector128<uint> left, Vector128<uint> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.maxpairwise?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.maxpairwise?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MaxPairwiseTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M12294_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M12294_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            umaxp   v16.8b, v16.8b, v17.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M12294_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=9304cff9) for method AdvSimdMethods:MaxPairwiseTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 40. Min

`Vector64<byte> Min(Vector64<byte> left, Vector64<byte> right)`

Performs 'Min' operation.

```csharp
private Vector64<byte> MinTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.Min(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <11, 12, 13, 14, 15, 16, 17, 18>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> Min(Vector64<short> left, Vector64<short> right)
Vector64<int> Min(Vector64<int> left, Vector64<int> right)
Vector64<sbyte> Min(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<float> Min(Vector64<float> left, Vector64<float> right)
Vector64<ushort> Min(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> Min(Vector64<uint> left, Vector64<uint> right)
Vector128<byte> Min(Vector128<byte> left, Vector128<byte> right)
Vector128<short> Min(Vector128<short> left, Vector128<short> right)
Vector128<int> Min(Vector128<int> left, Vector128<int> right)
Vector128<sbyte> Min(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<float> Min(Vector128<float> left, Vector128<float> right)
Vector128<ushort> Min(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> Min(Vector128<uint> left, Vector128<uint> right)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> Min(Vector128<double> left, Vector128<double> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.min?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.min?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MinTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M10650_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M10650_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            umin    v16.8b, v16.8b, v17.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M10650_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=0551d665) for method AdvSimdMethods:MinTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 41. MinNumber

`Vector64<float> MinNumber(Vector64<float> left, Vector64<float> right)`

Performs 'MinNumber' operation.

```csharp
private Vector64<float> MinNumberTest(Vector64<float> left, Vector64<float> right)
{
  return AdvSimd.MinNumber(left, right);
}
// left = <11.5, 12.5>
// right = <21.5, 22.5>
// Result = <11.5, 12.5>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<float> MinNumber(Vector128<float> left, Vector128<float> right)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> MinNumber(Vector128<double> left, Vector128<double> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.minnumber?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.minnumber?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MinNumberTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M64265_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M64265_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            fminnm  v16.2s, v16.2s, v17.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M64265_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=3b7d04f6) for method AdvSimdMethods:MinNumberTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 42. MinNumberScalar

`Vector64<double> MinNumberScalar(Vector64<double> left, Vector64<double> right)`

Performs 'MinNumberScalar' operation.

```csharp
private Vector64<double> MinNumberScalarTest(Vector64<double> left, Vector64<double> right)
{
  return AdvSimd.MinNumberScalar(left, right);
}
// left = <11.5>
// right = <11.5>
// Result = <11.5>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<float> MinNumberScalar(Vector64<float> left, Vector64<float> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.minnumberscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MinNumberScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M2312_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M2312_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            fminnm  d16, d16, d17
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M2312_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=7a33f6f7) for method AdvSimdMethods:MinNumberScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 43. MinPairwise

`Vector64<byte> MinPairwise(Vector64<byte> left, Vector64<byte> right)`

Performs 'MinPairwise' operation.

```csharp
private Vector64<byte> MinPairwiseTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.MinPairwise(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <11, 13, 15, 17, 21, 23, 25, 27>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> MinPairwise(Vector64<short> left, Vector64<short> right)
Vector64<int> MinPairwise(Vector64<int> left, Vector64<int> right)
Vector64<sbyte> MinPairwise(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<float> MinPairwise(Vector64<float> left, Vector64<float> right)
Vector64<ushort> MinPairwise(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> MinPairwise(Vector64<uint> left, Vector64<uint> right)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<byte> MinPairwise(Vector128<byte> left, Vector128<byte> right)
Vector128<double> MinPairwise(Vector128<double> left, Vector128<double> right)
Vector128<short> MinPairwise(Vector128<short> left, Vector128<short> right)
Vector128<int> MinPairwise(Vector128<int> left, Vector128<int> right)
Vector128<sbyte> MinPairwise(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<float> MinPairwise(Vector128<float> left, Vector128<float> right)
Vector128<ushort> MinPairwise(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> MinPairwise(Vector128<uint> left, Vector128<uint> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.minpairwise?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.minpairwise?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MinPairwiseTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M15256_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M15256_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            uminp   v16.8b, v16.8b, v17.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M15256_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=eaedc467) for method AdvSimdMethods:MinPairwiseTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 44. Multiply

`Vector64<byte> Multiply(Vector64<byte> left, Vector64<byte> right)`

Performs 'Multiply' operation.

```csharp
private Vector64<byte> MultiplyTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.Multiply(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <231, 8, 43, 80, 119, 160, 203, 248>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> Multiply(Vector64<short> left, Vector64<short> right)
Vector64<int> Multiply(Vector64<int> left, Vector64<int> right)
Vector64<sbyte> Multiply(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<float> Multiply(Vector64<float> left, Vector64<float> right)
Vector64<ushort> Multiply(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> Multiply(Vector64<uint> left, Vector64<uint> right)
Vector128<byte> Multiply(Vector128<byte> left, Vector128<byte> right)
Vector128<short> Multiply(Vector128<short> left, Vector128<short> right)
Vector128<int> Multiply(Vector128<int> left, Vector128<int> right)
Vector128<sbyte> Multiply(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<float> Multiply(Vector128<float> left, Vector128<float> right)
Vector128<ushort> Multiply(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> Multiply(Vector128<uint> left, Vector128<uint> right)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> Multiply(Vector128<double> left, Vector128<double> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiply?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.multiply?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M48252_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M48252_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            mul     v16.8b, v16.8b, v17.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M48252_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=14434383) for method AdvSimdMethods:MultiplyTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 45. MultiplyAdd

`Vector64<byte> MultiplyAdd(Vector64<byte> addend, Vector64<byte> left, Vector64<byte> right)`

Performs 'MultiplyAdd' operation.

```csharp
private Vector64<byte> MultiplyAddTest(Vector64<byte> addend, Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.MultiplyAdd(addend, left, right);
}
// addend = <11, 12, 13, 14, 15, 16, 17, 18>
// left = <21, 22, 23, 24, 25, 26, 27, 28>
// right = <31, 32, 33, 34, 35, 36, 37, 38>
// Result = <150, 204, 4, 62, 122, 184, 248, 58>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> MultiplyAdd(Vector64<short> addend, Vector64<short> left, Vector64<short> right)
Vector64<int> MultiplyAdd(Vector64<int> addend, Vector64<int> left, Vector64<int> right)
Vector64<sbyte> MultiplyAdd(Vector64<sbyte> addend, Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<ushort> MultiplyAdd(Vector64<ushort> addend, Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> MultiplyAdd(Vector64<uint> addend, Vector64<uint> left, Vector64<uint> right)
Vector128<byte> MultiplyAdd(Vector128<byte> addend, Vector128<byte> left, Vector128<byte> right)
Vector128<short> MultiplyAdd(Vector128<short> addend, Vector128<short> left, Vector128<short> right)
Vector128<int> MultiplyAdd(Vector128<int> addend, Vector128<int> left, Vector128<int> right)
Vector128<sbyte> MultiplyAdd(Vector128<sbyte> addend, Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<ushort> MultiplyAdd(Vector128<ushort> addend, Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> MultiplyAdd(Vector128<uint> addend, Vector128<uint> left, Vector128<uint> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplyadd?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyAddTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x20]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M31244_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     d1, [fp,#32]
            str     d2, [fp,#24]
						;; bbWeight=1    PerfScore 4.50
G_M31244_IG02:
            ldr     d16, [fp,#40]
            ldr     d17, [fp,#32]
            ldr     d18, [fp,#24]
            mla     v16.8b, v17.8b, v18.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 9.50
G_M31244_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 20.80, (MethodHash=6b6185f3) for method AdvSimdMethods:MultiplyAddTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 46. MultiplyAddByScalar

`Vector64<short> MultiplyAddByScalar(Vector64<short> addend, Vector64<short> left, Vector64<short> right)`

Performs 'MultiplyAddByScalar' operation.

```csharp
private Vector64<short> MultiplyAddByScalarTest(Vector64<short> addend, Vector64<short> left, Vector64<short> right)
{
  return AdvSimd.MultiplyAddByScalar(addend, left, right);
}
// addend = <11, 12, 13, 14>
// left = <21, 22, 23, 24>
// right = <31, 32, 33, 34>
// Result = <662, 694, 726, 758>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<int> MultiplyAddByScalar(Vector64<int> addend, Vector64<int> left, Vector64<int> right)
Vector64<ushort> MultiplyAddByScalar(Vector64<ushort> addend, Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> MultiplyAddByScalar(Vector64<uint> addend, Vector64<uint> left, Vector64<uint> right)
Vector128<short> MultiplyAddByScalar(Vector128<short> addend, Vector128<short> left, Vector64<short> right)
Vector128<int> MultiplyAddByScalar(Vector128<int> addend, Vector128<int> left, Vector64<int> right)
Vector128<ushort> MultiplyAddByScalar(Vector128<ushort> addend, Vector128<ushort> left, Vector64<ushort> right)
Vector128<uint> MultiplyAddByScalar(Vector128<uint> addend, Vector128<uint> left, Vector64<uint> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplyaddbyscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyAddByScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x20]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M57977_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     d1, [fp,#32]
            str     d2, [fp,#24]
						;; bbWeight=1    PerfScore 4.50
G_M57977_IG02:
            ldr     d16, [fp,#40]
            ldr     d17, [fp,#32]
            ldr     d7, [fp,#24]
            mla     v16.4h, v17.4h, v7.h[0]
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 9.50
G_M57977_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 20.80, (MethodHash=f9521d86) for method AdvSimdMethods:MultiplyAddByScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 47. MultiplyAddBySelectedScalar

`Vector64<short> MultiplyAddBySelectedScalar(Vector64<short> addend, Vector64<short> left, Vector64<short> right, byte rightIndex)`

Performs 'MultiplyAddBySelectedScalar' operation.

```csharp
private Vector64<short> MultiplyAddBySelectedScalarTest(Vector64<short> addend, Vector64<short> left, Vector64<short> right, byte rightIndex)
{
  return AdvSimd.MultiplyAddBySelectedScalar(addend, left, right, rightIndex);
}
// addend = <11, 12, 13, 14>
// left = <21, 22, 23, 24>
// right = <31, 32, 33, 34>
// rightIndex = 0
// Result = <662, 694, 726, 758>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> MultiplyAddBySelectedScalar(Vector64<short> addend, Vector64<short> left, Vector128<short> right, byte rightIndex)
Vector64<int> MultiplyAddBySelectedScalar(Vector64<int> addend, Vector64<int> left, Vector64<int> right, byte rightIndex)
Vector64<int> MultiplyAddBySelectedScalar(Vector64<int> addend, Vector64<int> left, Vector128<int> right, byte rightIndex)
Vector64<ushort> MultiplyAddBySelectedScalar(Vector64<ushort> addend, Vector64<ushort> left, Vector64<ushort> right, byte rightIndex)
Vector64<ushort> MultiplyAddBySelectedScalar(Vector64<ushort> addend, Vector64<ushort> left, Vector128<ushort> right, byte rightIndex)
Vector64<uint> MultiplyAddBySelectedScalar(Vector64<uint> addend, Vector64<uint> left, Vector64<uint> right, byte rightIndex)
Vector64<uint> MultiplyAddBySelectedScalar(Vector64<uint> addend, Vector64<uint> left, Vector128<uint> right, byte rightIndex)
Vector128<short> MultiplyAddBySelectedScalar(Vector128<short> addend, Vector128<short> left, Vector64<short> right, byte rightIndex)
Vector128<short> MultiplyAddBySelectedScalar(Vector128<short> addend, Vector128<short> left, Vector128<short> right, byte rightIndex)
Vector128<int> MultiplyAddBySelectedScalar(Vector128<int> addend, Vector128<int> left, Vector64<int> right, byte rightIndex)
Vector128<int> MultiplyAddBySelectedScalar(Vector128<int> addend, Vector128<int> left, Vector128<int> right, byte rightIndex)
Vector128<ushort> MultiplyAddBySelectedScalar(Vector128<ushort> addend, Vector128<ushort> left, Vector64<ushort> right, byte rightIndex)
Vector128<ushort> MultiplyAddBySelectedScalar(Vector128<ushort> addend, Vector128<ushort> left, Vector128<ushort> right, byte rightIndex)
Vector128<uint> MultiplyAddBySelectedScalar(Vector128<uint> addend, Vector128<uint> left, Vector64<uint> right, byte rightIndex)
Vector128<uint> MultiplyAddBySelectedScalar(Vector128<uint> addend, Vector128<uint> left, Vector128<uint> right, byte rightIndex)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplyaddbyselectedscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyAddBySelectedScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x20]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V03 arg3         [V03,T00] (  3,  3   )   ubyte  ->   x0        
;# V04 OutArgs      [V04    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V05 tmp1         [V05,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V06 tmp2         [V06,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;  V07 tmp3         [V07,T03] (  2,  4   )   simd8  ->   d2         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 32

G_M24291_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     d1, [fp,#32]
            str     d2, [fp,#24]
						;; bbWeight=1    PerfScore 4.50
G_M24291_IG02:
            ldr     d0, [fp,#40]
            ldr     d1, [fp,#32]
            ldr     d2, [fp,#24]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:MultiplyAddBySelectedScalar(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
						;; bbWeight=1    PerfScore 7.50
G_M24291_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 18.80, (MethodHash=db83a11c) for method AdvSimdMethods:MultiplyAddBySelectedScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 48. MultiplyByScalar

`Vector64<short> MultiplyByScalar(Vector64<short> left, Vector64<short> right)`

Performs 'MultiplyByScalar' operation.

```csharp
private Vector64<short> MultiplyByScalarTest(Vector64<short> left, Vector64<short> right)
{
  return AdvSimd.MultiplyByScalar(left, right);
}
// left = <11, 12, 13, 14>
// right = <21, 22, 23, 24>
// Result = <231, 252, 273, 294>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<int> MultiplyByScalar(Vector64<int> left, Vector64<int> right)
Vector64<float> MultiplyByScalar(Vector64<float> left, Vector64<float> right)
Vector64<ushort> MultiplyByScalar(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> MultiplyByScalar(Vector64<uint> left, Vector64<uint> right)
Vector128<short> MultiplyByScalar(Vector128<short> left, Vector64<short> right)
Vector128<int> MultiplyByScalar(Vector128<int> left, Vector64<int> right)
Vector128<float> MultiplyByScalar(Vector128<float> left, Vector64<float> right)
Vector128<ushort> MultiplyByScalar(Vector128<ushort> left, Vector64<ushort> right)
Vector128<uint> MultiplyByScalar(Vector128<uint> left, Vector64<uint> right)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> MultiplyByScalar(Vector128<double> left, Vector64<double> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplybyscalar?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.multiplybyscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyByScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M18007_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M18007_IG02:
            ldr     d16, [fp,#24]
            ldr     d7, [fp,#16]
            mul     v16.4h, v16.4h, v7.h[0]
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M18007_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=3ef9b9a8) for method AdvSimdMethods:MultiplyByScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 49. MultiplyBySelectedScalar

`Vector64<short> MultiplyBySelectedScalar(Vector64<short> left, Vector64<short> right, byte rightIndex)`

Performs 'MultiplyBySelectedScalar' operation.

```csharp
private Vector64<short> MultiplyBySelectedScalarTest(Vector64<short> left, Vector64<short> right, byte rightIndex)
{
  return AdvSimd.MultiplyBySelectedScalar(left, right, rightIndex);
}
// left = <11, 12, 13, 14>
// right = <21, 22, 23, 24>
// rightIndex = 0
// Result = <231, 252, 273, 294>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> MultiplyBySelectedScalar(Vector64<short> left, Vector128<short> right, byte rightIndex)
Vector64<int> MultiplyBySelectedScalar(Vector64<int> left, Vector64<int> right, byte rightIndex)
Vector64<int> MultiplyBySelectedScalar(Vector64<int> left, Vector128<int> right, byte rightIndex)
Vector64<float> MultiplyBySelectedScalar(Vector64<float> left, Vector64<float> right, byte rightIndex)
Vector64<float> MultiplyBySelectedScalar(Vector64<float> left, Vector128<float> right, byte rightIndex)
Vector64<ushort> MultiplyBySelectedScalar(Vector64<ushort> left, Vector64<ushort> right, byte rightIndex)
Vector64<ushort> MultiplyBySelectedScalar(Vector64<ushort> left, Vector128<ushort> right, byte rightIndex)
Vector64<uint> MultiplyBySelectedScalar(Vector64<uint> left, Vector64<uint> right, byte rightIndex)
Vector64<uint> MultiplyBySelectedScalar(Vector64<uint> left, Vector128<uint> right, byte rightIndex)
Vector128<short> MultiplyBySelectedScalar(Vector128<short> left, Vector64<short> right, byte rightIndex)
Vector128<short> MultiplyBySelectedScalar(Vector128<short> left, Vector128<short> right, byte rightIndex)
Vector128<int> MultiplyBySelectedScalar(Vector128<int> left, Vector64<int> right, byte rightIndex)
Vector128<int> MultiplyBySelectedScalar(Vector128<int> left, Vector128<int> right, byte rightIndex)
Vector128<float> MultiplyBySelectedScalar(Vector128<float> left, Vector64<float> right, byte rightIndex)
Vector128<float> MultiplyBySelectedScalar(Vector128<float> left, Vector128<float> right, byte rightIndex)
Vector128<ushort> MultiplyBySelectedScalar(Vector128<ushort> left, Vector64<ushort> right, byte rightIndex)
Vector128<ushort> MultiplyBySelectedScalar(Vector128<ushort> left, Vector128<ushort> right, byte rightIndex)
Vector128<uint> MultiplyBySelectedScalar(Vector128<uint> left, Vector64<uint> right, byte rightIndex)
Vector128<uint> MultiplyBySelectedScalar(Vector128<uint> left, Vector128<uint> right, byte rightIndex)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> MultiplyBySelectedScalar(Vector128<double> left, Vector128<double> right, byte rightIndex)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplybyselectedscalar?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.multiplybyselectedscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyBySelectedScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M59917_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M59917_IG02:
            ldr     d0, [fp,#24]
            ldr     d1, [fp,#16]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:MultiplyBySelectedScalar(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
						;; bbWeight=1    PerfScore 5.50
G_M59917_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=36dc15f2) for method AdvSimdMethods:MultiplyBySelectedScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 50. MultiplyBySelectedScalarWideningLower

`Vector128<int> MultiplyBySelectedScalarWideningLower(Vector64<short> left, Vector64<short> right, byte rightIndex)`

Performs 'MultiplyBySelectedScalarWideningLower' operation.

```csharp
private Vector128<int> MultiplyBySelectedScalarWideningLowerTest(Vector64<short> left, Vector64<short> right, byte rightIndex)
{
  return AdvSimd.MultiplyBySelectedScalarWideningLower(left, right, rightIndex);
}
// left = <11, 12, 13, 14>
// right = <21, 22, 23, 24>
// rightIndex = 0
// Result = <231, 252, 273, 294>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<int> MultiplyBySelectedScalarWideningLower(Vector64<short> left, Vector128<short> right, byte rightIndex)
Vector128<long> MultiplyBySelectedScalarWideningLower(Vector64<int> left, Vector64<int> right, byte rightIndex)
Vector128<long> MultiplyBySelectedScalarWideningLower(Vector64<int> left, Vector128<int> right, byte rightIndex)
Vector128<uint> MultiplyBySelectedScalarWideningLower(Vector64<ushort> left, Vector64<ushort> right, byte rightIndex)
Vector128<uint> MultiplyBySelectedScalarWideningLower(Vector64<ushort> left, Vector128<ushort> right, byte rightIndex)
Vector128<ulong> MultiplyBySelectedScalarWideningLower(Vector64<uint> left, Vector64<uint> right, byte rightIndex)
Vector128<ulong> MultiplyBySelectedScalarWideningLower(Vector64<uint> left, Vector128<uint> right, byte rightIndex)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplybyselectedscalarwideninglower?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyBySelectedScalarWideningLowerTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M35040_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M35040_IG02:
            ldr     d0, [fp,#24]
            ldr     d1, [fp,#16]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:MultiplyBySelectedScalarWideningLower(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
						;; bbWeight=1    PerfScore 5.50
G_M35040_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=05e5771f) for method AdvSimdMethods:MultiplyBySelectedScalarWideningLowerTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
; ============================================================


```
------------------------------------------------

### 51. MultiplyBySelectedScalarWideningLowerAndAdd

`Vector128<int> MultiplyBySelectedScalarWideningLowerAndAdd(Vector128<int> addend, Vector64<short> left, Vector64<short> right, byte rightIndex)`

Performs 'MultiplyBySelectedScalarWideningLowerAndAdd' operation.

```csharp
private Vector128<int> MultiplyBySelectedScalarWideningLowerAndAddTest(Vector128<int> addend, Vector64<short> left, Vector64<short> right, byte rightIndex)
{
  return AdvSimd.MultiplyBySelectedScalarWideningLowerAndAdd(addend, left, right, rightIndex);
}
// addend = <11, 12, 13, 14>
// left = <11, 12, 13, 14>
// right = <21, 22, 23, 24>
// rightIndex = 0
// Result = <242, 264, 286, 308>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<int> MultiplyBySelectedScalarWideningLowerAndAdd(Vector128<int> addend, Vector64<short> left, Vector128<short> right, byte rightIndex)
Vector128<long> MultiplyBySelectedScalarWideningLowerAndAdd(Vector128<long> addend, Vector64<int> left, Vector64<int> right, byte rightIndex)
Vector128<long> MultiplyBySelectedScalarWideningLowerAndAdd(Vector128<long> addend, Vector64<int> left, Vector128<int> right, byte rightIndex)
Vector128<uint> MultiplyBySelectedScalarWideningLowerAndAdd(Vector128<uint> addend, Vector64<ushort> left, Vector64<ushort> right, byte rightIndex)
Vector128<uint> MultiplyBySelectedScalarWideningLowerAndAdd(Vector128<uint> addend, Vector64<ushort> left, Vector128<ushort> right, byte rightIndex)
Vector128<ulong> MultiplyBySelectedScalarWideningLowerAndAdd(Vector128<ulong> addend, Vector64<uint> left, Vector64<uint> right, byte rightIndex)
Vector128<ulong> MultiplyBySelectedScalarWideningLowerAndAdd(Vector128<ulong> addend, Vector64<uint> left, Vector128<uint> right, byte rightIndex)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplybyselectedscalarwideninglowerandadd?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyBySelectedScalarWideningLowerAndAddTest(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V03 arg3         [V03,T00] (  3,  3   )   ubyte  ->   x0        
;# V04 OutArgs      [V04    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V05 tmp1         [V05,T01] (  2,  4   )  simd16  ->   d0         HFA(simd16)  "Inlining Arg"
;  V06 tmp2         [V06,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;  V07 tmp3         [V07,T03] (  2,  4   )   simd8  ->   d2         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 32

G_M15162_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     q0, [fp,#32]
            str     d1, [fp,#24]
            str     d2, [fp,#16]
						;; bbWeight=1    PerfScore 4.50
G_M15162_IG02:
            ldr     q0, [fp,#32]
            ldr     d1, [fp,#24]
            ldr     d2, [fp,#16]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:MultiplyBySelectedScalarWideningLowerAndAdd(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
						;; bbWeight=1    PerfScore 7.50
G_M15162_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 18.80, (MethodHash=66b0c4c5) for method AdvSimdMethods:MultiplyBySelectedScalarWideningLowerAndAddTest(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
; ============================================================


```
------------------------------------------------

### 52. MultiplyBySelectedScalarWideningLowerAndSubtract

`Vector128<int> MultiplyBySelectedScalarWideningLowerAndSubtract(Vector128<int> minuend, Vector64<short> left, Vector64<short> right, byte rightIndex)`

Performs 'MultiplyBySelectedScalarWideningLowerAndSubtract' operation.

```csharp
private Vector128<int> MultiplyBySelectedScalarWideningLowerAndSubtractTest(Vector128<int> minuend, Vector64<short> left, Vector64<short> right, byte rightIndex)
{
  return AdvSimd.MultiplyBySelectedScalarWideningLowerAndSubtract(minuend, left, right, rightIndex);
}
// minuend = <11, 12, 13, 14>
// left = <11, 12, 13, 14>
// right = <21, 22, 23, 24>
// rightIndex = 0
// Result = <-220, -240, -260, -280>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<int> MultiplyBySelectedScalarWideningLowerAndSubtract(Vector128<int> minuend, Vector64<short> left, Vector128<short> right, byte rightIndex)
Vector128<long> MultiplyBySelectedScalarWideningLowerAndSubtract(Vector128<long> minuend, Vector64<int> left, Vector64<int> right, byte rightIndex)
Vector128<long> MultiplyBySelectedScalarWideningLowerAndSubtract(Vector128<long> minuend, Vector64<int> left, Vector128<int> right, byte rightIndex)
Vector128<uint> MultiplyBySelectedScalarWideningLowerAndSubtract(Vector128<uint> minuend, Vector64<ushort> left, Vector64<ushort> right, byte rightIndex)
Vector128<uint> MultiplyBySelectedScalarWideningLowerAndSubtract(Vector128<uint> minuend, Vector64<ushort> left, Vector128<ushort> right, byte rightIndex)
Vector128<ulong> MultiplyBySelectedScalarWideningLowerAndSubtract(Vector128<ulong> minuend, Vector64<uint> left, Vector64<uint> right, byte rightIndex)
Vector128<ulong> MultiplyBySelectedScalarWideningLowerAndSubtract(Vector128<ulong> minuend, Vector64<uint> left, Vector128<uint> right, byte rightIndex)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplybyselectedscalarwideninglowerandsubtract?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyBySelectedScalarWideningLowerAndSubtractTest(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V03 arg3         [V03,T00] (  3,  3   )   ubyte  ->   x0        
;# V04 OutArgs      [V04    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V05 tmp1         [V05,T01] (  2,  4   )  simd16  ->   d0         HFA(simd16)  "Inlining Arg"
;  V06 tmp2         [V06,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;  V07 tmp3         [V07,T03] (  2,  4   )   simd8  ->   d2         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 32

G_M24687_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     q0, [fp,#32]
            str     d1, [fp,#24]
            str     d2, [fp,#16]
						;; bbWeight=1    PerfScore 4.50
G_M24687_IG02:
            ldr     q0, [fp,#32]
            ldr     d1, [fp,#24]
            ldr     d2, [fp,#16]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:MultiplyBySelectedScalarWideningLowerAndSubtract(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
						;; bbWeight=1    PerfScore 7.50
G_M24687_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 18.80, (MethodHash=1e629f90) for method AdvSimdMethods:MultiplyBySelectedScalarWideningLowerAndSubtractTest(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
; ============================================================


```
------------------------------------------------

### 53. MultiplyBySelectedScalarWideningUpper

`Vector128<int> MultiplyBySelectedScalarWideningUpper(Vector128<short> left, Vector64<short> right, byte rightIndex)`

Performs 'MultiplyBySelectedScalarWideningUpper' operation.

```csharp
private Vector128<int> MultiplyBySelectedScalarWideningUpperTest(Vector128<short> left, Vector64<short> right, byte rightIndex)
{
  return AdvSimd.MultiplyBySelectedScalarWideningUpper(left, right, rightIndex);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <11, 12, 13, 14>
// rightIndex = 0
// Result = <165, 176, 187, 198>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<int> MultiplyBySelectedScalarWideningUpper(Vector128<short> left, Vector128<short> right, byte rightIndex)
Vector128<long> MultiplyBySelectedScalarWideningUpper(Vector128<int> left, Vector64<int> right, byte rightIndex)
Vector128<long> MultiplyBySelectedScalarWideningUpper(Vector128<int> left, Vector128<int> right, byte rightIndex)
Vector128<uint> MultiplyBySelectedScalarWideningUpper(Vector128<ushort> left, Vector64<ushort> right, byte rightIndex)
Vector128<uint> MultiplyBySelectedScalarWideningUpper(Vector128<ushort> left, Vector128<ushort> right, byte rightIndex)
Vector128<ulong> MultiplyBySelectedScalarWideningUpper(Vector128<uint> left, Vector64<uint> right, byte rightIndex)
Vector128<ulong> MultiplyBySelectedScalarWideningUpper(Vector128<uint> left, Vector128<uint> right, byte rightIndex)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplybyselectedscalarwideningupper?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyBySelectedScalarWideningUpperTest(System.Runtime.Intrinsics.Vector128`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T01] (  2,  4   )  simd16  ->   d0         HFA(simd16)  "Inlining Arg"
;  V05 tmp2         [V05,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 32

G_M8856_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     q0, [fp,#32]
            str     d1, [fp,#24]
						;; bbWeight=1    PerfScore 3.50
G_M8856_IG02:
            ldr     q0, [fp,#32]
            ldr     d1, [fp,#24]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:MultiplyBySelectedScalarWideningUpper(System.Runtime.Intrinsics.Vector128`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
						;; bbWeight=1    PerfScore 5.50
G_M8856_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=b8bcdd67) for method AdvSimdMethods:MultiplyBySelectedScalarWideningUpperTest(System.Runtime.Intrinsics.Vector128`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
; ============================================================


```
------------------------------------------------

### 54. MultiplyBySelectedScalarWideningUpperAndAdd

`Vector128<int> MultiplyBySelectedScalarWideningUpperAndAdd(Vector128<int> addend, Vector128<short> left, Vector64<short> right, byte rightIndex)`

Performs 'MultiplyBySelectedScalarWideningUpperAndAdd' operation.

```csharp
private Vector128<int> MultiplyBySelectedScalarWideningUpperAndAddTest(Vector128<int> addend, Vector128<short> left, Vector64<short> right, byte rightIndex)
{
  return AdvSimd.MultiplyBySelectedScalarWideningUpperAndAdd(addend, left, right, rightIndex);
}
// addend = <11, 12, 13, 14>
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <11, 12, 13, 14>
// rightIndex = 0
// Result = <176, 188, 200, 212>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<int> MultiplyBySelectedScalarWideningUpperAndAdd(Vector128<int> addend, Vector128<short> left, Vector128<short> right, byte rightIndex)
Vector128<long> MultiplyBySelectedScalarWideningUpperAndAdd(Vector128<long> addend, Vector128<int> left, Vector64<int> right, byte rightIndex)
Vector128<long> MultiplyBySelectedScalarWideningUpperAndAdd(Vector128<long> addend, Vector128<int> left, Vector128<int> right, byte rightIndex)
Vector128<uint> MultiplyBySelectedScalarWideningUpperAndAdd(Vector128<uint> addend, Vector128<ushort> left, Vector64<ushort> right, byte rightIndex)
Vector128<uint> MultiplyBySelectedScalarWideningUpperAndAdd(Vector128<uint> addend, Vector128<ushort> left, Vector128<ushort> right, byte rightIndex)
Vector128<ulong> MultiplyBySelectedScalarWideningUpperAndAdd(Vector128<ulong> addend, Vector128<uint> left, Vector64<uint> right, byte rightIndex)
Vector128<ulong> MultiplyBySelectedScalarWideningUpperAndAdd(Vector128<ulong> addend, Vector128<uint> left, Vector128<uint> right, byte rightIndex)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplybyselectedscalarwideningupperandadd?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyBySelectedScalarWideningUpperAndAddTest(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector128`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x30]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V03 arg3         [V03,T00] (  3,  3   )   ubyte  ->   x0        
;# V04 OutArgs      [V04    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V05 tmp1         [V05,T01] (  2,  4   )  simd16  ->   d0         HFA(simd16)  "Inlining Arg"
;  V06 tmp2         [V06,T02] (  2,  4   )  simd16  ->   d1         HFA(simd16)  "Inlining Arg"
;  V07 tmp3         [V07,T03] (  2,  4   )   simd8  ->   d2         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 48

G_M25826_IG01:
            stp     fp, lr, [sp,#-64]!
            mov     fp, sp
            str     q0, [fp,#48]
            str     q1, [fp,#32]
            str     d2, [fp,#24]
						;; bbWeight=1    PerfScore 4.50
G_M25826_IG02:
            ldr     q0, [fp,#48]
            ldr     q1, [fp,#32]
            ldr     d2, [fp,#24]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:MultiplyBySelectedScalarWideningUpperAndAdd(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector128`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
						;; bbWeight=1    PerfScore 7.50
G_M25826_IG03:
            ldp     fp, lr, [sp],#64
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 18.80, (MethodHash=f2549b1d) for method AdvSimdMethods:MultiplyBySelectedScalarWideningUpperAndAddTest(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector128`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
; ============================================================


```
------------------------------------------------

### 55. MultiplyBySelectedScalarWideningUpperAndSubtract

`Vector128<int> MultiplyBySelectedScalarWideningUpperAndSubtract(Vector128<int> minuend, Vector128<short> left, Vector64<short> right, byte rightIndex)`

Performs 'MultiplyBySelectedScalarWideningUpperAndSubtract' operation.

```csharp
private Vector128<int> MultiplyBySelectedScalarWideningUpperAndSubtractTest(Vector128<int> minuend, Vector128<short> left, Vector64<short> right, byte rightIndex)
{
  return AdvSimd.MultiplyBySelectedScalarWideningUpperAndSubtract(minuend, left, right, rightIndex);
}
// minuend = <11, 12, 13, 14>
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <11, 12, 13, 14>
// rightIndex = 0
// Result = <-154, -164, -174, -184>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<int> MultiplyBySelectedScalarWideningUpperAndSubtract(Vector128<int> minuend, Vector128<short> left, Vector128<short> right, byte rightIndex)
Vector128<long> MultiplyBySelectedScalarWideningUpperAndSubtract(Vector128<long> minuend, Vector128<int> left, Vector64<int> right, byte rightIndex)
Vector128<long> MultiplyBySelectedScalarWideningUpperAndSubtract(Vector128<long> minuend, Vector128<int> left, Vector128<int> right, byte rightIndex)
Vector128<uint> MultiplyBySelectedScalarWideningUpperAndSubtract(Vector128<uint> minuend, Vector128<ushort> left, Vector64<ushort> right, byte rightIndex)
Vector128<uint> MultiplyBySelectedScalarWideningUpperAndSubtract(Vector128<uint> minuend, Vector128<ushort> left, Vector128<ushort> right, byte rightIndex)
Vector128<ulong> MultiplyBySelectedScalarWideningUpperAndSubtract(Vector128<ulong> minuend, Vector128<uint> left, Vector64<uint> right, byte rightIndex)
Vector128<ulong> MultiplyBySelectedScalarWideningUpperAndSubtract(Vector128<ulong> minuend, Vector128<uint> left, Vector128<uint> right, byte rightIndex)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplybyselectedscalarwideningupperandsubtract?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyBySelectedScalarWideningUpperAndSubtractTest(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector128`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x30]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V03 arg3         [V03,T00] (  3,  3   )   ubyte  ->   x0        
;# V04 OutArgs      [V04    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V05 tmp1         [V05,T01] (  2,  4   )  simd16  ->   d0         HFA(simd16)  "Inlining Arg"
;  V06 tmp2         [V06,T02] (  2,  4   )  simd16  ->   d1         HFA(simd16)  "Inlining Arg"
;  V07 tmp3         [V07,T03] (  2,  4   )   simd8  ->   d2         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 48

G_M35127_IG01:
            stp     fp, lr, [sp,#-64]!
            mov     fp, sp
            str     q0, [fp,#48]
            str     q1, [fp,#32]
            str     d2, [fp,#24]
						;; bbWeight=1    PerfScore 4.50
G_M35127_IG02:
            ldr     q0, [fp,#48]
            ldr     q1, [fp,#32]
            ldr     d2, [fp,#24]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:MultiplyBySelectedScalarWideningUpperAndSubtract(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector128`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
						;; bbWeight=1    PerfScore 7.50
G_M35127_IG03:
            ldp     fp, lr, [sp],#64
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 18.80, (MethodHash=bad976c8) for method AdvSimdMethods:MultiplyBySelectedScalarWideningUpperAndSubtractTest(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector128`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
; ============================================================


```
------------------------------------------------

### 56. MultiplyDoublingByScalarSaturateHigh

`Vector64<short> MultiplyDoublingByScalarSaturateHigh(Vector64<short> left, Vector64<short> right)`

Performs 'MultiplyDoublingByScalarSaturateHigh' operation.

```csharp
private Vector64<short> MultiplyDoublingByScalarSaturateHighTest(Vector64<short> left, Vector64<short> right)
{
  return AdvSimd.MultiplyDoublingByScalarSaturateHigh(left, right);
}
// left = <11, 12, 13, 14>
// right = <21, 22, 23, 24>
// Result = <0, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<int> MultiplyDoublingByScalarSaturateHigh(Vector64<int> left, Vector64<int> right)
Vector128<short> MultiplyDoublingByScalarSaturateHigh(Vector128<short> left, Vector64<short> right)
Vector128<int> MultiplyDoublingByScalarSaturateHigh(Vector128<int> left, Vector64<int> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplydoublingbyscalarsaturatehigh?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyDoublingByScalarSaturateHighTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M21816_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M21816_IG02:
            ldr     d16, [fp,#24]
            ldr     d7, [fp,#16]
            sqdmulh v16.4h, v16.4h, v7.h[0]
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M21816_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=d12aaac7) for method AdvSimdMethods:MultiplyDoublingByScalarSaturateHighTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 57. MultiplyDoublingBySelectedScalarSaturateHigh

`Vector64<short> MultiplyDoublingBySelectedScalarSaturateHigh(Vector64<short> left, Vector64<short> right, byte rightIndex)`

Performs 'MultiplyDoublingBySelectedScalarSaturateHigh' operation.

```csharp
private Vector64<short> MultiplyDoublingBySelectedScalarSaturateHighTest(Vector64<short> left, Vector64<short> right, byte rightIndex)
{
  return AdvSimd.MultiplyDoublingBySelectedScalarSaturateHigh(left, right, rightIndex);
}
// left = <11, 12, 13, 14>
// right = <21, 22, 23, 24>
// rightIndex = 0
// Result = <0, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> MultiplyDoublingBySelectedScalarSaturateHigh(Vector64<short> left, Vector128<short> right, byte rightIndex)
Vector64<int> MultiplyDoublingBySelectedScalarSaturateHigh(Vector64<int> left, Vector64<int> right, byte rightIndex)
Vector64<int> MultiplyDoublingBySelectedScalarSaturateHigh(Vector64<int> left, Vector128<int> right, byte rightIndex)
Vector128<short> MultiplyDoublingBySelectedScalarSaturateHigh(Vector128<short> left, Vector64<short> right, byte rightIndex)
Vector128<short> MultiplyDoublingBySelectedScalarSaturateHigh(Vector128<short> left, Vector128<short> right, byte rightIndex)
Vector128<int> MultiplyDoublingBySelectedScalarSaturateHigh(Vector128<int> left, Vector64<int> right, byte rightIndex)
Vector128<int> MultiplyDoublingBySelectedScalarSaturateHigh(Vector128<int> left, Vector128<int> right, byte rightIndex)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplydoublingbyselectedscalarsaturatehigh?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyDoublingBySelectedScalarSaturateHighTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M46434_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M46434_IG02:
            ldr     d0, [fp,#24]
            ldr     d1, [fp,#16]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:MultiplyDoublingBySelectedScalarSaturateHigh(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
						;; bbWeight=1    PerfScore 5.50
G_M46434_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=e60b4a9d) for method AdvSimdMethods:MultiplyDoublingBySelectedScalarSaturateHighTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 58. MultiplyDoublingSaturateHigh

`Vector64<short> MultiplyDoublingSaturateHigh(Vector64<short> left, Vector64<short> right)`

Performs 'MultiplyDoublingSaturateHigh' operation.

```csharp
private Vector64<short> MultiplyDoublingSaturateHighTest(Vector64<short> left, Vector64<short> right)
{
  return AdvSimd.MultiplyDoublingSaturateHigh(left, right);
}
// left = <11, 12, 13, 14>
// right = <21, 22, 23, 24>
// Result = <0, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<int> MultiplyDoublingSaturateHigh(Vector64<int> left, Vector64<int> right)
Vector128<short> MultiplyDoublingSaturateHigh(Vector128<short> left, Vector128<short> right)
Vector128<int> MultiplyDoublingSaturateHigh(Vector128<int> left, Vector128<int> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplydoublingsaturatehigh?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyDoublingSaturateHighTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M29357_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M29357_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            sqdmulh v16.4h, v16.4h, v17.4h
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M29357_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=d3cd8d52) for method AdvSimdMethods:MultiplyDoublingSaturateHighTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 59. MultiplyDoublingWideningLowerAndAddSaturate

`Vector128<int> MultiplyDoublingWideningLowerAndAddSaturate(Vector128<int> addend, Vector64<short> left, Vector64<short> right)`

Performs 'MultiplyDoublingWideningLowerAndAddSaturate' operation.

```csharp
private Vector128<int> MultiplyDoublingWideningLowerAndAddSaturateTest(Vector128<int> addend, Vector64<short> left, Vector64<short> right)
{
  return AdvSimd.MultiplyDoublingWideningLowerAndAddSaturate(addend, left, right);
}
// addend = <11, 12, 13, 14>
// left = <11, 12, 13, 14>
// right = <21, 22, 23, 24>
// Result = <473, 540, 611, 686>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<long> MultiplyDoublingWideningLowerAndAddSaturate(Vector128<long> addend, Vector64<int> left, Vector64<int> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplydoublingwideninglowerandaddsaturate?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyDoublingWideningLowerAndAddSaturateTest(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector128`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M27124_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     q0, [fp,#32]
            str     d1, [fp,#24]
            str     d2, [fp,#16]
						;; bbWeight=1    PerfScore 4.50
G_M27124_IG02:
            ldr     q16, [fp,#32]
            ldr     d17, [fp,#24]
            ldr     d18, [fp,#16]
            sqdmlal v16.4s, v17.4h, v18.4h
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 9.50
G_M27124_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 20.80, (MethodHash=061c960b) for method AdvSimdMethods:MultiplyDoublingWideningLowerAndAddSaturateTest(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector128`1[Int32]
; ============================================================


```
------------------------------------------------

### 60. MultiplyDoublingWideningLowerAndSubtractSaturate

`Vector128<int> MultiplyDoublingWideningLowerAndSubtractSaturate(Vector128<int> minuend, Vector64<short> left, Vector64<short> right)`

Performs 'MultiplyDoublingWideningLowerAndSubtractSaturate' operation.

```csharp
private Vector128<int> MultiplyDoublingWideningLowerAndSubtractSaturateTest(Vector128<int> minuend, Vector64<short> left, Vector64<short> right)
{
  return AdvSimd.MultiplyDoublingWideningLowerAndSubtractSaturate(minuend, left, right);
}
// minuend = <11, 12, 13, 14>
// left = <11, 12, 13, 14>
// right = <21, 22, 23, 24>
// Result = <-451, -516, -585, -658>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<long> MultiplyDoublingWideningLowerAndSubtractSaturate(Vector128<long> minuend, Vector64<int> left, Vector64<int> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplydoublingwideninglowerandsubtractsaturate?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyDoublingWideningLowerAndSubtractSaturateTest(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector128`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M22753_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     q0, [fp,#32]
            str     d1, [fp,#24]
            str     d2, [fp,#16]
						;; bbWeight=1    PerfScore 4.50
G_M22753_IG02:
            ldr     q16, [fp,#32]
            ldr     d17, [fp,#24]
            ldr     d18, [fp,#16]
            sqdmlsl v16.4s, v17.4h, v18.4h
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 9.50
G_M22753_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 20.80, (MethodHash=6622a71e) for method AdvSimdMethods:MultiplyDoublingWideningLowerAndSubtractSaturateTest(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector128`1[Int32]
; ============================================================

```

