---
layout: post
title: Arm64 Hardware Intrinsics APIs in .NET - Part 8
subtitle: Sample code usage, examples and generated assembly code
tags: [work, arm64, intrinsics]
---

### Introduction

In my [vectorization using .NET APIs](../2020-08-01-Vectorization-APIs) blog, I describe SIMD datatypes `Vector64<T>` and `Vector128<T>` that operates on 'Arm64 hardware intrinsic' APIs present under [System.Runtime.Intrinsics.Arm.AdvSimd](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.intrinsics.arm.advsimd?view=net-5.0) and [System.Runtime.Intrinsics.Arm.AdvSimd.Arm64](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.intrinsics.arm.advsimd.arm64?view=net-5.0) class. In this post I will describe those hardware intrinsic APIs by showing sample code usage along with examples and generated Arm64 code. This will help people in understanding these APIs so they can use them to optimize their .NET code written to target Arm64. Since there are 360 APIs, describing all of them in a single post will be overwhelming. So I have divided these APIs among 8 blogs and will demonstrate 45 APIs in each blog. This is part 8 of that blog series.

Most of the description of these APIs is adapted and referenced from [Arm Architecture Reference Manual Armv8, for Armv8-A architecture profile document](https://developer.arm.com/documentation/ddi0487/fc/). You can also refer to the description of SIMD and Floating-point instructions description at [Arm developer docs page](https://developer.arm.com/docs/ddi0596/h/simd-and-floating-point-instructions-alphabetic-order).

The blog page is [programmatically generated](../2020-09-12-Automating-Blog-Generation) and might contain mistakes. If you find any mistake, please leave a comment and I will address it.

### APIs covered

| --- | --- |
| [ShiftRightLogicalNarrowingSaturateLower](#1-shiftrightlogicalnarrowingsaturatelower) | [StoreSelectedScalar](#24-storeselectedscalar) |
| [ShiftRightLogicalNarrowingSaturateScalar](#2-shiftrightlogicalnarrowingsaturatescalar) | [Subtract](#25-subtract) |
| [ShiftRightLogicalNarrowingSaturateUpper](#3-shiftrightlogicalnarrowingsaturateupper) | [SubtractHighNarrowingLower](#26-subtracthighnarrowinglower) |
| [ShiftRightLogicalNarrowingUpper](#4-shiftrightlogicalnarrowingupper) | [SubtractHighNarrowingUpper](#27-subtracthighnarrowingupper) |
| [ShiftRightLogicalRounded](#5-shiftrightlogicalrounded) | [SubtractRoundedHighNarrowingLower](#28-subtractroundedhighnarrowinglower) |
| [ShiftRightLogicalRoundedAdd](#6-shiftrightlogicalroundedadd) | [SubtractRoundedHighNarrowingUpper](#29-subtractroundedhighnarrowingupper) |
| [ShiftRightLogicalRoundedAddScalar](#7-shiftrightlogicalroundedaddscalar) | [SubtractSaturate](#30-subtractsaturate) |
| [ShiftRightLogicalRoundedNarrowingLower](#8-shiftrightlogicalroundednarrowinglower) | [SubtractSaturateScalar](#31-subtractsaturatescalar) |
| [ShiftRightLogicalRoundedNarrowingSaturateLower](#9-shiftrightlogicalroundednarrowingsaturatelower) | [SubtractScalar](#32-subtractscalar) |
| [ShiftRightLogicalRoundedNarrowingSaturateScalar](#10-shiftrightlogicalroundednarrowingsaturatescalar) | [SubtractWideningLower](#33-subtractwideninglower) |
| [ShiftRightLogicalRoundedNarrowingSaturateUpper](#11-shiftrightlogicalroundednarrowingsaturateupper) | [SubtractWideningUpper](#34-subtractwideningupper) |
| [ShiftRightLogicalRoundedNarrowingUpper](#12-shiftrightlogicalroundednarrowingupper) | [TransposeEven](#35-transposeeven) |
| [ShiftRightLogicalRoundedScalar](#13-shiftrightlogicalroundedscalar) | [TransposeOdd](#36-transposeodd) |
| [ShiftRightLogicalScalar](#14-shiftrightlogicalscalar) | [UnzipEven](#37-unzipeven) |
| [SignExtendWideningLower](#15-signextendwideninglower) | [UnzipOdd](#38-unzipodd) |
| [SignExtendWideningUpper](#16-signextendwideningupper) | [VectorTableLookup](#39-vectortablelookup) |
| [Sqrt](#17-sqrt) | [VectorTableLookupExtension](#40-vectortablelookupextension) |
| [SqrtScalar](#18-sqrtscalar) | [Xor](#41-xor) |
| [Store](#19-store) | [ZeroExtendWideningLower](#42-zeroextendwideninglower) |
| [StorePair](#20-storepair) | [ZeroExtendWideningUpper](#43-zeroextendwideningupper) |
| [StorePairNonTemporal](#21-storepairnontemporal) | [ZipHigh](#44-ziphigh) |
| [StorePairScalar](#22-storepairscalar) | [ZipLow](#45-ziplow) |
| [StorePairScalarNonTemporal](#23-storepairscalarnontemporal) |  |


<p/>



### 1. ShiftRightLogicalNarrowingSaturateLower

__`Vector64<byte> ShiftRightLogicalNarrowingSaturateLower(Vector128<ushort> value, byte count)`__

This method right shifts each element in the `value` vector, by `count`, saturates each shifted result to a value that is half the original width, stores the final result into a vector, and writes the vector to the result vector. The results are truncated.

```csharp
private Vector64<byte> ShiftRightLogicalNarrowingSaturateLowerTest(Vector128<ushort> value, byte count)
{
  return AdvSimd.ShiftRightLogicalNarrowingSaturateLower(value, 1);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// count = 1
// Result = <5, 6, 6, 7, 7, 8, 8, 9>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> ShiftRightLogicalNarrowingSaturateLower(Vector128<int> value, byte count)
Vector64<int> ShiftRightLogicalNarrowingSaturateLower(Vector128<long> value, byte count)
Vector64<sbyte> ShiftRightLogicalNarrowingSaturateLower(Vector128<short> value, byte count)
Vector64<ushort> ShiftRightLogicalNarrowingSaturateLower(Vector128<uint> value, byte count)
Vector64<uint> ShiftRightLogicalNarrowingSaturateLower(Vector128<ulong> value, byte count)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightlogicalnarrowingsaturatelower?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vqshrn_n_u16).

Assembly generated:

```armasm
; Assembly listing for method AdvSimdMethods:ShiftRightLogicalNarrowingSaturateLowerTest(System.Runtime.Intrinsics.Vector128`1[UInt16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
;
;  V00 arg0         [V00,T00] (  3,  3   )  simd16  ->   d0         HFA(simd16) 
;* V01 arg1         [V01    ] (  0,  0   )   ubyte  ->  zero-ref   
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
; Lcl frame size = 0
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
            uqshrn  v16.8b, v0.8h, #1
            mov     v0.8b, v16.8b
            ldp     fp, lr, [sp],#16
            ret     lr

; Total bytes of code 24, prolog size 8
```
------------------------------------------------

### 2. ShiftRightLogicalNarrowingSaturateScalar

__`Vector64<byte> ShiftRightLogicalNarrowingSaturateScalar(Vector64<ushort> value, byte count)`__

This method right shifts 0th vector element in the `value` vector, by `count`, saturates each shifted result to a value that is half the original width, stores the final result into a vector, and writes the vector to the result vector.

```csharp
private Vector64<byte> ShiftRightLogicalNarrowingSaturateScalarTest(Vector64<ushort> value, byte count)
{
  return AdvSimd.Arm64.ShiftRightLogicalNarrowingSaturateScalar(value, 1);
}
// value = <11, 12, 13, 14>
// count = 1
// Result = <5, 0, 0, 0, 0, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<short> ShiftRightLogicalNarrowingSaturateScalar(Vector64<int> value, byte count)
Vector64<int> ShiftRightLogicalNarrowingSaturateScalar(Vector64<long> value, byte count)
Vector64<sbyte> ShiftRightLogicalNarrowingSaturateScalar(Vector64<short> value, byte count)
Vector64<ushort> ShiftRightLogicalNarrowingSaturateScalar(Vector64<uint> value, byte count)
Vector64<uint> ShiftRightLogicalNarrowingSaturateScalar(Vector64<ulong> value, byte count)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.shiftrightlogicalnarrowingsaturatescalar?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vqshrnh_n_u16).

Assembly generated:

```armasm
; Assembly listing for method AdvSimdMethods:ShiftRightLogicalNarrowingSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[UInt16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
;
;  V00 arg0         [V00,T00] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;* V01 arg1         [V01    ] (  0,  0   )   ubyte  ->  zero-ref   
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
; Lcl frame size = 0
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
            uqshrn  b16, h0, #1
            mov     v0.8b, v16.8b
            ldp     fp, lr, [sp],#16
            ret     lr

; Total bytes of code 24, prolog size 8
```
------------------------------------------------

### 3. ShiftRightLogicalNarrowingSaturateUpper

__`Vector128<byte> ShiftRightLogicalNarrowingSaturateUpper(Vector64<byte> lower, Vector128<ushort> value, byte count)`__

This method right shifts each element in the upper-half of `value` vector, by `count`, saturates each shifted result to a value that is half the original width, stores the final result into a vector, and writes the vector to the upper-half of result vector, lower-half being values from `lower` vector. The results are truncated.

```csharp
private Vector128<byte> ShiftRightLogicalNarrowingSaturateUpperTest(Vector64<byte> lower, Vector128<ushort> value, byte count)
{
  return AdvSimd.ShiftRightLogicalNarrowingSaturateUpper(lower, value, 1);
}
// lower = <11, 12, 13, 14, 15, 16, 17, 18>
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// count = 1
// Result = <11, 12, 13, 14, 15, 16, 17, 18, 5, 6, 6, 7, 7, 8, 8, 9>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<short> ShiftRightLogicalNarrowingSaturateUpper(Vector64<short> lower, Vector128<int> value, byte count)
Vector128<int> ShiftRightLogicalNarrowingSaturateUpper(Vector64<int> lower, Vector128<long> value, byte count)
Vector128<sbyte> ShiftRightLogicalNarrowingSaturateUpper(Vector64<sbyte> lower, Vector128<short> value, byte count)
Vector128<ushort> ShiftRightLogicalNarrowingSaturateUpper(Vector64<ushort> lower, Vector128<uint> value, byte count)
Vector128<uint> ShiftRightLogicalNarrowingSaturateUpper(Vector64<uint> lower, Vector128<ulong> value, byte count)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightlogicalnarrowingsaturateupper?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vqshrn_high_n_u16).

Assembly generated:

```armasm
; Assembly listing for method AdvSimdMethods:ShiftRightLogicalNarrowingSaturateUpperTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[UInt16],ubyte):System.Runtime.Intrinsics.Vector128`1[Byte]
;
;  V00 arg0         [V00,T00] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T01] (  3,  3   )  simd16  ->   d1         HFA(simd16) 
;* V02 arg2         [V02    ] (  0,  0   )   ubyte  ->  zero-ref   
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
; Lcl frame size = 0
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
            uqshrn2 v0.16b, v1.8h, #1
            ldp     fp, lr, [sp],#16
            ret     lr

; Total bytes of code 20, prolog size 8
```
------------------------------------------------

### 4. ShiftRightLogicalNarrowingUpper

__`Vector128<byte> ShiftRightLogicalNarrowingUpper(Vector64<byte> lower, Vector128<ushort> value, byte count)`__

This method right shifts each integer value from the upper-half of `value` vector, by `count`, stores the final result into a vector, and writes the vector to the upper-half of result vector, lower-half being values from `lower` vector. As seen in below example, the result vector element's size `byte` is half as long as the input vector element's size `ushort`. The results are truncated.

```csharp
private Vector128<byte> ShiftRightLogicalNarrowingUpperTest(Vector64<byte> lower, Vector128<ushort> value, byte count)
{
  return AdvSimd.ShiftRightLogicalNarrowingUpper(lower, value, 1);
}
// lower = <11, 12, 13, 14, 15, 16, 17, 18>
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// count = 1
// Result = <11, 12, 13, 14, 15, 16, 17, 18, 5, 6, 6, 7, 7, 8, 8, 9>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<short> ShiftRightLogicalNarrowingUpper(Vector64<short> lower, Vector128<int> value, byte count)
Vector128<int> ShiftRightLogicalNarrowingUpper(Vector64<int> lower, Vector128<long> value, byte count)
Vector128<sbyte> ShiftRightLogicalNarrowingUpper(Vector64<sbyte> lower, Vector128<short> value, byte count)
Vector128<ushort> ShiftRightLogicalNarrowingUpper(Vector64<ushort> lower, Vector128<uint> value, byte count)
Vector128<uint> ShiftRightLogicalNarrowingUpper(Vector64<uint> lower, Vector128<ulong> value, byte count)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightlogicalnarrowingupper?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vshrn_high_n_u16).

Assembly generated:

```armasm
; Assembly listing for method AdvSimdMethods:ShiftRightLogicalNarrowingUpperTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[UInt16],ubyte):System.Runtime.Intrinsics.Vector128`1[Byte]
;
;  V00 arg0         [V00,T00] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T01] (  3,  3   )  simd16  ->   d1         HFA(simd16) 
;* V02 arg2         [V02    ] (  0,  0   )   ubyte  ->  zero-ref   
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
; Lcl frame size = 0
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
            shrn2   v0.16b, v1.8h, #1
            ldp     fp, lr, [sp],#16
            ret     lr

; Total bytes of code 20, prolog size 8
```
------------------------------------------------

### 5. ShiftRightLogicalRounded

__`Vector64<byte> ShiftRightLogicalRounded(Vector64<byte> value, byte count)`__

This method right shifts each element in the `value` vector, by `count`, stores the results in a vector and returns the result vector. The results are rounded.

```csharp
private Vector64<byte> ShiftRightLogicalRoundedTest(Vector64<byte> value, byte count)
{
  return AdvSimd.ShiftRightLogicalRounded(value, 1);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// count = 1
// Result = <6, 6, 7, 7, 8, 8, 9, 9>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> ShiftRightLogicalRounded(Vector64<short> value, byte count)
Vector64<int> ShiftRightLogicalRounded(Vector64<int> value, byte count)
Vector64<sbyte> ShiftRightLogicalRounded(Vector64<sbyte> value, byte count)
Vector64<ushort> ShiftRightLogicalRounded(Vector64<ushort> value, byte count)
Vector64<uint> ShiftRightLogicalRounded(Vector64<uint> value, byte count)
Vector128<byte> ShiftRightLogicalRounded(Vector128<byte> value, byte count)
Vector128<short> ShiftRightLogicalRounded(Vector128<short> value, byte count)
Vector128<int> ShiftRightLogicalRounded(Vector128<int> value, byte count)
Vector128<long> ShiftRightLogicalRounded(Vector128<long> value, byte count)
Vector128<sbyte> ShiftRightLogicalRounded(Vector128<sbyte> value, byte count)
Vector128<ushort> ShiftRightLogicalRounded(Vector128<ushort> value, byte count)
Vector128<uint> ShiftRightLogicalRounded(Vector128<uint> value, byte count)
Vector128<ulong> ShiftRightLogicalRounded(Vector128<ulong> value, byte count)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightlogicalrounded?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vrshr_n_u8).

Assembly generated:

```armasm
; Assembly listing for method AdvSimdMethods:ShiftRightLogicalRoundedTest(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
;
;  V00 arg0         [V00,T00] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;* V01 arg1         [V01    ] (  0,  0   )   ubyte  ->  zero-ref   
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
; Lcl frame size = 0
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
            urshr   v16.8b, v0.8b, #1
            mov     v0.8b, v16.8b
            ldp     fp, lr, [sp],#16
            ret     lr

; Total bytes of code 24, prolog size 8
```
------------------------------------------------

### 6. ShiftRightLogicalRoundedAdd

__`Vector64<byte> ShiftRightLogicalRoundedAdd(Vector64<byte> addend, Vector64<byte> value, byte count)`__

This method right shifts each element in the `value` vector, by `count`, and accumulates the final results with the vector elements of the `addend` vector and return the result vector. The results are rounded.

```csharp
private Vector64<byte> ShiftRightLogicalRoundedAddTest(Vector64<byte> addend, Vector64<byte> value, byte count)
{
  return AdvSimd.ShiftRightLogicalRoundedAdd(addend, value, 1);
}
// addend = <11, 12, 13, 14, 15, 16, 17, 18>
// value = <21, 22, 23, 24, 25, 26, 27, 28>
// count = 1
// Result = <22, 23, 25, 26, 28, 29, 31, 32>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> ShiftRightLogicalRoundedAdd(Vector64<short> addend, Vector64<short> value, byte count)
Vector64<int> ShiftRightLogicalRoundedAdd(Vector64<int> addend, Vector64<int> value, byte count)
Vector64<sbyte> ShiftRightLogicalRoundedAdd(Vector64<sbyte> addend, Vector64<sbyte> value, byte count)
Vector64<ushort> ShiftRightLogicalRoundedAdd(Vector64<ushort> addend, Vector64<ushort> value, byte count)
Vector64<uint> ShiftRightLogicalRoundedAdd(Vector64<uint> addend, Vector64<uint> value, byte count)
Vector128<byte> ShiftRightLogicalRoundedAdd(Vector128<byte> addend, Vector128<byte> value, byte count)
Vector128<short> ShiftRightLogicalRoundedAdd(Vector128<short> addend, Vector128<short> value, byte count)
Vector128<int> ShiftRightLogicalRoundedAdd(Vector128<int> addend, Vector128<int> value, byte count)
Vector128<long> ShiftRightLogicalRoundedAdd(Vector128<long> addend, Vector128<long> value, byte count)
Vector128<sbyte> ShiftRightLogicalRoundedAdd(Vector128<sbyte> addend, Vector128<sbyte> value, byte count)
Vector128<ushort> ShiftRightLogicalRoundedAdd(Vector128<ushort> addend, Vector128<ushort> value, byte count)
Vector128<uint> ShiftRightLogicalRoundedAdd(Vector128<uint> addend, Vector128<uint> value, byte count)
Vector128<ulong> ShiftRightLogicalRoundedAdd(Vector128<ulong> addend, Vector128<ulong> value, byte count)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightlogicalroundedadd?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vrsra_n_u8).

Assembly generated:

```armasm
; Assembly listing for method AdvSimdMethods:ShiftRightLogicalRoundedAddTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
;
;  V00 arg0         [V00,T00] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T01] (  3,  3   )   simd8  ->   d1         HFA(simd8) 
;* V02 arg2         [V02    ] (  0,  0   )   ubyte  ->  zero-ref   
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
; Lcl frame size = 0
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
            ursra   v0.8b, v1.8b, #1
            ldp     fp, lr, [sp],#16
            ret     lr

; Total bytes of code 20, prolog size 8
```
------------------------------------------------

### 7. ShiftRightLogicalRoundedAddScalar

__`Vector64<long> ShiftRightLogicalRoundedAddScalar(Vector64<long> addend, Vector64<long> value, byte count)`__

This method right shifts each element in the `value` vector, by `count`, and accumulates the final results with the vector elements of the `addend` vector and return the result vector. The results are rounded.

```csharp
private Vector64<long> ShiftRightLogicalRoundedAddScalarTest(Vector64<long> addend, Vector64<long> value, byte count)
{
  return AdvSimd.ShiftRightLogicalRoundedAddScalar(addend, value, 1);
}
// addend = <11>
// value = <11>
// count = 1
// Result = <17>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<ulong> ShiftRightLogicalRoundedAddScalar(Vector64<ulong> addend, Vector64<ulong> value, byte count)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightlogicalroundedaddscalar?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vrsra_n_u64).

Assembly generated:

```armasm
; Assembly listing for method AdvSimdMethods:ShiftRightLogicalRoundedAddScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
;
;  V00 arg0         [V00,T00] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T01] (  3,  3   )   simd8  ->   d1         HFA(simd8) 
;* V02 arg2         [V02    ] (  0,  0   )   ubyte  ->  zero-ref   
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
; Lcl frame size = 0
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
            ursra   d0, d1, #1
            ldp     fp, lr, [sp],#16
            ret     lr

; Total bytes of code 20, prolog size 8
```
------------------------------------------------

### 8. ShiftRightLogicalRoundedNarrowingLower

__`Vector64<byte> ShiftRightLogicalRoundedNarrowingLower(Vector128<ushort> value, byte count)`__

This method right shifts each integer value in the `value` vector, by `count`, stoes the final result into a vector, and writes the vector to the result vector. As seen in below example, the result vector element's size `byte` is half as long as the source vector element's size `ushort`. The results are rounded.

```csharp
private Vector64<byte> ShiftRightLogicalRoundedNarrowingLowerTest(Vector128<ushort> value, byte count)
{
  return AdvSimd.ShiftRightLogicalRoundedNarrowingLower(value, 1);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// count = 1
// Result = <6, 6, 7, 7, 8, 8, 9, 9>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> ShiftRightLogicalRoundedNarrowingLower(Vector128<int> value, byte count)
Vector64<int> ShiftRightLogicalRoundedNarrowingLower(Vector128<long> value, byte count)
Vector64<sbyte> ShiftRightLogicalRoundedNarrowingLower(Vector128<short> value, byte count)
Vector64<ushort> ShiftRightLogicalRoundedNarrowingLower(Vector128<uint> value, byte count)
Vector64<uint> ShiftRightLogicalRoundedNarrowingLower(Vector128<ulong> value, byte count)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightlogicalroundednarrowinglower?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vrshrn_n_u16).

Assembly generated:

```armasm
; Assembly listing for method AdvSimdMethods:ShiftRightLogicalRoundedNarrowingLowerTest(System.Runtime.Intrinsics.Vector128`1[UInt16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
;
;  V00 arg0         [V00,T00] (  3,  3   )  simd16  ->   d0         HFA(simd16) 
;* V01 arg1         [V01    ] (  0,  0   )   ubyte  ->  zero-ref   
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
; Lcl frame size = 0
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
            rshrn   v16.8b, v0.8h, #1
            mov     v0.8b, v16.8b
            ldp     fp, lr, [sp],#16
            ret     lr

; Total bytes of code 24, prolog size 8
```
------------------------------------------------

### 9. ShiftRightLogicalRoundedNarrowingSaturateLower

__`Vector64<byte> ShiftRightLogicalRoundedNarrowingSaturateLower(Vector128<ushort> value, byte count)`__

This method right shifts each element in the `value` vector, by `count`, saturates each shifted result to a value that is half the original width, stores the final result into a vector, and writes the vector to the result vector. The results are rounded.

```csharp
private Vector64<byte> ShiftRightLogicalRoundedNarrowingSaturateLowerTest(Vector128<ushort> value, byte count)
{
  return AdvSimd.ShiftRightLogicalRoundedNarrowingSaturateLower(value, 1);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// count = 1
// Result = <6, 6, 7, 7, 8, 8, 9, 9>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> ShiftRightLogicalRoundedNarrowingSaturateLower(Vector128<int> value, byte count)
Vector64<int> ShiftRightLogicalRoundedNarrowingSaturateLower(Vector128<long> value, byte count)
Vector64<sbyte> ShiftRightLogicalRoundedNarrowingSaturateLower(Vector128<short> value, byte count)
Vector64<ushort> ShiftRightLogicalRoundedNarrowingSaturateLower(Vector128<uint> value, byte count)
Vector64<uint> ShiftRightLogicalRoundedNarrowingSaturateLower(Vector128<ulong> value, byte count)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightlogicalroundednarrowingsaturatelower?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vqrshrn_n_u16).

Assembly generated:

```armasm
; Assembly listing for method AdvSimdMethods:ShiftRightLogicalRoundedNarrowingSaturateLowerTest(System.Runtime.Intrinsics.Vector128`1[UInt16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
;
;  V00 arg0         [V00,T00] (  3,  3   )  simd16  ->   d0         HFA(simd16) 
;* V01 arg1         [V01    ] (  0,  0   )   ubyte  ->  zero-ref   
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
; Lcl frame size = 0
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
            uqrshrn v16.8b, v0.8h, #1
            mov     v0.8b, v16.8b
            ldp     fp, lr, [sp],#16
            ret     lr

; Total bytes of code 24, prolog size 8
```
------------------------------------------------

### 10. ShiftRightLogicalRoundedNarrowingSaturateScalar

__`Vector64<byte> ShiftRightLogicalRoundedNarrowingSaturateScalar(Vector64<ushort> value, byte count)`__

This method right shifts 0th vector element in the `value` vector, by `count`, saturates each shifted result to a value that is half the original width, stores the final result into a vector, and writes the vector to the result vector.

```csharp
private Vector64<byte> ShiftRightLogicalRoundedNarrowingSaturateScalarTest(Vector64<ushort> value, byte count)
{
  return AdvSimd.Arm64.ShiftRightLogicalRoundedNarrowingSaturateScalar(value, 1);
}
// value = <11, 12, 13, 14>
// count = 1
// Result = <6, 0, 0, 0, 0, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<short> ShiftRightLogicalRoundedNarrowingSaturateScalar(Vector64<int> value, byte count)
Vector64<int> ShiftRightLogicalRoundedNarrowingSaturateScalar(Vector64<long> value, byte count)
Vector64<sbyte> ShiftRightLogicalRoundedNarrowingSaturateScalar(Vector64<short> value, byte count)
Vector64<ushort> ShiftRightLogicalRoundedNarrowingSaturateScalar(Vector64<uint> value, byte count)
Vector64<uint> ShiftRightLogicalRoundedNarrowingSaturateScalar(Vector64<ulong> value, byte count)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.shiftrightlogicalroundednarrowingsaturatescalar?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vqrshrnh_n_u16).

Assembly generated:

```armasm
; Assembly listing for method AdvSimdMethods:ShiftRightLogicalRoundedNarrowingSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[UInt16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
;
;  V00 arg0         [V00,T00] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;* V01 arg1         [V01    ] (  0,  0   )   ubyte  ->  zero-ref   
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
; Lcl frame size = 0
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
            uqrshrn b16, h0, #1
            mov     v0.8b, v16.8b
            ldp     fp, lr, [sp],#16
            ret     lr

; Total bytes of code 24, prolog size 8
```
------------------------------------------------

### 11. ShiftRightLogicalRoundedNarrowingSaturateUpper

__`Vector128<byte> ShiftRightLogicalRoundedNarrowingSaturateUpper(Vector64<byte> lower, Vector128<ushort> value, byte count)`__

This method right shifts each element in the upper-half of `value` vector, by `count`, stores the final result into a vector, and writes the vector to the upper-half of result vector, lower-half being the values from `lower` vector. The results are rounded. As per ARM docs, if overflow occurs with any of the results, those results are saturated.

```csharp
private Vector128<byte> ShiftRightLogicalRoundedNarrowingSaturateUpperTest(Vector64<byte> lower, Vector128<ushort> value, byte count)
{
  return AdvSimd.ShiftRightLogicalRoundedNarrowingSaturateUpper(lower, value, 1);
}
// lower = <11, 12, 13, 14, 15, 16, 17, 18>
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// count = 1
// Result = <11, 12, 13, 14, 15, 16, 17, 18, 6, 6, 7, 7, 8, 8, 9, 9>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<short> ShiftRightLogicalRoundedNarrowingSaturateUpper(Vector64<short> lower, Vector128<int> value, byte count)
Vector128<int> ShiftRightLogicalRoundedNarrowingSaturateUpper(Vector64<int> lower, Vector128<long> value, byte count)
Vector128<sbyte> ShiftRightLogicalRoundedNarrowingSaturateUpper(Vector64<sbyte> lower, Vector128<short> value, byte count)
Vector128<ushort> ShiftRightLogicalRoundedNarrowingSaturateUpper(Vector64<ushort> lower, Vector128<uint> value, byte count)
Vector128<uint> ShiftRightLogicalRoundedNarrowingSaturateUpper(Vector64<uint> lower, Vector128<ulong> value, byte count)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightlogicalroundednarrowingsaturateupper?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vqrshrn_high_n_u16).

Assembly generated:

```armasm
; Assembly listing for method AdvSimdMethods:ShiftRightLogicalRoundedNarrowingSaturateUpperTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[UInt16],ubyte):System.Runtime.Intrinsics.Vector128`1[Byte]
;
;  V00 arg0         [V00,T00] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T01] (  3,  3   )  simd16  ->   d1         HFA(simd16) 
;* V02 arg2         [V02    ] (  0,  0   )   ubyte  ->  zero-ref   
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
; Lcl frame size = 0
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
            uqrshrn2 v0.16b, v1.8h, #1
            ldp     fp, lr, [sp],#16
            ret     lr

; Total bytes of code 20, prolog size 8
```
------------------------------------------------

### 12. ShiftRightLogicalRoundedNarrowingUpper

__`Vector128<byte> ShiftRightLogicalRoundedNarrowingUpper(Vector64<byte> lower, Vector128<ushort> value, byte count)`__

This method right shifts each integer value from the upper-half of `value` vector, by `count`, writes the final result to a vector, and writes the vector to the upper-half of result vector, the lower-half being values from `lower` vector. As seen in below example, the result vector element's size `byte` is half as long as the input vector element's size `ushort`. The results are rounded.

```csharp
private Vector128<byte> ShiftRightLogicalRoundedNarrowingUpperTest(Vector64<byte> lower, Vector128<ushort> value, byte count)
{
  return AdvSimd.ShiftRightLogicalRoundedNarrowingUpper(lower, value, 1);
}
// lower = <11, 12, 13, 14, 15, 16, 17, 18>
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// count = 1
// Result = <11, 12, 13, 14, 15, 16, 17, 18, 6, 6, 7, 7, 8, 8, 9, 9>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<short> ShiftRightLogicalRoundedNarrowingUpper(Vector64<short> lower, Vector128<int> value, byte count)
Vector128<int> ShiftRightLogicalRoundedNarrowingUpper(Vector64<int> lower, Vector128<long> value, byte count)
Vector128<sbyte> ShiftRightLogicalRoundedNarrowingUpper(Vector64<sbyte> lower, Vector128<short> value, byte count)
Vector128<ushort> ShiftRightLogicalRoundedNarrowingUpper(Vector64<ushort> lower, Vector128<uint> value, byte count)
Vector128<uint> ShiftRightLogicalRoundedNarrowingUpper(Vector64<uint> lower, Vector128<ulong> value, byte count)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightlogicalroundednarrowingupper?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vrshrn_high_n_u16).

Assembly generated:

```armasm
; Assembly listing for method AdvSimdMethods:ShiftRightLogicalRoundedNarrowingUpperTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[UInt16],ubyte):System.Runtime.Intrinsics.Vector128`1[Byte]
;
;  V00 arg0         [V00,T00] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T01] (  3,  3   )  simd16  ->   d1         HFA(simd16) 
;* V02 arg2         [V02    ] (  0,  0   )   ubyte  ->  zero-ref   
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
; Lcl frame size = 0
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
            rshrn2  v0.16b, v1.8h, #1
            ldp     fp, lr, [sp],#16
            ret     lr

; Total bytes of code 20, prolog size 8
```
------------------------------------------------

### 13. ShiftRightLogicalRoundedScalar

__`Vector64<long> ShiftRightLogicalRoundedScalar(Vector64<long> value, byte count)`__

This method right shifts each element in the `value` vector, by `count`, stores the results in a vector and returns the result vector. The results are rounded.

```csharp
private Vector64<long> ShiftRightLogicalRoundedScalarTest(Vector64<long> value, byte count)
{
  return AdvSimd.ShiftRightLogicalRoundedScalar(value, 1);
}
// value = <11>
// count = 1
// Result = <6>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<ulong> ShiftRightLogicalRoundedScalar(Vector64<ulong> value, byte count)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightlogicalroundedscalar?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vrshr_n_u64).

Assembly generated:

```armasm
; Assembly listing for method AdvSimdMethods:ShiftRightLogicalRoundedScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
;
;  V00 arg0         [V00,T00] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;* V01 arg1         [V01    ] (  0,  0   )   ubyte  ->  zero-ref   
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
; Lcl frame size = 0
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
            urshr   d16, d0, #1
            mov     v0.8b, v16.8b
            ldp     fp, lr, [sp],#16
            ret     lr

; Total bytes of code 24, prolog size 8
```
------------------------------------------------

### 14. ShiftRightLogicalScalar

__`Vector64<long> ShiftRightLogicalScalar(Vector64<long> value, byte count)`__

This method right shifts each vector element in the `value` vector, by `count`, stores the results in a vector and returns the result vector. The results are truncated.

```csharp
private Vector64<long> ShiftRightLogicalScalarTest(Vector64<long> value, byte count)
{
  return AdvSimd.ShiftRightLogicalScalar(value, 1);
}
// value = <11>
// count = 1
// Result = <5>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<ulong> ShiftRightLogicalScalar(Vector64<ulong> value, byte count)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightlogicalscalar?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vshr_n_u64).

Assembly generated:

```armasm
; Assembly listing for method AdvSimdMethods:ShiftRightLogicalScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
;
;  V00 arg0         [V00,T00] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;* V01 arg1         [V01    ] (  0,  0   )   ubyte  ->  zero-ref   
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
; Lcl frame size = 0
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
            ushr    d16, d0, #1
            mov     v0.8b, v16.8b
            ldp     fp, lr, [sp],#16
            ret     lr

; Total bytes of code 24, prolog size 8
```
------------------------------------------------

### 15. SignExtendWideningLower

__`Vector128<int> SignExtendWideningLower(Vector64<short> value)`__

This method duplicates each vector element in the `value` into a vector, and writes the vector to the result vector. As seen in below example, number of result vector elements are twice as long as the input vector elements. All the values in this method are signed integer values.

```csharp
private Vector128<int> SignExtendWideningLowerTest(Vector64<short> value)
{
  return AdvSimd.SignExtendWideningLower(value);
}
// value = <11, -12, 13, 14>
// Result = <11, -12, 13, 14>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<long> SignExtendWideningLower(Vector64<int> value)
Vector128<short> SignExtendWideningLower(Vector64<sbyte> value)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.signextendwideninglower?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vmovl_s16).

Assembly generated:

```armasm
; Assembly listing for method AdvSimdMethods:SignExtendWideningLowerTest(System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector128`1[Int32]
;
;  V00 arg0         [V00,T00] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
; Lcl frame size = 0
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
            sxtl    v16.4s, v0.4h
            mov     v0.16b, v16.16b
            ldp     fp, lr, [sp],#16
            ret     lr

; Total bytes of code 24, prolog size 8
```
------------------------------------------------

### 16. SignExtendWideningUpper

__`Vector128<int> SignExtendWideningUpper(Vector128<short> value)`__

This method duplicates each vector element in the upper half of the `value` into a vector, and writes the vector to the result vector. As seen in below example, the destination vector element's  size `int` is twice as long as the input vector element's size `short`. All the values in this method are signed integer values. 

```csharp
private Vector128<int> SignExtendWideningUpperTest(Vector128<short> value)
{
  return AdvSimd.SignExtendWideningUpper(value);
}
// value = <11, 12, 13, 14, -15, 16, 17, 18>
// Result = <-15, 16, 17, 18>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<long> SignExtendWideningUpper(Vector128<int> value)
Vector128<short> SignExtendWideningUpper(Vector128<sbyte> value)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.signextendwideningupper?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vmovl_high_s16).

Assembly generated:

```armasm
; Assembly listing for method AdvSimdMethods:SignExtendWideningUpperTest(System.Runtime.Intrinsics.Vector128`1[Int16]):System.Runtime.Intrinsics.Vector128`1[Int32]
;
;  V00 arg0         [V00,T00] (  3,  3   )  simd16  ->   d0         HFA(simd16) 
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
; Lcl frame size = 0
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
            sxtl2   v16.4s, v0.8h
            mov     v0.16b, v16.16b
            ldp     fp, lr, [sp],#16
            ret     lr

; Total bytes of code 24, prolog size 8
```
------------------------------------------------

### 17. Sqrt

__`Vector64<float> Sqrt(Vector64<float> value)`__

This method calculates the square root for each vector element in the`value` vector, stores the results in a vector and returns the result vector.

```csharp
private Vector64<float> SqrtTest(Vector64<float> value)
{
  return AdvSimd.Arm64.Sqrt(value);
}
// value = <11.5, 12.5>
// Result = <3.391165, 3.535534>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> Sqrt(Vector128<double> value)
Vector128<float> Sqrt(Vector128<float> value)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.sqrt?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vsqrt_f32).

Assembly generated:

```armasm
; Assembly listing for method AdvSimdMethods:SqrtTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
;
;  V00 arg0         [V00,T00] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
; Lcl frame size = 0
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
            fsqrt   v16.2s, v0.2s
            mov     v0.8b, v16.8b
            ldp     fp, lr, [sp],#16
            ret     lr

; Total bytes of code 24, prolog size 8
```
------------------------------------------------

### 18. SqrtScalar

__`Vector64<double> SqrtScalar(Vector64<double> value)`__

This method calculates the square root of the value in the `value` vector and returns the result.

```csharp
private Vector64<double> SqrtScalarTest(Vector64<double> value)
{
  return AdvSimd.SqrtScalar(value);
}
// value = <11.5>
// Result = <3.391164991562634>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<float> SqrtScalar(Vector64<float> value)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.sqrtscalar?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vsqrt_f64).

Assembly generated:

```armasm
; Assembly listing for method AdvSimdMethods:SqrtScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
;
;  V00 arg0         [V00,T00] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
; Lcl frame size = 0
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
            fsqrt   d16, d0
            mov     v0.8b, v16.8b
            ldp     fp, lr, [sp],#16
            ret     lr

; Total bytes of code 24, prolog size 8
```
------------------------------------------------

### 19. Store

__`void Store(byte* address, Vector64<byte> source)`__

This method stores the `source` vector to memory. In below example, it would copy all the elements to the array `byte[]` as much it can fit. E.g. if byte[] address was of 5 elements, it would just copy 5 elements into it and if there were 10 elements, it would copy the 8 elements from `source` and keep remaining values in memory untouched.

```csharp
private void StoreTest(byte* address, Vector64<byte> source)
{
  AdvSimd.Store(address, source);
}
// address = Address to byte[] where `source` needs to be stored.
// source = <11, 12, 13, 14, 15, 16, 17, 18>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
void Store(double* address, Vector64<double> source)
void Store(short* address, Vector64<short> source)
void Store(int* address, Vector64<int> source)
void Store(long* address, Vector64<long> source)
void Store(sbyte* address, Vector64<sbyte> source)
void Store(float* address, Vector64<float> source)
void Store(ushort* address, Vector64<ushort> source)
void Store(uint* address, Vector64<uint> source)
void Store(ulong* address, Vector64<ulong> source)
void Store(byte* address, Vector128<byte> source)
void Store(double* address, Vector128<double> source)
void Store(short* address, Vector128<short> source)
void Store(int* address, Vector128<int> source)
void Store(long* address, Vector128<long> source)
void Store(sbyte* address, Vector128<sbyte> source)
void Store(float* address, Vector128<float> source)
void Store(ushort* address, Vector128<ushort> source)
void Store(uint* address, Vector128<uint> source)
void Store(ulong* address, Vector128<ulong> source)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.store?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vst1_u8).

Assembly generated:

```armasm
; Assembly listing for method AdvSimdMethods:StoreTest(long,System.Runtime.Intrinsics.Vector64`1[Byte])
;
;  V00 arg0         [V00,T00] (  3,  3   )    long  ->   x0        
;  V01 arg1         [V01,T01] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
; Lcl frame size = 0
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
            st1     {v0.8b}, [x0]
            ldp     fp, lr, [sp],#16
            ret     lr

; Total bytes of code 20, prolog size 8
```
------------------------------------------------

### 20. StorePair

__`void StorePair(byte* address, Vector64<byte> value1, Vector64<byte> value2)`__

Store pair of vectors `value1` and `value2` in memory whose address is given in `address`.

```csharp
private void StorePairTest(byte* address, Vector64<byte> value1, Vector64<byte> value2)
{
  AdvSimd.Arm64.StorePair(address, value1, value2);
}
// address = Address of `byte[]` or likewise
// value1 = <11, 12, 13, 14, 15, 16, 17, 18>
// value2 = <21, 22, 23, 24, 25, 26, 27, 28>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
void StorePair(double* address, Vector64<double> value1, Vector64<double> value2)
void StorePair(short* address, Vector64<short> value1, Vector64<short> value2)
void StorePair(int* address, Vector64<int> value1, Vector64<int> value2)
void StorePair(long* address, Vector64<long> value1, Vector64<long> value2)
void StorePair(sbyte* address, Vector64<sbyte> value1, Vector64<sbyte> value2)
void StorePair(float* address, Vector64<float> value1, Vector64<float> value2)
void StorePair(ushort* address, Vector64<ushort> value1, Vector64<ushort> value2)
void StorePair(uint* address, Vector64<uint> value1, Vector64<uint> value2)
void StorePair(ulong* address, Vector64<ulong> value1, Vector64<ulong> value2)
void StorePair(byte* address, Vector128<byte> value1, Vector128<byte> value2)
void StorePair(double* address, Vector128<double> value1, Vector128<double> value2)
void StorePair(short* address, Vector128<short> value1, Vector128<short> value2)
void StorePair(int* address, Vector128<int> value1, Vector128<int> value2)
void StorePair(long* address, Vector128<long> value1, Vector128<long> value2)
void StorePair(sbyte* address, Vector128<sbyte> value1, Vector128<sbyte> value2)
void StorePair(float* address, Vector128<float> value1, Vector128<float> value2)
void StorePair(ushort* address, Vector128<ushort> value1, Vector128<ushort> value2)
void StorePair(uint* address, Vector128<uint> value1, Vector128<uint> value2)
void StorePair(ulong* address, Vector128<ulong> value1, Vector128<ulong> value2)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.storepair?view=net-5.0).

Assembly generated:

```armasm
; Assembly listing for method AdvSimdMethods:StorePairTest(long,System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte])
;
;  V00 arg0         [V00,T00] (  3,  3   )    long  ->   x0        
;  V01 arg1         [V01,T01] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V02 arg2         [V02,T02] (  3,  3   )   simd8  ->   d1         HFA(simd8) 
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
; Lcl frame size = 0
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
            stp     d0, d1, [x0]
            ldp     fp, lr, [sp],#16
            ret     lr

; Total bytes of code 20, prolog size 8
```
------------------------------------------------

### 21. StorePairNonTemporal

__`void StorePairNonTemporal(byte* address, Vector64<byte> value1, Vector64<byte> value2)`__

Store pair of vectors `value1` and `value2`, with non-temporal hint, in memory whose address is given in `address`.

```csharp
private void StorePairNonTemporalTest(byte* address, Vector64<byte> value1, Vector64<byte> value2)
{
  AdvSimd.Arm64.StorePairNonTemporal(address, value1, value2);
}
// address = <address>
// value1 = <11, 12, 13, 14, 15, 16, 17, 18>
// value2 = <21, 22, 23, 24, 25, 26, 27, 28>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
void StorePairNonTemporal(double* address, Vector64<double> value1, Vector64<double> value2)
void StorePairNonTemporal(short* address, Vector64<short> value1, Vector64<short> value2)
void StorePairNonTemporal(int* address, Vector64<int> value1, Vector64<int> value2)
void StorePairNonTemporal(long* address, Vector64<long> value1, Vector64<long> value2)
void StorePairNonTemporal(sbyte* address, Vector64<sbyte> value1, Vector64<sbyte> value2)
void StorePairNonTemporal(float* address, Vector64<float> value1, Vector64<float> value2)
void StorePairNonTemporal(ushort* address, Vector64<ushort> value1, Vector64<ushort> value2)
void StorePairNonTemporal(uint* address, Vector64<uint> value1, Vector64<uint> value2)
void StorePairNonTemporal(ulong* address, Vector64<ulong> value1, Vector64<ulong> value2)
void StorePairNonTemporal(byte* address, Vector128<byte> value1, Vector128<byte> value2)
void StorePairNonTemporal(double* address, Vector128<double> value1, Vector128<double> value2)
void StorePairNonTemporal(short* address, Vector128<short> value1, Vector128<short> value2)
void StorePairNonTemporal(int* address, Vector128<int> value1, Vector128<int> value2)
void StorePairNonTemporal(long* address, Vector128<long> value1, Vector128<long> value2)
void StorePairNonTemporal(sbyte* address, Vector128<sbyte> value1, Vector128<sbyte> value2)
void StorePairNonTemporal(float* address, Vector128<float> value1, Vector128<float> value2)
void StorePairNonTemporal(ushort* address, Vector128<ushort> value1, Vector128<ushort> value2)
void StorePairNonTemporal(uint* address, Vector128<uint> value1, Vector128<uint> value2)
void StorePairNonTemporal(ulong* address, Vector128<ulong> value1, Vector128<ulong> value2)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.storepairnontemporal?view=net-5.0).

Assembly generated:

```armasm
; Assembly listing for method AdvSimdMethods:StorePairNonTemporalTest(long,System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte])
;
;  V00 arg0         [V00,T00] (  3,  3   )    long  ->   x0        
;  V01 arg1         [V01,T01] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V02 arg2         [V02,T02] (  3,  3   )   simd8  ->   d1         HFA(simd8) 
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
; Lcl frame size = 0
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
            stnp    d0, d1, [x0]
            ldp     fp, lr, [sp],#16
            ret     lr

; Total bytes of code 20, prolog size 8
```
------------------------------------------------

### 22. StorePairScalar

__`void StorePairScalar(int* address, Vector64<int> value1, Vector64<int> value2)`__

This method stores a pair of `value1` and `value2` vectors to memory whose address is passed in `address`. Only the 0th element from each vector is stored in `address`.

```csharp
private void StorePairScalarTest(int* address, Vector64<int> value1, Vector64<int> value2)
{
  AdvSimd.Arm64.StorePairScalar(address, value1, value2);
}
// address = <address>
// value1 = <11, 12>
// value2 = <21, 22>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
void StorePairScalar(float* address, Vector64<float> value1, Vector64<float> value2)
void StorePairScalar(uint* address, Vector64<uint> value1, Vector64<uint> value2)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.storepairscalar?view=net-5.0).

Assembly generated:

```armasm
; Assembly listing for method AdvSimdMethods:StorePairScalarTest(long,System.Runtime.Intrinsics.Vector64`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int32])
;
;  V00 arg0         [V00,T00] (  3,  3   )    long  ->   x0        
;  V01 arg1         [V01,T01] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V02 arg2         [V02,T02] (  3,  3   )   simd8  ->   d1         HFA(simd8) 
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
; Lcl frame size = 0
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
            stp     s0, s1, [x0]
            ldp     fp, lr, [sp],#16
            ret     lr

; Total bytes of code 20, prolog size 8
```
------------------------------------------------

### 23. StorePairScalarNonTemporal

__`void StorePairScalarNonTemporal(int* address, Vector64<int> value1, Vector64<int> value2)`__

This method stores a pair of `value1` and `value2` vectors to memory, issuing a hint to the memory system that the access is non-temporal,  whose address is passed in `address`. Only the 0th element from each vector is stored in `address`.

```csharp
private void StorePairScalarNonTemporalTest(int* address, Vector64<int> value1, Vector64<int> value2)
{
  AdvSimd.Arm64.StorePairScalarNonTemporal(address, value1, value2);
}
// address = <address>
// value1 = <11, 12>
// value2 = <21, 22>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
void StorePairScalarNonTemporal(float* address, Vector64<float> value1, Vector64<float> value2)
void StorePairScalarNonTemporal(uint* address, Vector64<uint> value1, Vector64<uint> value2)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.storepairscalarnontemporal?view=net-5.0).

Assembly generated:

```armasm
; Assembly listing for method AdvSimdMethods:StorePairScalarNonTemporalTest(long,System.Runtime.Intrinsics.Vector64`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int32])
;
;  V00 arg0         [V00,T00] (  3,  3   )    long  ->   x0        
;  V01 arg1         [V01,T01] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V02 arg2         [V02,T02] (  3,  3   )   simd8  ->   d1         HFA(simd8) 
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
; Lcl frame size = 0
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
            stnp    s0, s1, [x0]
            ldp     fp, lr, [sp],#16
            ret     lr

; Total bytes of code 20, prolog size 8
```
------------------------------------------------

### 24. StoreSelectedScalar

__`void StoreSelectedScalar(byte* address, Vector64<byte> value, byte index)`__

This method stores the specified element `index` of the `source` vector to memory. In below example, it would copy `14` to 0th element of `byte[]` whose address is passed.

```csharp
private void StoreSelectedScalarTest(byte* address, Vector64<byte> value, byte index)
{
  AdvSimd.StoreSelectedScalar(address, value, 3);
}
// address = Address to memory e.g. address of byte[]
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// index = 3

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
void StoreSelectedScalar(short* address, Vector64<short> value, byte index)
void StoreSelectedScalar(int* address, Vector64<int> value, byte index)
void StoreSelectedScalar(sbyte* address, Vector64<sbyte> value, byte index)
void StoreSelectedScalar(float* address, Vector64<float> value, byte index)
void StoreSelectedScalar(ushort* address, Vector64<ushort> value, byte index)
void StoreSelectedScalar(uint* address, Vector64<uint> value, byte index)
void StoreSelectedScalar(byte* address, Vector128<byte> value, byte index)
void StoreSelectedScalar(double* address, Vector128<double> value, byte index)
void StoreSelectedScalar(short* address, Vector128<short> value, byte index)
void StoreSelectedScalar(int* address, Vector128<int> value, byte index)
void StoreSelectedScalar(long* address, Vector128<long> value, byte index)
void StoreSelectedScalar(sbyte* address, Vector128<sbyte> value, byte index)
void StoreSelectedScalar(float* address, Vector128<float> value, byte index)
void StoreSelectedScalar(ushort* address, Vector128<ushort> value, byte index)
void StoreSelectedScalar(uint* address, Vector128<uint> value, byte index)
void StoreSelectedScalar(ulong* address, Vector128<ulong> value, byte index)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.storeselectedscalar?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vst1_lane_u8).

Assembly generated:

```armasm
; Assembly listing for method AdvSimdMethods:StoreSelectedScalarTest(long,System.Runtime.Intrinsics.Vector64`1[Byte],ubyte)
;
;  V00 arg0         [V00,T00] (  3,  3   )    long  ->   x0        
;  V01 arg1         [V01,T01] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;* V02 arg2         [V02    ] (  0,  0   )   ubyte  ->  zero-ref   
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
; Lcl frame size = 0
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
            st1     {v0.b}[3], [x0]
            ldp     fp, lr, [sp],#16
            ret     lr

; Total bytes of code 20, prolog size 8
```
------------------------------------------------

### 25. Subtract

__`Vector64<byte> Subtract(Vector64<byte> left, Vector64<byte> right)`__

This method subtracts each vector element in the `right` vector from the corresponding vector element in the `left` vector, stores the results in a vector and returns the result vector.

```csharp
private Vector64<byte> SubtractTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.Subtract(left, right);
}
// left = <21, 22, 23, 24, 25, 26, 27, 18>
// right = <11, 12, 13, 14, 15, 16, 17, 28>
// Result = <10, 10, 10, 10, 10, 10, 10, 246>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> Subtract(Vector64<short> left, Vector64<short> right)
Vector64<int> Subtract(Vector64<int> left, Vector64<int> right)
Vector64<sbyte> Subtract(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<float> Subtract(Vector64<float> left, Vector64<float> right)
Vector64<ushort> Subtract(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> Subtract(Vector64<uint> left, Vector64<uint> right)
Vector128<byte> Subtract(Vector128<byte> left, Vector128<byte> right)
Vector128<short> Subtract(Vector128<short> left, Vector128<short> right)
Vector128<int> Subtract(Vector128<int> left, Vector128<int> right)
Vector128<long> Subtract(Vector128<long> left, Vector128<long> right)
Vector128<sbyte> Subtract(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<float> Subtract(Vector128<float> left, Vector128<float> right)
Vector128<ushort> Subtract(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> Subtract(Vector128<uint> left, Vector128<uint> right)
Vector128<ulong> Subtract(Vector128<ulong> left, Vector128<ulong> right)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> Subtract(Vector128<double> left, Vector128<double> right)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.subtract?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.subtract?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vsub_u8).

Assembly generated:

```armasm
; Assembly listing for method AdvSimdMethods:SubtractTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
;
;  V00 arg0         [V00,T00] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T01] (  3,  3   )   simd8  ->   d1         HFA(simd8) 
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
; Lcl frame size = 0
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
            sub     v16.8b, v0.8b, v1.8b
            mov     v0.8b, v16.8b
            ldp     fp, lr, [sp],#16
            ret     lr

; Total bytes of code 24, prolog size 8
```
------------------------------------------------

### 26. SubtractHighNarrowingLower

__`Vector64<byte> SubtractHighNarrowingLower(Vector128<ushort> left, Vector128<ushort> right)`__

This method subtracts each vector element in the `right` vector from the corresponding vector element in the `left` vector, stores the most significant half of the result into a vector, and writes the vector to the result vector.

```csharp
private Vector64<byte> SubtractHighNarrowingLowerTest(Vector128<ushort> left, Vector128<ushort> right)
{
  return AdvSimd.SubtractHighNarrowingLower(left, right);
}
// left = <1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000>
// right = <10, 20, 30 , 40, 50, 60, 70, 80>
// Result = <3, 7, 11, 15, 19, 23, 27, 30>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> SubtractHighNarrowingLower(Vector128<int> left, Vector128<int> right)
Vector64<int> SubtractHighNarrowingLower(Vector128<long> left, Vector128<long> right)
Vector64<sbyte> SubtractHighNarrowingLower(Vector128<short> left, Vector128<short> right)
Vector64<ushort> SubtractHighNarrowingLower(Vector128<uint> left, Vector128<uint> right)
Vector64<uint> SubtractHighNarrowingLower(Vector128<ulong> left, Vector128<ulong> right)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.subtracthighnarrowinglower?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vsubhn_u16).

Assembly generated:

```armasm
; Assembly listing for method AdvSimdMethods:SubtractHighNarrowingLowerTest(System.Runtime.Intrinsics.Vector128`1[UInt16],System.Runtime.Intrinsics.Vector128`1[UInt16]):System.Runtime.Intrinsics.Vector64`1[Byte]
;
;  V00 arg0         [V00,T00] (  3,  3   )  simd16  ->   d0         HFA(simd16) 
;  V01 arg1         [V01,T01] (  3,  3   )  simd16  ->   d1         HFA(simd16) 
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
; Lcl frame size = 0
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
            subhn   v16.8b, v0.8h, v1.8h
            mov     v0.8b, v16.8b
            ldp     fp, lr, [sp],#16
            ret     lr

; Total bytes of code 24, prolog size 8
```
------------------------------------------------

### 27. SubtractHighNarrowingUpper

__`Vector128<byte> SubtractHighNarrowingUpper(Vector64<byte> lower, Vector128<ushort> left, Vector128<ushort> right)`__

This method subtracts each vector element in the `right` vector from the corresponding vector element in the `left` vector, stores the most significant half of the result into a vector, and writes the vector to the upper half of the result vector.

```csharp
private Vector128<byte> SubtractHighNarrowingUpperTest(Vector64<byte> lower, Vector128<ushort> left, Vector128<ushort> right)
{
  return AdvSimd.SubtractHighNarrowingUpper(lower, left, right);
}
// lower = <5, 5, 5, 5, 5, 5, 5, 5>
// left = <1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000>
// right = <10, 20, 30 , 40, 50, 60, 70, 80>
// Result = <5, 5, 5, 5, 5, 5, 5, 5, 3, 7, 11, 15, 19, 23, 27, 30>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<short> SubtractHighNarrowingUpper(Vector64<short> lower, Vector128<int> left, Vector128<int> right)
Vector128<int> SubtractHighNarrowingUpper(Vector64<int> lower, Vector128<long> left, Vector128<long> right)
Vector128<sbyte> SubtractHighNarrowingUpper(Vector64<sbyte> lower, Vector128<short> left, Vector128<short> right)
Vector128<ushort> SubtractHighNarrowingUpper(Vector64<ushort> lower, Vector128<uint> left, Vector128<uint> right)
Vector128<uint> SubtractHighNarrowingUpper(Vector64<uint> lower, Vector128<ulong> left, Vector128<ulong> right)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.subtracthighnarrowingupper?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vsubhn_high_u16).

Assembly generated:

```armasm
; Assembly listing for method AdvSimdMethods:SubtractHighNarrowingUpperTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[UInt16],System.Runtime.Intrinsics.Vector128`1[UInt16]):System.Runtime.Intrinsics.Vector128`1[Byte]
;
;  V00 arg0         [V00,T00] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T01] (  3,  3   )  simd16  ->   d1         HFA(simd16) 
;  V02 arg2         [V02,T02] (  3,  3   )  simd16  ->   d2         HFA(simd16) 
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
; Lcl frame size = 0
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
            subhn2  v0.16b, v1.8h, v2.8h
            ldp     fp, lr, [sp],#16
            ret     lr

; Total bytes of code 20, prolog size 8
```
------------------------------------------------

### 28. SubtractRoundedHighNarrowingLower

__`Vector64<byte> SubtractRoundedHighNarrowingLower(Vector128<ushort> left, Vector128<ushort> right)`__

This method subtracts each vector element of the `right` vector from the corresponding vector element of the `left` vector, stores the most significant half of the result into a vector, and writes the vector to the result vector. The results are rounded.

```csharp
private Vector64<byte> SubtractRoundedHighNarrowingLowerTest(Vector128<ushort> left, Vector128<ushort> right)
{
  return AdvSimd.SubtractRoundedHighNarrowingLower(left, right);
}
// left = <1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000>
// right = <10, 20, 30 , 40, 50, 60, 70, 80>
// Result = <4, 8, 12, 15, 19, 23, 27, 31>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> SubtractRoundedHighNarrowingLower(Vector128<int> left, Vector128<int> right)
Vector64<int> SubtractRoundedHighNarrowingLower(Vector128<long> left, Vector128<long> right)
Vector64<sbyte> SubtractRoundedHighNarrowingLower(Vector128<short> left, Vector128<short> right)
Vector64<ushort> SubtractRoundedHighNarrowingLower(Vector128<uint> left, Vector128<uint> right)
Vector64<uint> SubtractRoundedHighNarrowingLower(Vector128<ulong> left, Vector128<ulong> right)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.subtractroundedhighnarrowinglower?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vrsubhn_u16).

Assembly generated:

```armasm
; Assembly listing for method AdvSimdMethods:SubtractRoundedHighNarrowingLowerTest(System.Runtime.Intrinsics.Vector128`1[UInt16],System.Runtime.Intrinsics.Vector128`1[UInt16]):System.Runtime.Intrinsics.Vector64`1[Byte]
;
;  V00 arg0         [V00,T00] (  3,  3   )  simd16  ->   d0         HFA(simd16) 
;  V01 arg1         [V01,T01] (  3,  3   )  simd16  ->   d1         HFA(simd16) 
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
; Lcl frame size = 0
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
            rsubhn  v16.8b, v0.8h, v1.8h
            mov     v0.8b, v16.8b
            ldp     fp, lr, [sp],#16
            ret     lr

; Total bytes of code 24, prolog size 8
```
------------------------------------------------

### 29. SubtractRoundedHighNarrowingUpper

__`Vector128<byte> SubtractRoundedHighNarrowingUpper(Vector64<byte> lower, Vector128<ushort> left, Vector128<ushort> right)`__

This method subtracts each vector element in the `right` vector from the corresponding vector element in the `left` vector, stores the most significant half of the result into a vector, and writes the vector to the upper half of the result vector. The results are rounded. 

```csharp
private Vector128<byte> SubtractRoundedHighNarrowingUpperTest(Vector64<byte> lower, Vector128<ushort> left, Vector128<ushort> right)
{
  return AdvSimd.SubtractRoundedHighNarrowingUpper(lower, left, right);
}
// lower = <5, 5, 5, 5, 5, 5, 5, 5>
// left = <1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000>
// right = <10, 20, 30 , 40, 50, 60, 70, 80>
// Result = <5, 5, 5, 5, 5, 5, 5, 5, 4, 8, 12, 15, 19, 23, 27, 31>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<short> SubtractRoundedHighNarrowingUpper(Vector64<short> lower, Vector128<int> left, Vector128<int> right)
Vector128<int> SubtractRoundedHighNarrowingUpper(Vector64<int> lower, Vector128<long> left, Vector128<long> right)
Vector128<sbyte> SubtractRoundedHighNarrowingUpper(Vector64<sbyte> lower, Vector128<short> left, Vector128<short> right)
Vector128<ushort> SubtractRoundedHighNarrowingUpper(Vector64<ushort> lower, Vector128<uint> left, Vector128<uint> right)
Vector128<uint> SubtractRoundedHighNarrowingUpper(Vector64<uint> lower, Vector128<ulong> left, Vector128<ulong> right)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.subtractroundedhighnarrowingupper?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vrsubhn_high_u16).

Assembly generated:

```armasm
; Assembly listing for method AdvSimdMethods:SubtractRoundedHighNarrowingUpperTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[UInt16],System.Runtime.Intrinsics.Vector128`1[UInt16]):System.Runtime.Intrinsics.Vector128`1[Byte]
;
;  V00 arg0         [V00,T00] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T01] (  3,  3   )  simd16  ->   d1         HFA(simd16) 
;  V02 arg2         [V02,T02] (  3,  3   )  simd16  ->   d2         HFA(simd16) 
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
; Lcl frame size = 0
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
            rsubhn2 v0.16b, v1.8h, v2.8h
            ldp     fp, lr, [sp],#16
            ret     lr

; Total bytes of code 20, prolog size 8
```
------------------------------------------------

### 30. SubtractSaturate

__`Vector64<byte> SubtractSaturate(Vector64<byte> left, Vector64<byte> right)`__

This method subtracts the element values of the `right` vector from the corresponding element values of the `left` vector, stores the results in a vector and returns the result vector. As per ARM docs, if overflow occurs with any of the results, those results are saturated.

```csharp
private Vector64<byte> SubtractSaturateTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.SubtractSaturate(left, right);
}
// left = <250, 240, 230, 220, 210, 200, 190, 180>
// right = <10, 20, 30, 40, 50, 255, 250, 250>
// Result = <240, 220, 200, 180, 160, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> SubtractSaturate(Vector64<short> left, Vector64<short> right)
Vector64<int> SubtractSaturate(Vector64<int> left, Vector64<int> right)
Vector64<sbyte> SubtractSaturate(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<ushort> SubtractSaturate(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> SubtractSaturate(Vector64<uint> left, Vector64<uint> right)
Vector128<byte> SubtractSaturate(Vector128<byte> left, Vector128<byte> right)
Vector128<short> SubtractSaturate(Vector128<short> left, Vector128<short> right)
Vector128<int> SubtractSaturate(Vector128<int> left, Vector128<int> right)
Vector128<long> SubtractSaturate(Vector128<long> left, Vector128<long> right)
Vector128<sbyte> SubtractSaturate(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<ushort> SubtractSaturate(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> SubtractSaturate(Vector128<uint> left, Vector128<uint> right)
Vector128<ulong> SubtractSaturate(Vector128<ulong> left, Vector128<ulong> right)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.subtractsaturate?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vqsub_u8).

Assembly generated:

```armasm
; Assembly listing for method AdvSimdMethods:SubtractSaturateTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
;
;  V00 arg0         [V00,T00] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T01] (  3,  3   )   simd8  ->   d1         HFA(simd8) 
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
; Lcl frame size = 0
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
            uqsub   v16.8b, v0.8b, v1.8b
            mov     v0.8b, v16.8b
            ldp     fp, lr, [sp],#16
            ret     lr

; Total bytes of code 24, prolog size 8
```
------------------------------------------------

### 31. SubtractSaturateScalar

__`Vector64<long> SubtractSaturateScalar(Vector64<long> left, Vector64<long> right)`__

This method subtracts the element values of the `right` vector from the corresponding element values of the `left` vector, stores the results in a vector and returns the result vector. As per ARM docs, if overflow occurs with any of the results, those results are saturated.

```csharp
private Vector64<long> SubtractSaturateScalarTest(Vector64<long> left, Vector64<long> right)
{
  return AdvSimd.SubtractSaturateScalar(left, right);
}
// left = <500>
// right = <-200>
// Result = <700>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<ulong> SubtractSaturateScalar(Vector64<ulong> left, Vector64<ulong> right)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<byte> SubtractSaturateScalar(Vector64<byte> left, Vector64<byte> right)
Vector64<short> SubtractSaturateScalar(Vector64<short> left, Vector64<short> right)
Vector64<int> SubtractSaturateScalar(Vector64<int> left, Vector64<int> right)
Vector64<sbyte> SubtractSaturateScalar(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<ushort> SubtractSaturateScalar(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> SubtractSaturateScalar(Vector64<uint> left, Vector64<uint> right)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.subtractsaturatescalar?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.subtractsaturatescalar?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vqsub_s64).

Assembly generated:

```armasm
; Assembly listing for method AdvSimdMethods:SubtractSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64]):System.Runtime.Intrinsics.Vector64`1[Int64]
;
;  V00 arg0         [V00,T00] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T01] (  3,  3   )   simd8  ->   d1         HFA(simd8) 
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
; Lcl frame size = 0
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
            sqsub   d16, d0, d1
            mov     v0.8b, v16.8b
            ldp     fp, lr, [sp],#16
            ret     lr

; Total bytes of code 24, prolog size 8
```
------------------------------------------------

### 32. SubtractScalar

__`Vector64<double> SubtractScalar(Vector64<double> left, Vector64<double> right)`__

This method subtracts the floating-point value of the `right` vector from the floating-point value of the `left` vector and returns the result.

```csharp
private Vector64<double> SubtractScalarTest(Vector64<double> left, Vector64<double> right)
{
  return AdvSimd.SubtractScalar(left, right);
}
// left = <11.5>
// right = <11.5>
// Result = <0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<long> SubtractScalar(Vector64<long> left, Vector64<long> right)
Vector64<float> SubtractScalar(Vector64<float> left, Vector64<float> right)
Vector64<ulong> SubtractScalar(Vector64<ulong> left, Vector64<ulong> right)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.subtractscalar?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vsub_f64).

Assembly generated:

```armasm
; Assembly listing for method AdvSimdMethods:SubtractScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
;
;  V00 arg0         [V00,T00] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T01] (  3,  3   )   simd8  ->   d1         HFA(simd8) 
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
; Lcl frame size = 0
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
            fsub    d16, d0, d1
            mov     v0.8b, v16.8b
            ldp     fp, lr, [sp],#16
            ret     lr

; Total bytes of code 24, prolog size 8
```
------------------------------------------------

### 33. SubtractWideningLower

__`Vector128<ushort> SubtractWideningLower(Vector64<byte> left, Vector64<byte> right)`__

This method subtracts each vector element in the `right` from the corresponding vector element of the `left` vector, stores the results in a vector and returns the result vector.  As seen in below example, the result vector element's size `ushort` is twice as long as the input vector element's size `byte`.

```csharp
private Vector128<ushort> SubtractWideningLowerTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.SubtractWideningLower(left, right);
}
// left = <250, 240, 230, 220, 210, 200, 190, 180>
// right = <10, 20, 30, 40, 50, 255, 250, 250>
// Result = <240, 220, 200, 180, 160, 65481, 65476, 65466>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<int> SubtractWideningLower(Vector64<short> left, Vector64<short> right)
Vector128<long> SubtractWideningLower(Vector64<int> left, Vector64<int> right)
Vector128<short> SubtractWideningLower(Vector64<sbyte> left, Vector64<sbyte> right)
Vector128<uint> SubtractWideningLower(Vector64<ushort> left, Vector64<ushort> right)
Vector128<ulong> SubtractWideningLower(Vector64<uint> left, Vector64<uint> right)
Vector128<short> SubtractWideningLower(Vector128<short> left, Vector64<sbyte> right)
Vector128<int> SubtractWideningLower(Vector128<int> left, Vector64<short> right)
Vector128<long> SubtractWideningLower(Vector128<long> left, Vector64<int> right)
Vector128<ushort> SubtractWideningLower(Vector128<ushort> left, Vector64<byte> right)
Vector128<uint> SubtractWideningLower(Vector128<uint> left, Vector64<ushort> right)
Vector128<ulong> SubtractWideningLower(Vector128<ulong> left, Vector64<uint> right)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.subtractwideninglower?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vsubl_u8).

Assembly generated:

```armasm
; Assembly listing for method AdvSimdMethods:SubtractWideningLowerTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector128`1[UInt16]
;
;  V00 arg0         [V00,T00] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T01] (  3,  3   )   simd8  ->   d1         HFA(simd8) 
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
; Lcl frame size = 0
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
            usubl   v16.8h, v0.8b, v1.8b
            mov     v0.16b, v16.16b
            ldp     fp, lr, [sp],#16
            ret     lr

; Total bytes of code 24, prolog size 8
```
------------------------------------------------

### 34. SubtractWideningUpper

__`Vector128<ushort> SubtractWideningUpper(Vector128<byte> left, Vector128<byte> right)`__

This method subtracts each vector element in the upper-half of `right` from the corresponding vector element of the `left` vector, stores the results in a vector and returns the result vector. As seen in below example, the result vector element's size `ushort` is twice as long as the input vector element's size `byte`.

```csharp
private Vector128<ushort> SubtractWideningUpperTest(Vector128<byte> left, Vector128<byte> right)
{
  return AdvSimd.SubtractWideningUpper(left, right);
}
// left = <250, 240, 230, 220, 210, 200, 190, 180, 100, 100, 100, 100, 100, 100, 100, 100>
// right = <10, 20, 30, 40, 50, 255, 250, 250, 50, 50, 50, 50, 200, 200, 200, 200>
// Result = <50, 50, 50, 50, 65436, 65436, 65436, 65436>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<int> SubtractWideningUpper(Vector128<short> left, Vector128<short> right)
Vector128<short> SubtractWideningUpper(Vector128<short> left, Vector128<sbyte> right)
Vector128<int> SubtractWideningUpper(Vector128<int> left, Vector128<short> right)
Vector128<long> SubtractWideningUpper(Vector128<int> left, Vector128<int> right)
Vector128<long> SubtractWideningUpper(Vector128<long> left, Vector128<int> right)
Vector128<short> SubtractWideningUpper(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<ushort> SubtractWideningUpper(Vector128<ushort> left, Vector128<byte> right)
Vector128<uint> SubtractWideningUpper(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> SubtractWideningUpper(Vector128<uint> left, Vector128<ushort> right)
Vector128<ulong> SubtractWideningUpper(Vector128<uint> left, Vector128<uint> right)
Vector128<ulong> SubtractWideningUpper(Vector128<ulong> left, Vector128<uint> right)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.subtractwideningupper?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vsubl_high_u8).

Assembly generated:

```armasm
; Assembly listing for method AdvSimdMethods:SubtractWideningUpperTest(System.Runtime.Intrinsics.Vector128`1[Byte],System.Runtime.Intrinsics.Vector128`1[Byte]):System.Runtime.Intrinsics.Vector128`1[UInt16]
;
;  V00 arg0         [V00,T00] (  3,  3   )  simd16  ->   d0         HFA(simd16) 
;  V01 arg1         [V01,T01] (  3,  3   )  simd16  ->   d1         HFA(simd16) 
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
; Lcl frame size = 0
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
            usubl2  v16.8h, v0.16b, v1.16b
            mov     v0.16b, v16.16b
            ldp     fp, lr, [sp],#16
            ret     lr

; Total bytes of code 24, prolog size 8
```
------------------------------------------------

### 35. TransposeEven

__`Vector64<byte> TransposeEven(Vector64<byte> left, Vector64<byte> right)`__

This method reads corresponding even-numbered vector elements from `left` and `right`, starting at zero, places each result into consecutive elements of a vector, and writes the vector to the result vector. Vector elements from the `left` vector are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the `right` vector are placed into odd-numbered elements of the destination vector. By using this method with `TransposeOdd()`, a 2 x 2 matrix can be transposed.

```csharp
private Vector64<byte> TransposeEvenTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.Arm64.TransposeEven(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <11, 21, 13, 23, 15, 25, 17, 27>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<short> TransposeEven(Vector64<short> left, Vector64<short> right)
Vector64<int> TransposeEven(Vector64<int> left, Vector64<int> right)
Vector64<sbyte> TransposeEven(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<float> TransposeEven(Vector64<float> left, Vector64<float> right)
Vector64<ushort> TransposeEven(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> TransposeEven(Vector64<uint> left, Vector64<uint> right)
Vector128<byte> TransposeEven(Vector128<byte> left, Vector128<byte> right)
Vector128<double> TransposeEven(Vector128<double> left, Vector128<double> right)
Vector128<short> TransposeEven(Vector128<short> left, Vector128<short> right)
Vector128<int> TransposeEven(Vector128<int> left, Vector128<int> right)
Vector128<long> TransposeEven(Vector128<long> left, Vector128<long> right)
Vector128<sbyte> TransposeEven(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<float> TransposeEven(Vector128<float> left, Vector128<float> right)
Vector128<ushort> TransposeEven(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> TransposeEven(Vector128<uint> left, Vector128<uint> right)
Vector128<ulong> TransposeEven(Vector128<ulong> left, Vector128<ulong> right)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.transposeeven?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vtrn1_u8).

Assembly generated:

```armasm
; Assembly listing for method AdvSimdMethods:TransposeEvenTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
;
;  V00 arg0         [V00,T00] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T01] (  3,  3   )   simd8  ->   d1         HFA(simd8) 
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
; Lcl frame size = 0
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
            trn1    v16.8b, v0.8b, v1.8b
            mov     v0.8b, v16.8b
            ldp     fp, lr, [sp],#16
            ret     lr

; Total bytes of code 24, prolog size 8
```
------------------------------------------------

### 36. TransposeOdd

__`Vector64<byte> TransposeOdd(Vector64<byte> left, Vector64<byte> right)`__

This method reads corresponding odd-numbered vector elements from the `left` and `right` vectors, places each result into consecutive elements of a vector, and writes the vector to the result vector. Vector elements from the `left` vector are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the `right` vector are placed into odd-numbered elements of the destination vector. By using this method with `TransposeEven()`, a 2 x 2 matrix can be transposed.

```csharp
private Vector64<byte> TransposeOddTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.Arm64.TransposeOdd(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <12, 22, 14, 24, 16, 26, 18, 28>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<short> TransposeOdd(Vector64<short> left, Vector64<short> right)
Vector64<int> TransposeOdd(Vector64<int> left, Vector64<int> right)
Vector64<sbyte> TransposeOdd(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<float> TransposeOdd(Vector64<float> left, Vector64<float> right)
Vector64<ushort> TransposeOdd(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> TransposeOdd(Vector64<uint> left, Vector64<uint> right)
Vector128<byte> TransposeOdd(Vector128<byte> left, Vector128<byte> right)
Vector128<double> TransposeOdd(Vector128<double> left, Vector128<double> right)
Vector128<short> TransposeOdd(Vector128<short> left, Vector128<short> right)
Vector128<int> TransposeOdd(Vector128<int> left, Vector128<int> right)
Vector128<long> TransposeOdd(Vector128<long> left, Vector128<long> right)
Vector128<sbyte> TransposeOdd(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<float> TransposeOdd(Vector128<float> left, Vector128<float> right)
Vector128<ushort> TransposeOdd(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> TransposeOdd(Vector128<uint> left, Vector128<uint> right)
Vector128<ulong> TransposeOdd(Vector128<ulong> left, Vector128<ulong> right)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.transposeodd?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vtrn2_u8).

Assembly generated:

```armasm
; Assembly listing for method AdvSimdMethods:TransposeOddTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
;
;  V00 arg0         [V00,T00] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T01] (  3,  3   )   simd8  ->   d1         HFA(simd8) 
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
; Lcl frame size = 0
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
            trn2    v16.8b, v0.8b, v1.8b
            mov     v0.8b, v16.8b
            ldp     fp, lr, [sp],#16
            ret     lr

; Total bytes of code 24, prolog size 8
```
------------------------------------------------

### 37. UnzipEven

__`Vector64<byte> UnzipEven(Vector64<byte> left, Vector64<byte> right)`__

This method reads corresponding even-numbered vector elements from the `left` and `right` vectors, starting at zero, places the result from the `left` vector into consecutive elements in the lower half of a vector, and the result from the `right` vector into consecutive elements in the upper half of a vector, and writes the vector to the result vector. This method can be used with `UnzipOdd()` to de-interleave two vectors.

```csharp
private Vector64<byte> UnzipEvenTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.Arm64.UnzipEven(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <11, 13, 15, 17, 21, 23, 25, 27>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<short> UnzipEven(Vector64<short> left, Vector64<short> right)
Vector64<int> UnzipEven(Vector64<int> left, Vector64<int> right)
Vector64<sbyte> UnzipEven(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<float> UnzipEven(Vector64<float> left, Vector64<float> right)
Vector64<ushort> UnzipEven(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> UnzipEven(Vector64<uint> left, Vector64<uint> right)
Vector128<byte> UnzipEven(Vector128<byte> left, Vector128<byte> right)
Vector128<double> UnzipEven(Vector128<double> left, Vector128<double> right)
Vector128<short> UnzipEven(Vector128<short> left, Vector128<short> right)
Vector128<int> UnzipEven(Vector128<int> left, Vector128<int> right)
Vector128<long> UnzipEven(Vector128<long> left, Vector128<long> right)
Vector128<sbyte> UnzipEven(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<float> UnzipEven(Vector128<float> left, Vector128<float> right)
Vector128<ushort> UnzipEven(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> UnzipEven(Vector128<uint> left, Vector128<uint> right)
Vector128<ulong> UnzipEven(Vector128<ulong> left, Vector128<ulong> right)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.unzipeven?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vuzp1_u8).

Assembly generated:

```armasm
; Assembly listing for method AdvSimdMethods:UnzipEvenTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
;
;  V00 arg0         [V00,T00] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T01] (  3,  3   )   simd8  ->   d1         HFA(simd8) 
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
; Lcl frame size = 0
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
            uzp1    v16.8b, v0.8b, v1.8b
            mov     v0.8b, v16.8b
            ldp     fp, lr, [sp],#16
            ret     lr

; Total bytes of code 24, prolog size 8
```
------------------------------------------------

### 38. UnzipOdd

__`Vector64<byte> UnzipOdd(Vector64<byte> left, Vector64<byte> right)`__

This method reads corresponding odd-numbered vector elements from the `left` and `right` vectors, places the result from the `left` vector into consecutive elements in the lower half of a vector, and the result from the `right` vector into consecutive elements in the upper half of a vector, and writes the vector to the result vector.  This method can be used with `UnzipEven()` to de-interleave two vectors.

```csharp
private Vector64<byte> UnzipOddTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.Arm64.UnzipOdd(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <12, 14, 16, 18, 22, 24, 26, 28>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<short> UnzipOdd(Vector64<short> left, Vector64<short> right)
Vector64<int> UnzipOdd(Vector64<int> left, Vector64<int> right)
Vector64<sbyte> UnzipOdd(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<float> UnzipOdd(Vector64<float> left, Vector64<float> right)
Vector64<ushort> UnzipOdd(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> UnzipOdd(Vector64<uint> left, Vector64<uint> right)
Vector128<byte> UnzipOdd(Vector128<byte> left, Vector128<byte> right)
Vector128<double> UnzipOdd(Vector128<double> left, Vector128<double> right)
Vector128<short> UnzipOdd(Vector128<short> left, Vector128<short> right)
Vector128<int> UnzipOdd(Vector128<int> left, Vector128<int> right)
Vector128<long> UnzipOdd(Vector128<long> left, Vector128<long> right)
Vector128<sbyte> UnzipOdd(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<float> UnzipOdd(Vector128<float> left, Vector128<float> right)
Vector128<ushort> UnzipOdd(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> UnzipOdd(Vector128<uint> left, Vector128<uint> right)
Vector128<ulong> UnzipOdd(Vector128<ulong> left, Vector128<ulong> right)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.unzipodd?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vuzp2_u8).

Assembly generated:

```armasm
; Assembly listing for method AdvSimdMethods:UnzipOddTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
;
;  V00 arg0         [V00,T00] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T01] (  3,  3   )   simd8  ->   d1         HFA(simd8) 
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
; Lcl frame size = 0
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
            uzp2    v16.8b, v0.8b, v1.8b
            mov     v0.8b, v16.8b
            ldp     fp, lr, [sp],#16
            ret     lr

; Total bytes of code 24, prolog size 8
```
------------------------------------------------

### 39. VectorTableLookup

__`Vector64<byte> VectorTableLookup(Vector128<byte> table, Vector64<byte> byteIndexes)`__

This method reads each value from the vector elements in the `byteIndexes` vector, uses each result as an index to perform a lookup in a table of bytes that is described by `table` vector, places the lookup result in a vector, and writes the vector to the result vector. If an index is out of range for the table, the result for that lookup is 0.

```csharp
private Vector64<byte> VectorTableLookupTest(Vector128<byte> table, Vector64<byte> byteIndexes)
{
  return AdvSimd.VectorTableLookup(table, byteIndexes);
}
// table = <11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26>
// byteIndexes = <11, 12, 13, 14, 15, 16, 17, 18>
// Result = <22, 23, 24, 25, 26, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<sbyte> VectorTableLookup(Vector128<sbyte> table, Vector64<sbyte> byteIndexes)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<byte> VectorTableLookup(Vector128<byte> table, Vector128<byte> byteIndexes)
Vector128<sbyte> VectorTableLookup(Vector128<sbyte> table, Vector128<sbyte> byteIndexes)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.vectortablelookup?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.vectortablelookup?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vqvtbl1_u8).

Assembly generated:

```armasm
; Assembly listing for method AdvSimdMethods:VectorTableLookupTest(System.Runtime.Intrinsics.Vector128`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
;
;  V00 arg0         [V00,T00] (  3,  3   )  simd16  ->   d0         HFA(simd16) 
;  V01 arg1         [V01,T01] (  3,  3   )   simd8  ->   d1         HFA(simd8) 
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
; Lcl frame size = 0
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
            tbl     v16.8b, {v0.16b}, v1.8b
            mov     v0.8b, v16.8b
            ldp     fp, lr, [sp],#16
            ret     lr

; Total bytes of code 24, prolog size 8
```
------------------------------------------------

### 40. VectorTableLookupExtension

__`Vector64<byte> VectorTableLookupExtension(Vector64<byte> defaultValues, Vector128<byte> table, Vector64<byte> byteIndexes)`__

This method reads each value from the vector elements in the `byteIndexes` vector, uses each result as an index to perform a lookup in a table of bytes that is described by `table` vector, places the lookup result in a vector, and writes the vector to the result vector. If an index is out of range for the table, the value from `defaultValue` is picked.

```csharp
private Vector64<byte> VectorTableLookupExtensionTest(Vector64<byte> defaultValues, Vector128<byte> table, Vector64<byte> byteIndexes)
{
  return AdvSimd.VectorTableLookupExtension(defaultValues, table, byteIndexes);
}
// defaultValues = <5, 5, 5, 5, 5, 5, 5, 5>
// table = <11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26>
// byteIndexes = <1, 15, 4, 3, 8, 19, 1, 0>
// Result = <12, 26, 15, 14, 19, 5, 12, 11>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<sbyte> VectorTableLookupExtension(Vector64<sbyte> defaultValues, Vector128<sbyte> table, Vector64<sbyte> byteIndexes)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<byte> VectorTableLookupExtension(Vector128<byte> defaultValues, Vector128<byte> table, Vector128<byte> byteIndexes)
Vector128<sbyte> VectorTableLookupExtension(Vector128<sbyte> defaultValues, Vector128<sbyte> table, Vector128<sbyte> byteIndexes)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.vectortablelookupextension?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.vectortablelookupextension?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vqvtbx1_u8).

Assembly generated:

```armasm
; Assembly listing for method AdvSimdMethods:VectorTableLookupExtensionTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
;
;  V00 arg0         [V00,T00] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T01] (  3,  3   )  simd16  ->   d1         HFA(simd16) 
;  V02 arg2         [V02,T02] (  3,  3   )   simd8  ->   d2         HFA(simd8) 
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
; Lcl frame size = 0
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
            tbx     v0.8b, {v1.16b}, v2.8b
            ldp     fp, lr, [sp],#16
            ret     lr

; Total bytes of code 20, prolog size 8
```
------------------------------------------------

### 41. Xor

__`Vector64<byte> Xor(Vector64<byte> left, Vector64<byte> right)`__

This method performs a bitwise Exclusive OR operation between the `left` and `right` vector, and stores the results in a vector and returns the result vector.

```csharp
private Vector64<byte> XorTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.Xor(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <30, 26, 26, 22, 22, 10, 10, 14>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<double> Xor(Vector64<double> left, Vector64<double> right)
Vector64<short> Xor(Vector64<short> left, Vector64<short> right)
Vector64<int> Xor(Vector64<int> left, Vector64<int> right)
Vector64<long> Xor(Vector64<long> left, Vector64<long> right)
Vector64<sbyte> Xor(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<float> Xor(Vector64<float> left, Vector64<float> right)
Vector64<ushort> Xor(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> Xor(Vector64<uint> left, Vector64<uint> right)
Vector64<ulong> Xor(Vector64<ulong> left, Vector64<ulong> right)
Vector128<byte> Xor(Vector128<byte> left, Vector128<byte> right)
Vector128<double> Xor(Vector128<double> left, Vector128<double> right)
Vector128<short> Xor(Vector128<short> left, Vector128<short> right)
Vector128<int> Xor(Vector128<int> left, Vector128<int> right)
Vector128<long> Xor(Vector128<long> left, Vector128<long> right)
Vector128<sbyte> Xor(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<float> Xor(Vector128<float> left, Vector128<float> right)
Vector128<ushort> Xor(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> Xor(Vector128<uint> left, Vector128<uint> right)
Vector128<ulong> Xor(Vector128<ulong> left, Vector128<ulong> right)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.xor?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=veor_u8).

Assembly generated:

```armasm
; Assembly listing for method AdvSimdMethods:XorTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
;
;  V00 arg0         [V00,T00] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T01] (  3,  3   )   simd8  ->   d1         HFA(simd8) 
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
; Lcl frame size = 0
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
            eor     v16.8b, v0.8b, v1.8b
            mov     v0.8b, v16.8b
            ldp     fp, lr, [sp],#16
            ret     lr

; Total bytes of code 24, prolog size 8
```
------------------------------------------------

### 42. ZeroExtendWideningLower

__`Vector128<ushort> ZeroExtendWideningLower(Vector64<byte> value)`__

This method copies each vector element from the`value` vector into a vector, and writes the vector to the result vector. As seen in below example, the result vector element's size `ushort` is twice as long as the input vector element's size `byte`.

```csharp
private Vector128<ushort> ZeroExtendWideningLowerTest(Vector64<byte> value)
{
  return AdvSimd.ZeroExtendWideningLower(value);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// Result = <11, 12, 13, 14, 15, 16, 17, 18>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<int> ZeroExtendWideningLower(Vector64<short> value)
Vector128<long> ZeroExtendWideningLower(Vector64<int> value)
Vector128<short> ZeroExtendWideningLower(Vector64<sbyte> value)
Vector128<uint> ZeroExtendWideningLower(Vector64<ushort> value)
Vector128<ulong> ZeroExtendWideningLower(Vector64<uint> value)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.zeroextendwideninglower?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vmovl_u8).

Assembly generated:

```armasm
; Assembly listing for method AdvSimdMethods:ZeroExtendWideningLowerTest(System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector128`1[UInt16]
;
;  V00 arg0         [V00,T00] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
; Lcl frame size = 0
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
            uxtl    v16.8h, v0.8b
            mov     v0.16b, v16.16b
            ldp     fp, lr, [sp],#16
            ret     lr

; Total bytes of code 24, prolog size 8
```
------------------------------------------------

### 43. ZeroExtendWideningUpper

__`Vector128<ushort> ZeroExtendWideningUpper(Vector128<byte> value)`__

This method copies each vector element from the upper-half of `value` vector into a vector, and writes the vector to the result vector. As seen in below example, the result vector element's size `ushort` is twice as long as the input vector element's size `byte`.

```csharp
private Vector128<ushort> ZeroExtendWideningUpperTest(Vector128<byte> value)
{
  return AdvSimd.ZeroExtendWideningUpper(value);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26>
// Result = <19, 20, 21, 22, 23, 24, 25, 26>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<int> ZeroExtendWideningUpper(Vector128<short> value)
Vector128<long> ZeroExtendWideningUpper(Vector128<int> value)
Vector128<short> ZeroExtendWideningUpper(Vector128<sbyte> value)
Vector128<uint> ZeroExtendWideningUpper(Vector128<ushort> value)
Vector128<ulong> ZeroExtendWideningUpper(Vector128<uint> value)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.zeroextendwideningupper?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vmovl_high_u8).

Assembly generated:

```armasm
; Assembly listing for method AdvSimdMethods:ZeroExtendWideningUpperTest(System.Runtime.Intrinsics.Vector128`1[Byte]):System.Runtime.Intrinsics.Vector128`1[UInt16]
;
;  V00 arg0         [V00,T00] (  3,  3   )  simd16  ->   d0         HFA(simd16) 
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
; Lcl frame size = 0
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
            uxtl2   v16.8h, v0.16b
            mov     v0.16b, v16.16b
            ldp     fp, lr, [sp],#16
            ret     lr

; Total bytes of code 24, prolog size 8
```
------------------------------------------------

### 44. ZipHigh

__`Vector64<byte> ZipHigh(Vector64<byte> left, Vector64<byte> right)`__

This method reads adjacent vector elements from the lower half of `left` and `right` vector as pairs, interleaves the pairs and stores the results in a vector and returns the result vector. The first pair from the `left` vector is placed into the two lowest vector elements, with subsequent pairs taken alternately from each argument vector. This method can be used with `ZipLow()` to interleave two vectors.

```csharp
private Vector64<byte> ZipHighTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.Arm64.ZipHigh(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <15, 25, 16, 26, 17, 27, 18, 28>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<short> ZipHigh(Vector64<short> left, Vector64<short> right)
Vector64<int> ZipHigh(Vector64<int> left, Vector64<int> right)
Vector64<sbyte> ZipHigh(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<float> ZipHigh(Vector64<float> left, Vector64<float> right)
Vector64<ushort> ZipHigh(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> ZipHigh(Vector64<uint> left, Vector64<uint> right)
Vector128<byte> ZipHigh(Vector128<byte> left, Vector128<byte> right)
Vector128<double> ZipHigh(Vector128<double> left, Vector128<double> right)
Vector128<short> ZipHigh(Vector128<short> left, Vector128<short> right)
Vector128<int> ZipHigh(Vector128<int> left, Vector128<int> right)
Vector128<long> ZipHigh(Vector128<long> left, Vector128<long> right)
Vector128<sbyte> ZipHigh(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<float> ZipHigh(Vector128<float> left, Vector128<float> right)
Vector128<ushort> ZipHigh(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> ZipHigh(Vector128<uint> left, Vector128<uint> right)
Vector128<ulong> ZipHigh(Vector128<ulong> left, Vector128<ulong> right)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.ziphigh?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vzip2_u8).

Assembly generated:

```armasm
; Assembly listing for method AdvSimdMethods:ZipHighTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
;
;  V00 arg0         [V00,T00] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T01] (  3,  3   )   simd8  ->   d1         HFA(simd8) 
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
; Lcl frame size = 0
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
            zip2    v16.8b, v0.8b, v1.8b
            mov     v0.8b, v16.8b
            ldp     fp, lr, [sp],#16
            ret     lr

; Total bytes of code 24, prolog size 8
```
------------------------------------------------

### 45. ZipLow

__`Vector64<byte> ZipLow(Vector64<byte> left, Vector64<byte> right)`__

This method reads adjacent vector elements from the upper half of `left` and `right` vector as pairs, interleaves the pairs and stores the results in a vector and returns the result vector. The first pair from the `left` vector is placed into the two lowest vector elements, with subsequent pairs taken alternately from each argument vectors. This method can be used with `ZipHigh()` to interleave two vectors.

```csharp
private Vector64<byte> ZipLowTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.Arm64.ZipLow(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <11, 21, 12, 22, 13, 23, 14, 24>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<short> ZipLow(Vector64<short> left, Vector64<short> right)
Vector64<int> ZipLow(Vector64<int> left, Vector64<int> right)
Vector64<sbyte> ZipLow(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<float> ZipLow(Vector64<float> left, Vector64<float> right)
Vector64<ushort> ZipLow(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> ZipLow(Vector64<uint> left, Vector64<uint> right)
Vector128<byte> ZipLow(Vector128<byte> left, Vector128<byte> right)
Vector128<double> ZipLow(Vector128<double> left, Vector128<double> right)
Vector128<short> ZipLow(Vector128<short> left, Vector128<short> right)
Vector128<int> ZipLow(Vector128<int> left, Vector128<int> right)
Vector128<long> ZipLow(Vector128<long> left, Vector128<long> right)
Vector128<sbyte> ZipLow(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<float> ZipLow(Vector128<float> left, Vector128<float> right)
Vector128<ushort> ZipLow(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> ZipLow(Vector128<uint> left, Vector128<uint> right)
Vector128<ulong> ZipLow(Vector128<ulong> left, Vector128<ulong> right)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.ziplow?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vzip1_u8).

Assembly generated:

```armasm
; Assembly listing for method AdvSimdMethods:ZipLowTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
;
;  V00 arg0         [V00,T00] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T01] (  3,  3   )   simd8  ->   d1         HFA(simd8) 
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
; Lcl frame size = 0
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
            zip1    v16.8b, v0.8b, v1.8b
            mov     v0.8b, v16.8b
            ldp     fp, lr, [sp],#16
            ret     lr

; Total bytes of code 24, prolog size 8
