---
layout: post
title: Hardware Intrinsics APIs for ARM64 - Part 6
subtitle: With examples
tags: [work, arm64, intrinsics]
---

### Introduction

In my [last post](../2019-01-01-Vectorization-APIs), I describe SIMD datatypes `Vector64<T>` and `Vector128<T>` that operates on 'hardware intrisic' APIs. In this post I will describe the intrinsic APIs for ARM64 and how you can use them to optimize your code if you are writing a .NET API targetting ARM64. This is 3 post series TODO.


### API list

[ExtractNarrowingSaturateScalar](#1-extractnarrowingsaturatescalar), [ExtractNarrowingSaturateUnsignedScalar](#2-extractnarrowingsaturateunsignedscalar), [FusedMultiplyAddByScalar](#3-fusedmultiplyaddbyscalar), [FusedMultiplyAddBySelectedScalar](#4-fusedmultiplyaddbyselectedscalar), [FusedMultiplyAddScalarBySelectedScalar](#5-fusedmultiplyaddscalarbyselectedscalar), [FusedMultiplySubtractByScalar](#6-fusedmultiplysubtractbyscalar), [FusedMultiplySubtractBySelectedScalar](#7-fusedmultiplysubtractbyselectedscalar), [FusedMultiplySubtractScalarBySelectedScalar](#8-fusedmultiplysubtractscalarbyselectedscalar), [InsertSelectedScalar](#9-insertselectedscalar), [MaxAcross](#10-maxacross), [MaxNumberAcross](#11-maxnumberacross), [MaxNumberPairwise](#12-maxnumberpairwise), [MaxNumberPairwiseScalar](#13-maxnumberpairwisescalar), [MaxPairwiseScalar](#14-maxpairwisescalar), [MaxScalar](#15-maxscalar), [MinAcross](#16-minacross), [MinNumberAcross](#17-minnumberacross), [MinNumberPairwise](#18-minnumberpairwise), [MinNumberPairwiseScalar](#19-minnumberpairwisescalar), [MinPairwiseScalar](#20-minpairwisescalar), [MinScalar](#21-minscalar), [MultiplyDoublingSaturateHighScalar](#22-multiplydoublingsaturatehighscalar), [MultiplyDoublingScalarBySelectedScalarSaturateHigh](#23-multiplydoublingscalarbyselectedscalarsaturatehigh), [MultiplyDoublingWideningAndAddSaturateScalar](#24-multiplydoublingwideningandaddsaturatescalar), [MultiplyDoublingWideningAndSubtractSaturateScalar](#25-multiplydoublingwideningandsubtractsaturatescalar), [MultiplyDoublingWideningSaturateScalar](#26-multiplydoublingwideningsaturatescalar), [MultiplyDoublingWideningSaturateScalarBySelectedScalar](#27-multiplydoublingwideningsaturatescalarbyselectedscalar), [MultiplyDoublingWideningScalarBySelectedScalarAndAddSaturate](#28-multiplydoublingwideningscalarbyselectedscalarandaddsaturate), [MultiplyDoublingWideningScalarBySelectedScalarAndSubtractSaturate](#29-multiplydoublingwideningscalarbyselectedscalarandsubtractsaturate), [MultiplyExtended](#30-multiplyextended), [MultiplyExtendedByScalar](#31-multiplyextendedbyscalar), [MultiplyExtendedBySelectedScalar](#32-multiplyextendedbyselectedscalar), [MultiplyExtendedScalar](#33-multiplyextendedscalar), [MultiplyExtendedScalarBySelectedScalar](#34-multiplyextendedscalarbyselectedscalar), [MultiplyRoundedDoublingSaturateHighScalar](#35-multiplyroundeddoublingsaturatehighscalar), [MultiplyRoundedDoublingScalarBySelectedScalarSaturateHigh](#36-multiplyroundeddoublingscalarbyselectedscalarsaturatehigh), [NegateSaturateScalar](#37-negatesaturatescalar), [ReciprocalEstimateScalar](#38-reciprocalestimatescalar), [ReciprocalExponentScalar](#39-reciprocalexponentscalar), [ReciprocalSquareRootEstimateScalar](#40-reciprocalsquarerootestimatescalar), [ReciprocalSquareRootStepScalar](#41-reciprocalsquarerootstepscalar), [ReciprocalStepScalar](#42-reciprocalstepscalar), [ShiftRightArithmeticNarrowingSaturateScalar](#43-shiftrightarithmeticnarrowingsaturatescalar), [ShiftRightArithmeticNarrowingSaturateUnsignedScalar](#44-shiftrightarithmeticnarrowingsaturateunsignedscalar), [ShiftRightArithmeticRoundedNarrowingSaturateScalar](#45-shiftrightarithmeticroundednarrowingsaturatescalar), [ShiftRightArithmeticRoundedNarrowingSaturateUnsignedScalar](#46-shiftrightarithmeticroundednarrowingsaturateunsignedscalar), [ShiftRightLogicalNarrowingSaturateScalar](#47-shiftrightlogicalnarrowingsaturatescalar), [ShiftRightLogicalRoundedNarrowingSaturateScalar](#48-shiftrightlogicalroundednarrowingsaturatescalar), [Sqrt](#49-sqrt), [StorePair](#50-storepair), [StorePairNonTemporal](#51-storepairnontemporal), [StorePairScalar](#52-storepairscalar), [StorePairScalarNonTemporal](#53-storepairscalarnontemporal), [ReverseElementBits](#54-reverseelementbits), [TransposeEven](#55-transposeeven), [TransposeOdd](#56-transposeodd), [UnzipEven](#57-unzipeven), [UnzipOdd](#58-unzipodd), [ZipHigh](#59-ziphigh), [ZipLow](#60-ziplow),[...](Part6.md)






### 1. ExtractNarrowingSaturateScalar

`Vector64<byte> ExtractNarrowingSaturateScalar(Vector64<ushort> value)`

Performs 'ExtractNarrowingSaturateScalar' operation.

```csharp
private Vector64<byte> ExtractNarrowingSaturateScalarTest(Vector64<ushort> value)
{
  return AdvSimd.Arm64.ExtractNarrowingSaturateScalar(value);
}
// value = <11, 12, 13, 14>
// Result = <11, 0, 0, 0, 0, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<short> ExtractNarrowingSaturateScalar(Vector64<int> value)
Vector64<int> ExtractNarrowingSaturateScalar(Vector64<long> value)
Vector64<sbyte> ExtractNarrowingSaturateScalar(Vector64<short> value)
Vector64<ushort> ExtractNarrowingSaturateScalar(Vector64<uint> value)
Vector64<uint> ExtractNarrowingSaturateScalar(Vector64<ulong> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.extractnarrowingsaturatescalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ExtractNarrowingSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[UInt16]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M33135_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M33135_IG02:
            ldr     d16, [fp,#24]
            uqxtn   b16, h16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M33135_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=ae277e90) for method AdvSimdMethods:ExtractNarrowingSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[UInt16]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 2. ExtractNarrowingSaturateUnsignedScalar

`Vector64<byte> ExtractNarrowingSaturateUnsignedScalar(Vector64<short> value)`

Performs 'ExtractNarrowingSaturateUnsignedScalar' operation.

```csharp
private Vector64<byte> ExtractNarrowingSaturateUnsignedScalarTest(Vector64<short> value)
{
  return AdvSimd.Arm64.ExtractNarrowingSaturateUnsignedScalar(value);
}
// value = <11, 12, 13, 14>
// Result = <11, 0, 0, 0, 0, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<ushort> ExtractNarrowingSaturateUnsignedScalar(Vector64<int> value)
Vector64<uint> ExtractNarrowingSaturateUnsignedScalar(Vector64<long> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.extractnarrowingsaturateunsignedscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ExtractNarrowingSaturateUnsignedScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M51411_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M51411_IG02:
            ldr     d16, [fp,#24]
            sqxtun  b16, h16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M51411_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=c717372c) for method AdvSimdMethods:ExtractNarrowingSaturateUnsignedScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 3. FusedMultiplyAddByScalar

`Vector64<float> FusedMultiplyAddByScalar(Vector64<float> addend, Vector64<float> left, Vector64<float> right)`

Performs 'FusedMultiplyAddByScalar' operation.

```csharp
private Vector64<float> FusedMultiplyAddByScalarTest(Vector64<float> addend, Vector64<float> left, Vector64<float> right)
{
  return AdvSimd.Arm64.FusedMultiplyAddByScalar(addend, left, right);
}
// addend = <11.5, 12.5>
// left = <21.5, 22.5>
// right = <11.5, 12.5>
// Result = <258.75, 271.25>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> FusedMultiplyAddByScalar(Vector128<double> addend, Vector128<double> left, Vector64<double> right)
Vector128<float> FusedMultiplyAddByScalar(Vector128<float> addend, Vector128<float> left, Vector64<float> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.fusedmultiplyaddbyscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:FusedMultiplyAddByScalarTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x20]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M9656_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     d1, [fp,#32]
            str     d2, [fp,#24]
						;; bbWeight=1    PerfScore 4.50
G_M9656_IG02:
            ldr     d16, [fp,#40]
            ldr     d17, [fp,#32]
            ldr     d18, [fp,#24]
            fmla    v16.2s, v17.2s, v18.s[0]
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 9.50
G_M9656_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 20.80, (MethodHash=732bda47) for method AdvSimdMethods:FusedMultiplyAddByScalarTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 4. FusedMultiplyAddBySelectedScalar

`Vector64<float> FusedMultiplyAddBySelectedScalar(Vector64<float> addend, Vector64<float> left, Vector64<float> right, byte rightIndex)`

Performs 'FusedMultiplyAddBySelectedScalar' operation.

```csharp
private Vector64<float> FusedMultiplyAddBySelectedScalarTest(Vector64<float> addend, Vector64<float> left, Vector64<float> right, byte rightIndex)
{
  return AdvSimd.Arm64.FusedMultiplyAddBySelectedScalar(addend, left, right, rightIndex);
}
// addend = <11.5, 12.5>
// left = <21.5, 22.5>
// right = <11.5, 12.5>
// rightIndex = 0
// Result = <258.75, 271.25>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<float> FusedMultiplyAddBySelectedScalar(Vector64<float> addend, Vector64<float> left, Vector128<float> right, byte rightIndex)
Vector128<double> FusedMultiplyAddBySelectedScalar(Vector128<double> addend, Vector128<double> left, Vector128<double> right, byte rightIndex)
Vector128<float> FusedMultiplyAddBySelectedScalar(Vector128<float> addend, Vector128<float> left, Vector64<float> right, byte rightIndex)
Vector128<float> FusedMultiplyAddBySelectedScalar(Vector128<float> addend, Vector128<float> left, Vector128<float> right, byte rightIndex)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.fusedmultiplyaddbyselectedscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:FusedMultiplyAddBySelectedScalarTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single],ubyte):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x20]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V03 arg3         [V03,T00] (  3,  3   )   ubyte  ->   x0        
;# V04 OutArgs      [V04    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V05 tmp1         [V05,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V06 tmp2         [V06,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;  V07 tmp3         [V07,T03] (  2,  4   )   simd8  ->   d2         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 32

G_M60418_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     d1, [fp,#32]
            str     d2, [fp,#24]
						;; bbWeight=1    PerfScore 4.50
G_M60418_IG02:
            ldr     d0, [fp,#40]
            ldr     d1, [fp,#32]
            ldr     d2, [fp,#24]
            uxtb    w0, w0
            bl      Arm64:FusedMultiplyAddBySelectedScalar(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single],ubyte):System.Runtime.Intrinsics.Vector64`1[Single]
						;; bbWeight=1    PerfScore 7.50
G_M60418_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 18.80, (MethodHash=872113fd) for method AdvSimdMethods:FusedMultiplyAddBySelectedScalarTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single],ubyte):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 5. FusedMultiplyAddScalarBySelectedScalar

`Vector64<double> FusedMultiplyAddScalarBySelectedScalar(Vector64<double> addend, Vector64<double> left, Vector128<double> right, byte rightIndex)`

Performs 'FusedMultiplyAddScalarBySelectedScalar' operation.

```csharp
private Vector64<double> FusedMultiplyAddScalarBySelectedScalarTest(Vector64<double> addend, Vector64<double> left, Vector128<double> right, byte rightIndex)
{
  return AdvSimd.Arm64.FusedMultiplyAddScalarBySelectedScalar(addend, left, right, rightIndex);
}
// addend = <11.5>
// left = <11.5>
// right = <11.5, 12.5>
// rightIndex = 0
// Result = <143.75>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<float> FusedMultiplyAddScalarBySelectedScalar(Vector64<float> addend, Vector64<float> left, Vector64<float> right, byte rightIndex)
Vector64<float> FusedMultiplyAddScalarBySelectedScalar(Vector64<float> addend, Vector64<float> left, Vector128<float> right, byte rightIndex)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.fusedmultiplyaddscalarbyselectedscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:FusedMultiplyAddScalarBySelectedScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector128`1[Double],ubyte):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x20]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V03 arg3         [V03,T00] (  3,  3   )   ubyte  ->   x0        
;# V04 OutArgs      [V04    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V05 tmp1         [V05,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V06 tmp2         [V06,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;  V07 tmp3         [V07,T03] (  2,  4   )  simd16  ->   d2         HFA(simd16)  "Inlining Arg"
;
; Lcl frame size = 32

G_M26869_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     d1, [fp,#32]
            str     q2, [fp,#16]
						;; bbWeight=1    PerfScore 4.50
G_M26869_IG02:
            ldr     d0, [fp,#40]
            ldr     d1, [fp,#32]
            ldr     q2, [fp,#16]
            uxtb    w0, w0
            bl      Arm64:FusedMultiplyAddScalarBySelectedScalar(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector128`1[Double],ubyte):System.Runtime.Intrinsics.Vector64`1[Double]
						;; bbWeight=1    PerfScore 7.50
G_M26869_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 18.80, (MethodHash=4058970a) for method AdvSimdMethods:FusedMultiplyAddScalarBySelectedScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector128`1[Double],ubyte):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 6. FusedMultiplySubtractByScalar

`Vector64<float> FusedMultiplySubtractByScalar(Vector64<float> minuend, Vector64<float> left, Vector64<float> right)`

Performs 'FusedMultiplySubtractByScalar' operation.

```csharp
private Vector64<float> FusedMultiplySubtractByScalarTest(Vector64<float> minuend, Vector64<float> left, Vector64<float> right)
{
  return AdvSimd.Arm64.FusedMultiplySubtractByScalar(minuend, left, right);
}
// minuend = <11.5, 12.5>
// left = <21.5, 22.5>
// right = <11.5, 12.5>
// Result = <-235.75, -246.25>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> FusedMultiplySubtractByScalar(Vector128<double> minuend, Vector128<double> left, Vector64<double> right)
Vector128<float> FusedMultiplySubtractByScalar(Vector128<float> minuend, Vector128<float> left, Vector64<float> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.fusedmultiplysubtractbyscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:FusedMultiplySubtractByScalarTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x20]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M6573_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     d1, [fp,#32]
            str     d2, [fp,#24]
						;; bbWeight=1    PerfScore 4.50
G_M6573_IG02:
            ldr     d16, [fp,#40]
            ldr     d17, [fp,#32]
            ldr     d18, [fp,#24]
            fmls    v16.2s, v17.2s, v18.s[0]
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 9.50
G_M6573_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 20.80, (MethodHash=4149e652) for method AdvSimdMethods:FusedMultiplySubtractByScalarTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 7. FusedMultiplySubtractBySelectedScalar

`Vector64<float> FusedMultiplySubtractBySelectedScalar(Vector64<float> minuend, Vector64<float> left, Vector64<float> right, byte rightIndex)`

Performs 'FusedMultiplySubtractBySelectedScalar' operation.

```csharp
private Vector64<float> FusedMultiplySubtractBySelectedScalarTest(Vector64<float> minuend, Vector64<float> left, Vector64<float> right, byte rightIndex)
{
  return AdvSimd.Arm64.FusedMultiplySubtractBySelectedScalar(minuend, left, right, rightIndex);
}
// minuend = <11.5, 12.5>
// left = <21.5, 22.5>
// right = <11.5, 12.5>
// rightIndex = 0
// Result = <-235.75, -246.25>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<float> FusedMultiplySubtractBySelectedScalar(Vector64<float> minuend, Vector64<float> left, Vector128<float> right, byte rightIndex)
Vector128<double> FusedMultiplySubtractBySelectedScalar(Vector128<double> minuend, Vector128<double> left, Vector128<double> right, byte rightIndex)
Vector128<float> FusedMultiplySubtractBySelectedScalar(Vector128<float> minuend, Vector128<float> left, Vector64<float> right, byte rightIndex)
Vector128<float> FusedMultiplySubtractBySelectedScalar(Vector128<float> minuend, Vector128<float> left, Vector128<float> right, byte rightIndex)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.fusedmultiplysubtractbyselectedscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:FusedMultiplySubtractBySelectedScalarTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single],ubyte):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x20]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V03 arg3         [V03,T00] (  3,  3   )   ubyte  ->   x0        
;# V04 OutArgs      [V04    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V05 tmp1         [V05,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V06 tmp2         [V06,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;  V07 tmp3         [V07,T03] (  2,  4   )   simd8  ->   d2         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 32

G_M54295_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     d1, [fp,#32]
            str     d2, [fp,#24]
						;; bbWeight=1    PerfScore 4.50
G_M54295_IG02:
            ldr     d0, [fp,#40]
            ldr     d1, [fp,#32]
            ldr     d2, [fp,#24]
            uxtb    w0, w0
            bl      Arm64:FusedMultiplySubtractBySelectedScalar(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single],ubyte):System.Runtime.Intrinsics.Vector64`1[Single]
						;; bbWeight=1    PerfScore 7.50
G_M54295_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 18.80, (MethodHash=d11c2be8) for method AdvSimdMethods:FusedMultiplySubtractBySelectedScalarTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single],ubyte):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 8. FusedMultiplySubtractScalarBySelectedScalar

`Vector64<double> FusedMultiplySubtractScalarBySelectedScalar(Vector64<double> minuend, Vector64<double> left, Vector128<double> right, byte rightIndex)`

Performs 'FusedMultiplySubtractScalarBySelectedScalar' operation.

```csharp
private Vector64<double> FusedMultiplySubtractScalarBySelectedScalarTest(Vector64<double> minuend, Vector64<double> left, Vector128<double> right, byte rightIndex)
{
  return AdvSimd.Arm64.FusedMultiplySubtractScalarBySelectedScalar(minuend, left, right, rightIndex);
}
// minuend = <11.5>
// left = <11.5>
// right = <11.5, 12.5>
// rightIndex = 0
// Result = <-120.75>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<float> FusedMultiplySubtractScalarBySelectedScalar(Vector64<float> minuend, Vector64<float> left, Vector64<float> right, byte rightIndex)
Vector64<float> FusedMultiplySubtractScalarBySelectedScalar(Vector64<float> minuend, Vector64<float> left, Vector128<float> right, byte rightIndex)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.fusedmultiplysubtractscalarbyselectedscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:FusedMultiplySubtractScalarBySelectedScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector128`1[Double],ubyte):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x20]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V03 arg3         [V03,T00] (  3,  3   )   ubyte  ->   x0        
;# V04 OutArgs      [V04    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V05 tmp1         [V05,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V06 tmp2         [V06,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;  V07 tmp3         [V07,T03] (  2,  4   )  simd16  ->   d2         HFA(simd16)  "Inlining Arg"
;
; Lcl frame size = 32

G_M13376_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     d1, [fp,#32]
            str     q2, [fp,#16]
						;; bbWeight=1    PerfScore 4.50
G_M13376_IG02:
            ldr     d0, [fp,#40]
            ldr     d1, [fp,#32]
            ldr     q2, [fp,#16]
            uxtb    w0, w0
            bl      Arm64:FusedMultiplySubtractScalarBySelectedScalar(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector128`1[Double],ubyte):System.Runtime.Intrinsics.Vector64`1[Double]
						;; bbWeight=1    PerfScore 7.50
G_M13376_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 18.80, (MethodHash=855ecbbf) for method AdvSimdMethods:FusedMultiplySubtractScalarBySelectedScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector128`1[Double],ubyte):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 9. InsertSelectedScalar

`Vector64<byte> InsertSelectedScalar(Vector64<byte> result, byte resultIndex, Vector64<byte> value, byte valueIndex)`

Performs 'InsertSelectedScalar' operation.

```csharp
private Vector64<byte> InsertSelectedScalarTest(Vector64<byte> result, byte resultIndex, Vector64<byte> value, byte valueIndex)
{
  return AdvSimd.Arm64.InsertSelectedScalar(result, resultIndex, value, valueIndex);
}
// result = <11, 12, 13, 14, 15, 16, 17, 18>
// resultIndex = 0
// value = <21, 22, 23, 24, 25, 26, 27, 28>
// valueIndex = 1
// Result = <22, 12, 13, 14, 15, 16, 17, 18>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<byte> InsertSelectedScalar(Vector64<byte> result, byte resultIndex, Vector128<byte> value, byte valueIndex)
Vector64<short> InsertSelectedScalar(Vector64<short> result, byte resultIndex, Vector64<short> value, byte valueIndex)
Vector64<short> InsertSelectedScalar(Vector64<short> result, byte resultIndex, Vector128<short> value, byte valueIndex)
Vector64<int> InsertSelectedScalar(Vector64<int> result, byte resultIndex, Vector64<int> value, byte valueIndex)
Vector64<int> InsertSelectedScalar(Vector64<int> result, byte resultIndex, Vector128<int> value, byte valueIndex)
Vector64<sbyte> InsertSelectedScalar(Vector64<sbyte> result, byte resultIndex, Vector64<sbyte> value, byte valueIndex)
Vector64<sbyte> InsertSelectedScalar(Vector64<sbyte> result, byte resultIndex, Vector128<sbyte> value, byte valueIndex)
Vector64<float> InsertSelectedScalar(Vector64<float> result, byte resultIndex, Vector64<float> value, byte valueIndex)
Vector64<float> InsertSelectedScalar(Vector64<float> result, byte resultIndex, Vector128<float> value, byte valueIndex)
Vector64<ushort> InsertSelectedScalar(Vector64<ushort> result, byte resultIndex, Vector64<ushort> value, byte valueIndex)
Vector64<ushort> InsertSelectedScalar(Vector64<ushort> result, byte resultIndex, Vector128<ushort> value, byte valueIndex)
Vector64<uint> InsertSelectedScalar(Vector64<uint> result, byte resultIndex, Vector64<uint> value, byte valueIndex)
Vector64<uint> InsertSelectedScalar(Vector64<uint> result, byte resultIndex, Vector128<uint> value, byte valueIndex)
Vector128<byte> InsertSelectedScalar(Vector128<byte> result, byte resultIndex, Vector64<byte> value, byte valueIndex)
Vector128<byte> InsertSelectedScalar(Vector128<byte> result, byte resultIndex, Vector128<byte> value, byte valueIndex)
Vector128<double> InsertSelectedScalar(Vector128<double> result, byte resultIndex, Vector128<double> value, byte valueIndex)
Vector128<short> InsertSelectedScalar(Vector128<short> result, byte resultIndex, Vector64<short> value, byte valueIndex)
Vector128<short> InsertSelectedScalar(Vector128<short> result, byte resultIndex, Vector128<short> value, byte valueIndex)
Vector128<int> InsertSelectedScalar(Vector128<int> result, byte resultIndex, Vector64<int> value, byte valueIndex)
Vector128<int> InsertSelectedScalar(Vector128<int> result, byte resultIndex, Vector128<int> value, byte valueIndex)
Vector128<long> InsertSelectedScalar(Vector128<long> result, byte resultIndex, Vector128<long> value, byte valueIndex)
Vector128<sbyte> InsertSelectedScalar(Vector128<sbyte> result, byte resultIndex, Vector64<sbyte> value, byte valueIndex)
Vector128<sbyte> InsertSelectedScalar(Vector128<sbyte> result, byte resultIndex, Vector128<sbyte> value, byte valueIndex)
Vector128<float> InsertSelectedScalar(Vector128<float> result, byte resultIndex, Vector64<float> value, byte valueIndex)
Vector128<float> InsertSelectedScalar(Vector128<float> result, byte resultIndex, Vector128<float> value, byte valueIndex)
Vector128<ushort> InsertSelectedScalar(Vector128<ushort> result, byte resultIndex, Vector64<ushort> value, byte valueIndex)
Vector128<ushort> InsertSelectedScalar(Vector128<ushort> result, byte resultIndex, Vector128<ushort> value, byte valueIndex)
Vector128<uint> InsertSelectedScalar(Vector128<uint> result, byte resultIndex, Vector64<uint> value, byte valueIndex)
Vector128<uint> InsertSelectedScalar(Vector128<uint> result, byte resultIndex, Vector128<uint> value, byte valueIndex)
Vector128<ulong> InsertSelectedScalar(Vector128<ulong> result, byte resultIndex, Vector128<ulong> value, byte valueIndex)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.insertselectedscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:InsertSelectedScalarTest(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte,System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->  x19        
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V03 arg3         [V03,T01] (  3,  3   )   ubyte  ->   x1        
;# V04 OutArgs      [V04    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V05 tmp1         [V05,T03] (  2,  4   )   simd8  ->   d8         HFA(simd8)  "Inlining Arg"
;  V06 tmp2         [V06,T04] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V07 tmp3         [V07,T05] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V08 tmp4         [V08,T06] (  2,  4   )   simd8  ->   d8         HFA(simd8)  "Inlining Arg"
;  V09 tmp5         [V09,T02] (  2,  4   )   ubyte  ->   x1         "Inlining Arg"
;
; Lcl frame size = 16

G_M38144_IG01:
            stp     fp, lr, [sp,#-48]!
            str     d8, [sp,#32]
            str     x19, [sp,#40]
            mov     fp, sp
            mov     w19, w0
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 6.00
G_M38144_IG02:
            ldr     d8, [fp,#24]
            ldr     d0, [fp,#16]
            uxtb    w0, w1
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:Extract(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):ubyte
            uxtb    w1, w0
            uxtb    w0, w19
            mov     v0.8b, v8.8b
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:Insert(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte,ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
						;; bbWeight=1    PerfScore 8.00
G_M38144_IG03:
            ldr     x19, [sp,#40]
            ldr     d8, [sp,#32]
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 6.00

; Total bytes of code 76, prolog size 16, PerfScore 27.60, (MethodHash=1dc16aff) for method AdvSimdMethods:InsertSelectedScalarTest(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte,System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 10. MaxAcross

`Vector64<byte> MaxAcross(Vector64<byte> value)`

Performs 'MaxAcross' operation.

```csharp
private Vector64<byte> MaxAcrossTest(Vector64<byte> value)
{
  return AdvSimd.Arm64.MaxAcross(value);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// Result = <18, 0, 0, 0, 0, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<short> MaxAcross(Vector64<short> value)
Vector64<sbyte> MaxAcross(Vector64<sbyte> value)
Vector64<ushort> MaxAcross(Vector64<ushort> value)
Vector64<byte> MaxAcross(Vector128<byte> value)
Vector64<short> MaxAcross(Vector128<short> value)
Vector64<int> MaxAcross(Vector128<int> value)
Vector64<sbyte> MaxAcross(Vector128<sbyte> value)
Vector64<float> MaxAcross(Vector128<float> value)
Vector64<ushort> MaxAcross(Vector128<ushort> value)
Vector64<uint> MaxAcross(Vector128<uint> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.maxacross?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MaxAcrossTest(System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M44874_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M44874_IG02:
            ldr     d16, [fp,#24]
            umaxv   b16, v16.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M44874_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=879450b5) for method AdvSimdMethods:MaxAcrossTest(System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 11. MaxNumberAcross

`Vector64<float> MaxNumberAcross(Vector128<float> value)`

Performs 'MaxNumberAcross' operation.

```csharp
private Vector64<float> MaxNumberAcrossTest(Vector128<float> value)
{
  return AdvSimd.Arm64.MaxNumberAcross(value);
}
// value = <11.5, 12.5, 13.5, 14.5>
// Result = <14.5, 0>

```



See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.maxnumberacross?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MaxNumberAcrossTest(System.Runtime.Intrinsics.Vector128`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M55888_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     q0, [fp,#16]
						;; bbWeight=1    PerfScore 2.50
G_M55888_IG02:
            ldr     q16, [fp,#16]
            fmaxnmv s16, v16.4s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M55888_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=670225af) for method AdvSimdMethods:MaxNumberAcrossTest(System.Runtime.Intrinsics.Vector128`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 12. MaxNumberPairwise

`Vector64<float> MaxNumberPairwise(Vector64<float> left, Vector64<float> right)`

Performs 'MaxNumberPairwise' operation.

```csharp
private Vector64<float> MaxNumberPairwiseTest(Vector64<float> left, Vector64<float> right)
{
  return AdvSimd.Arm64.MaxNumberPairwise(left, right);
}
// left = <11.5, 12.5>
// right = <21.5, 22.5>
// Result = <12.5, 22.5>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> MaxNumberPairwise(Vector128<double> left, Vector128<double> right)
Vector128<float> MaxNumberPairwise(Vector128<float> left, Vector128<float> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.maxnumberpairwise?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MaxNumberPairwiseTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M25941_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M25941_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            fmaxnmp v16.2s, v16.2s, v17.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M25941_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=77549aaa) for method AdvSimdMethods:MaxNumberPairwiseTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 13. MaxNumberPairwiseScalar

`Vector64<float> MaxNumberPairwiseScalar(Vector64<float> value)`

Performs 'MaxNumberPairwiseScalar' operation.

```csharp
private Vector64<float> MaxNumberPairwiseScalarTest(Vector64<float> value)
{
  return AdvSimd.Arm64.MaxNumberPairwiseScalar(value);
}
// value = <11.5, 12.5>
// Result = <12.5, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<double> MaxNumberPairwiseScalar(Vector128<double> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.maxnumberpairwisescalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MaxNumberPairwiseScalarTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M16346_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M16346_IG02:
            ldr     d16, [fp,#24]
            fmaxnmp s16, v16.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M16346_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=ffd9c025) for method AdvSimdMethods:MaxNumberPairwiseScalarTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 14. MaxPairwiseScalar

`Vector64<float> MaxPairwiseScalar(Vector64<float> value)`

Performs 'MaxPairwiseScalar' operation.

```csharp
private Vector64<float> MaxPairwiseScalarTest(Vector64<float> value)
{
  return AdvSimd.Arm64.MaxPairwiseScalar(value);
}
// value = <11.5, 12.5>
// Result = <12.5, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<double> MaxPairwiseScalar(Vector128<double> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.maxpairwisescalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MaxPairwiseScalarTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M64665_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M64665_IG02:
            ldr     d16, [fp,#24]
            fmaxp   s16, v16.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M64665_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=eeae0366) for method AdvSimdMethods:MaxPairwiseScalarTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 15. MaxScalar

`Vector64<double> MaxScalar(Vector64<double> left, Vector64<double> right)`

Performs 'MaxScalar' operation.

```csharp
private Vector64<double> MaxScalarTest(Vector64<double> left, Vector64<double> right)
{
  return AdvSimd.Arm64.MaxScalar(left, right);
}
// left = <11.5>
// right = <11.5>
// Result = <11.5>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<float> MaxScalar(Vector64<float> left, Vector64<float> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.maxscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MaxScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M32821_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M32821_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            fmax    d16, d16, d17
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M32821_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=8eea7fca) for method AdvSimdMethods:MaxScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 16. MinAcross

`Vector64<byte> MinAcross(Vector64<byte> value)`

Performs 'MinAcross' operation.

```csharp
private Vector64<byte> MinAcrossTest(Vector64<byte> value)
{
  return AdvSimd.Arm64.MinAcross(value);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// Result = <11, 0, 0, 0, 0, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<short> MinAcross(Vector64<short> value)
Vector64<sbyte> MinAcross(Vector64<sbyte> value)
Vector64<ushort> MinAcross(Vector64<ushort> value)
Vector64<byte> MinAcross(Vector128<byte> value)
Vector64<short> MinAcross(Vector128<short> value)
Vector64<int> MinAcross(Vector128<int> value)
Vector64<sbyte> MinAcross(Vector128<sbyte> value)
Vector64<float> MinAcross(Vector128<float> value)
Vector64<ushort> MinAcross(Vector128<ushort> value)
Vector64<uint> MinAcross(Vector128<uint> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.minacross?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MinAcrossTest(System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M8724_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M8724_IG02:
            ldr     d16, [fp,#24]
            uminv   b16, v16.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M8724_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=046cddeb) for method AdvSimdMethods:MinAcrossTest(System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 17. MinNumberAcross

`Vector64<float> MinNumberAcross(Vector128<float> value)`

Performs 'MinNumberAcross' operation.

```csharp
private Vector64<float> MinNumberAcrossTest(Vector128<float> value)
{
  return AdvSimd.Arm64.MinNumberAcross(value);
}
// value = <11.5, 12.5, 13.5, 14.5>
// Result = <11.5, 0>

```



See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.minnumberacross?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MinNumberAcrossTest(System.Runtime.Intrinsics.Vector128`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M38990_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     q0, [fp,#16]
						;; bbWeight=1    PerfScore 2.50
G_M38990_IG02:
            ldr     q16, [fp,#16]
            fminnmv s16, v16.4s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M38990_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=5f7167b1) for method AdvSimdMethods:MinNumberAcrossTest(System.Runtime.Intrinsics.Vector128`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 18. MinNumberPairwise

`Vector64<float> MinNumberPairwise(Vector64<float> left, Vector64<float> right)`

Performs 'MinNumberPairwise' operation.

```csharp
private Vector64<float> MinNumberPairwiseTest(Vector64<float> left, Vector64<float> right)
{
  return AdvSimd.Arm64.MinNumberPairwise(left, right);
}
// left = <11.5, 12.5>
// right = <21.5, 22.5>
// Result = <11.5, 21.5>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> MinNumberPairwise(Vector128<double> left, Vector128<double> right)
Vector128<float> MinNumberPairwise(Vector128<float> left, Vector128<float> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.minnumberpairwise?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MinNumberPairwiseTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M53707_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M53707_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            fminnmp v16.2s, v16.2s, v17.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M53707_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=75cd2e34) for method AdvSimdMethods:MinNumberPairwiseTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 19. MinNumberPairwiseScalar

`Vector64<float> MinNumberPairwiseScalar(Vector64<float> value)`

Performs 'MinNumberPairwiseScalar' operation.

```csharp
private Vector64<float> MinNumberPairwiseScalarTest(Vector64<float> value)
{
  return AdvSimd.Arm64.MinNumberPairwiseScalar(value);
}
// value = <11.5, 12.5>
// Result = <11.5, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<double> MinNumberPairwiseScalar(Vector128<double> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.minnumberpairwisescalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MinNumberPairwiseScalarTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M11140_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M11140_IG02:
            ldr     d16, [fp,#24]
            fminnmp s16, v16.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M11140_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=41eed47b) for method AdvSimdMethods:MinNumberPairwiseScalarTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 20. MinPairwiseScalar

`Vector64<float> MinPairwiseScalar(Vector64<float> value)`

Performs 'MinPairwiseScalar' operation.

```csharp
private Vector64<float> MinPairwiseScalarTest(Vector64<float> value)
{
  return AdvSimd.Arm64.MinPairwiseScalar(value);
}
// value = <11.5, 12.5>
// Result = <11.5, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<double> MinPairwiseScalar(Vector128<double> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.minpairwisescalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MinPairwiseScalarTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M21063_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M21063_IG02:
            ldr     d16, [fp,#24]
            fminp   s16, v16.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M21063_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=4ec7adb8) for method AdvSimdMethods:MinPairwiseScalarTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 21. MinScalar

`Vector64<double> MinScalar(Vector64<double> left, Vector64<double> right)`

Performs 'MinScalar' operation.

```csharp
private Vector64<double> MinScalarTest(Vector64<double> left, Vector64<double> right)
{
  return AdvSimd.Arm64.MinScalar(left, right);
}
// left = <11.5>
// right = <11.5>
// Result = <11.5>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<float> MinScalar(Vector64<float> left, Vector64<float> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.minscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MinScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M31915_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M31915_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            fmin    d16, d16, d17
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M31915_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=6cb78354) for method AdvSimdMethods:MinScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 22. MultiplyDoublingSaturateHighScalar

`Vector64<short> MultiplyDoublingSaturateHighScalar(Vector64<short> left, Vector64<short> right)`

Performs 'MultiplyDoublingSaturateHighScalar' operation.

```csharp
private Vector64<short> MultiplyDoublingSaturateHighScalarTest(Vector64<short> left, Vector64<short> right)
{
  return AdvSimd.Arm64.MultiplyDoublingSaturateHighScalar(left, right);
}
// left = <11, 12, 13, 14>
// right = <21, 22, 23, 24>
// Result = <0, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<int> MultiplyDoublingSaturateHighScalar(Vector64<int> left, Vector64<int> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.multiplydoublingsaturatehighscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyDoublingSaturateHighScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M8803_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M8803_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            sqdmulh h16, h16, h17
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M8803_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=3700dd9c) for method AdvSimdMethods:MultiplyDoublingSaturateHighScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 23. MultiplyDoublingScalarBySelectedScalarSaturateHigh

`Vector64<short> MultiplyDoublingScalarBySelectedScalarSaturateHigh(Vector64<short> left, Vector64<short> right, byte rightIndex)`

Performs 'MultiplyDoublingScalarBySelectedScalarSaturateHigh' operation.

```csharp
private Vector64<short> MultiplyDoublingScalarBySelectedScalarSaturateHighTest(Vector64<short> left, Vector64<short> right, byte rightIndex)
{
  return AdvSimd.Arm64.MultiplyDoublingScalarBySelectedScalarSaturateHigh(left, right, rightIndex);
}
// left = <11, 12, 13, 14>
// right = <21, 22, 23, 24>
// rightIndex = 0
// Result = <0, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<short> MultiplyDoublingScalarBySelectedScalarSaturateHigh(Vector64<short> left, Vector128<short> right, byte rightIndex)
Vector64<int> MultiplyDoublingScalarBySelectedScalarSaturateHigh(Vector64<int> left, Vector64<int> right, byte rightIndex)
Vector64<int> MultiplyDoublingScalarBySelectedScalarSaturateHigh(Vector64<int> left, Vector128<int> right, byte rightIndex)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.multiplydoublingscalarbyselectedscalarsaturatehigh?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyDoublingScalarBySelectedScalarSaturateHighTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M23340_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M23340_IG02:
            ldr     d0, [fp,#24]
            ldr     d1, [fp,#16]
            uxtb    w0, w0
            bl      Arm64:MultiplyDoublingScalarBySelectedScalarSaturateHigh(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
						;; bbWeight=1    PerfScore 5.50
G_M23340_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=1406a4d3) for method AdvSimdMethods:MultiplyDoublingScalarBySelectedScalarSaturateHighTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 24. MultiplyDoublingWideningAndAddSaturateScalar

`Vector64<int> MultiplyDoublingWideningAndAddSaturateScalar(Vector64<int> addend, Vector64<short> left, Vector64<short> right)`

Performs 'MultiplyDoublingWideningAndAddSaturateScalar' operation.

```csharp
private Vector64<int> MultiplyDoublingWideningAndAddSaturateScalarTest(Vector64<int> addend, Vector64<short> left, Vector64<short> right)
{
  return AdvSimd.Arm64.MultiplyDoublingWideningAndAddSaturateScalar(addend, left, right);
}
// addend = <11, 12>
// left = <11, 12, 13, 14>
// right = <21, 22, 23, 24>
// Result = <473, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<long> MultiplyDoublingWideningAndAddSaturateScalar(Vector64<long> addend, Vector64<int> left, Vector64<int> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.multiplydoublingwideningandaddsaturatescalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyDoublingWideningAndAddSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x20]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M59801_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     d1, [fp,#32]
            str     d2, [fp,#24]
						;; bbWeight=1    PerfScore 4.50
G_M59801_IG02:
            ldr     d16, [fp,#40]
            ldr     d17, [fp,#32]
            ldr     d18, [fp,#24]
            sqdmlal s16, h17, h18
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M59801_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 18.80, (MethodHash=e38a1666) for method AdvSimdMethods:MultiplyDoublingWideningAndAddSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int32]
; ============================================================


```
------------------------------------------------

### 25. MultiplyDoublingWideningAndSubtractSaturateScalar

`Vector64<int> MultiplyDoublingWideningAndSubtractSaturateScalar(Vector64<int> minuend, Vector64<short> left, Vector64<short> right)`

Performs 'MultiplyDoublingWideningAndSubtractSaturateScalar' operation.

```csharp
private Vector64<int> MultiplyDoublingWideningAndSubtractSaturateScalarTest(Vector64<int> minuend, Vector64<short> left, Vector64<short> right)
{
  return AdvSimd.Arm64.MultiplyDoublingWideningAndSubtractSaturateScalar(minuend, left, right);
}
// minuend = <11, 12>
// left = <11, 12, 13, 14>
// right = <21, 22, 23, 24>
// Result = <-451, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<long> MultiplyDoublingWideningAndSubtractSaturateScalar(Vector64<long> minuend, Vector64<int> left, Vector64<int> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.multiplydoublingwideningandsubtractsaturatescalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyDoublingWideningAndSubtractSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x20]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M4524_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     d1, [fp,#32]
            str     d2, [fp,#24]
						;; bbWeight=1    PerfScore 4.50
G_M4524_IG02:
            ldr     d16, [fp,#40]
            ldr     d17, [fp,#32]
            ldr     d18, [fp,#24]
            sqdmlsl s16, h17, h18
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M4524_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 18.80, (MethodHash=32eeee53) for method AdvSimdMethods:MultiplyDoublingWideningAndSubtractSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int32]
; ============================================================


```
------------------------------------------------

### 26. MultiplyDoublingWideningSaturateScalar

`Vector64<int> MultiplyDoublingWideningSaturateScalar(Vector64<short> left, Vector64<short> right)`

Performs 'MultiplyDoublingWideningSaturateScalar' operation.

```csharp
private Vector64<int> MultiplyDoublingWideningSaturateScalarTest(Vector64<short> left, Vector64<short> right)
{
  return AdvSimd.Arm64.MultiplyDoublingWideningSaturateScalar(left, right);
}
// left = <11, 12, 13, 14>
// right = <21, 22, 23, 24>
// Result = <462, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<long> MultiplyDoublingWideningSaturateScalar(Vector64<int> left, Vector64<int> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.multiplydoublingwideningsaturatescalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyDoublingWideningSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M62810_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M62810_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            sqdmull s16, h16, h17
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M62810_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=15c30aa5) for method AdvSimdMethods:MultiplyDoublingWideningSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int32]
; ============================================================


```
------------------------------------------------

### 27. MultiplyDoublingWideningSaturateScalarBySelectedScalar

`Vector64<int> MultiplyDoublingWideningSaturateScalarBySelectedScalar(Vector64<short> left, Vector64<short> right, byte rightIndex)`

Performs 'MultiplyDoublingWideningSaturateScalarBySelectedScalar' operation.

```csharp
private Vector64<int> MultiplyDoublingWideningSaturateScalarBySelectedScalarTest(Vector64<short> left, Vector64<short> right, byte rightIndex)
{
  return AdvSimd.Arm64.MultiplyDoublingWideningSaturateScalarBySelectedScalar(left, right, rightIndex);
}
// left = <11, 12, 13, 14>
// right = <21, 22, 23, 24>
// rightIndex = 0
// Result = <462, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<int> MultiplyDoublingWideningSaturateScalarBySelectedScalar(Vector64<short> left, Vector128<short> right, byte rightIndex)
Vector64<long> MultiplyDoublingWideningSaturateScalarBySelectedScalar(Vector64<int> left, Vector64<int> right, byte rightIndex)
Vector64<long> MultiplyDoublingWideningSaturateScalarBySelectedScalar(Vector64<int> left, Vector128<int> right, byte rightIndex)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.multiplydoublingwideningsaturatescalarbyselectedscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyDoublingWideningSaturateScalarBySelectedScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M27861_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M27861_IG02:
            ldr     d0, [fp,#24]
            ldr     d1, [fp,#16]
            uxtb    w0, w0
            bl      Arm64:MultiplyDoublingWideningSaturateScalarBySelectedScalar(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int32]
						;; bbWeight=1    PerfScore 5.50
G_M27861_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=8079932a) for method AdvSimdMethods:MultiplyDoublingWideningSaturateScalarBySelectedScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int32]
; ============================================================


```
------------------------------------------------

### 28. MultiplyDoublingWideningScalarBySelectedScalarAndAddSaturate

`Vector64<int> MultiplyDoublingWideningScalarBySelectedScalarAndAddSaturate(Vector64<int> addend, Vector64<short> left, Vector64<short> right, byte rightIndex)`

Performs 'MultiplyDoublingWideningScalarBySelectedScalarAndAddSaturate' operation.

```csharp
private Vector64<int> MultiplyDoublingWideningScalarBySelectedScalarAndAddSaturateTest(Vector64<int> addend, Vector64<short> left, Vector64<short> right, byte rightIndex)
{
  return AdvSimd.Arm64.MultiplyDoublingWideningScalarBySelectedScalarAndAddSaturate(addend, left, right, rightIndex);
}
// addend = <11, 12>
// left = <11, 12, 13, 14>
// right = <21, 22, 23, 24>
// rightIndex = 0
// Result = <473, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<int> MultiplyDoublingWideningScalarBySelectedScalarAndAddSaturate(Vector64<int> addend, Vector64<short> left, Vector128<short> right, byte rightIndex)
Vector64<long> MultiplyDoublingWideningScalarBySelectedScalarAndAddSaturate(Vector64<long> addend, Vector64<int> left, Vector64<int> right, byte rightIndex)
Vector64<long> MultiplyDoublingWideningScalarBySelectedScalarAndAddSaturate(Vector64<long> addend, Vector64<int> left, Vector128<int> right, byte rightIndex)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.multiplydoublingwideningscalarbyselectedscalarandaddsaturate?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyDoublingWideningScalarBySelectedScalarAndAddSaturateTest(System.Runtime.Intrinsics.Vector64`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x20]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V03 arg3         [V03,T00] (  3,  3   )   ubyte  ->   x0        
;# V04 OutArgs      [V04    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V05 tmp1         [V05,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V06 tmp2         [V06,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;  V07 tmp3         [V07,T03] (  2,  4   )   simd8  ->   d2         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 32

G_M63702_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     d1, [fp,#32]
            str     d2, [fp,#24]
						;; bbWeight=1    PerfScore 4.50
G_M63702_IG02:
            ldr     d0, [fp,#40]
            ldr     d1, [fp,#32]
            ldr     d2, [fp,#24]
            uxtb    w0, w0
            bl      Arm64:MultiplyDoublingWideningScalarBySelectedScalarAndAddSaturate(System.Runtime.Intrinsics.Vector64`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int32]
						;; bbWeight=1    PerfScore 7.50
G_M63702_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 18.80, (MethodHash=bff70729) for method AdvSimdMethods:MultiplyDoublingWideningScalarBySelectedScalarAndAddSaturateTest(System.Runtime.Intrinsics.Vector64`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int32]
; ============================================================


```
------------------------------------------------

### 29. MultiplyDoublingWideningScalarBySelectedScalarAndSubtractSaturate

`Vector64<int> MultiplyDoublingWideningScalarBySelectedScalarAndSubtractSaturate(Vector64<int> minuend, Vector64<short> left, Vector64<short> right, byte rightIndex)`

Performs 'MultiplyDoublingWideningScalarBySelectedScalarAndSubtractSaturate' operation.

```csharp
private Vector64<int> MultiplyDoublingWideningScalarBySelectedScalarAndSubtractSaturateTest(Vector64<int> minuend, Vector64<short> left, Vector64<short> right, byte rightIndex)
{
  return AdvSimd.Arm64.MultiplyDoublingWideningScalarBySelectedScalarAndSubtractSaturate(minuend, left, right, rightIndex);
}
// minuend = <11, 12>
// left = <11, 12, 13, 14>
// right = <21, 22, 23, 24>
// rightIndex = 0
// Result = <-451, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<int> MultiplyDoublingWideningScalarBySelectedScalarAndSubtractSaturate(Vector64<int> minuend, Vector64<short> left, Vector128<short> right, byte rightIndex)
Vector64<long> MultiplyDoublingWideningScalarBySelectedScalarAndSubtractSaturate(Vector64<long> minuend, Vector64<int> left, Vector64<int> right, byte rightIndex)
Vector64<long> MultiplyDoublingWideningScalarBySelectedScalarAndSubtractSaturate(Vector64<long> minuend, Vector64<int> left, Vector128<int> right, byte rightIndex)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.multiplydoublingwideningscalarbyselectedscalarandsubtractsaturate?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyDoublingWideningScalarBySelectedScalarAndSubtractSaturateTest(System.Runtime.Intrinsics.Vector64`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x20]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V03 arg3         [V03,T00] (  3,  3   )   ubyte  ->   x0        
;# V04 OutArgs      [V04    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V05 tmp1         [V05,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V06 tmp2         [V06,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;  V07 tmp3         [V07,T03] (  2,  4   )   simd8  ->   d2         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 32

G_M31139_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     d1, [fp,#32]
            str     d2, [fp,#24]
						;; bbWeight=1    PerfScore 4.50
G_M31139_IG02:
            ldr     d0, [fp,#40]
            ldr     d1, [fp,#32]
            ldr     d2, [fp,#24]
            uxtb    w0, w0
            bl      Arm64:MultiplyDoublingWideningScalarBySelectedScalarAndSubtractSaturate(System.Runtime.Intrinsics.Vector64`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int32]
						;; bbWeight=1    PerfScore 7.50
G_M31139_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 18.80, (MethodHash=5539865c) for method AdvSimdMethods:MultiplyDoublingWideningScalarBySelectedScalarAndSubtractSaturateTest(System.Runtime.Intrinsics.Vector64`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int32]
; ============================================================


```
------------------------------------------------

### 30. MultiplyExtended

`Vector64<float> MultiplyExtended(Vector64<float> left, Vector64<float> right)`

Performs 'MultiplyExtended' operation.

```csharp
private Vector64<float> MultiplyExtendedTest(Vector64<float> left, Vector64<float> right)
{
  return AdvSimd.Arm64.MultiplyExtended(left, right);
}
// left = <11.5, 12.5>
// right = <21.5, 22.5>
// Result = <247.25, 281.25>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> MultiplyExtended(Vector128<double> left, Vector128<double> right)
Vector128<float> MultiplyExtended(Vector128<float> left, Vector128<float> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.multiplyextended?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyExtendedTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M39019_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M39019_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            fmulx   v16.2s, v16.2s, v17.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M39019_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=21936794) for method AdvSimdMethods:MultiplyExtendedTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 31. MultiplyExtendedByScalar

`Vector128<double> MultiplyExtendedByScalar(Vector128<double> left, Vector64<double> right)`

Performs 'MultiplyExtendedByScalar' operation.

```csharp
private Vector128<double> MultiplyExtendedByScalarTest(Vector128<double> left, Vector64<double> right)
{
  return AdvSimd.Arm64.MultiplyExtendedByScalar(left, right);
}
// left = <11.5, 12.5>
// right = <11.5>
// Result = <132.25, 143.75>

```



See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.multiplyextendedbyscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyExtendedByScalarTest(System.Runtime.Intrinsics.Vector128`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector128`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M5169_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     q0, [fp,#32]
            str     d1, [fp,#24]
						;; bbWeight=1    PerfScore 3.50
G_M5169_IG02:
            ldr     q16, [fp,#32]
            ldr     d17, [fp,#24]
            fmulx   v16.2d, v16.2d, v17.d[0]
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 7.50
G_M5169_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=3e51ebce) for method AdvSimdMethods:MultiplyExtendedByScalarTest(System.Runtime.Intrinsics.Vector128`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector128`1[Double]
; ============================================================


```
------------------------------------------------

### 32. MultiplyExtendedBySelectedScalar

`Vector64<float> MultiplyExtendedBySelectedScalar(Vector64<float> left, Vector64<float> right, byte rightIndex)`

Performs 'MultiplyExtendedBySelectedScalar' operation.

```csharp
private Vector64<float> MultiplyExtendedBySelectedScalarTest(Vector64<float> left, Vector64<float> right, byte rightIndex)
{
  return AdvSimd.Arm64.MultiplyExtendedBySelectedScalar(left, right, rightIndex);
}
// left = <11.5, 12.5>
// right = <21.5, 22.5>
// rightIndex = 0
// Result = <247.25, 268.75>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<float> MultiplyExtendedBySelectedScalar(Vector64<float> left, Vector128<float> right, byte rightIndex)
Vector128<double> MultiplyExtendedBySelectedScalar(Vector128<double> left, Vector128<double> right, byte rightIndex)
Vector128<float> MultiplyExtendedBySelectedScalar(Vector128<float> left, Vector64<float> right, byte rightIndex)
Vector128<float> MultiplyExtendedBySelectedScalar(Vector128<float> left, Vector128<float> right, byte rightIndex)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.multiplyextendedbyselectedscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyExtendedBySelectedScalarTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single],ubyte):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M61700_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M61700_IG02:
            ldr     d0, [fp,#24]
            ldr     d1, [fp,#16]
            uxtb    w0, w0
            bl      Arm64:MultiplyExtendedBySelectedScalar(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single],ubyte):System.Runtime.Intrinsics.Vector64`1[Single]
						;; bbWeight=1    PerfScore 5.50
G_M61700_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=592a0efb) for method AdvSimdMethods:MultiplyExtendedBySelectedScalarTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single],ubyte):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 33. MultiplyExtendedScalar

`Vector64<double> MultiplyExtendedScalar(Vector64<double> left, Vector64<double> right)`

Performs 'MultiplyExtendedScalar' operation.

```csharp
private Vector64<double> MultiplyExtendedScalarTest(Vector64<double> left, Vector64<double> right)
{
  return AdvSimd.Arm64.MultiplyExtendedScalar(left, right);
}
// left = <11.5>
// right = <11.5>
// Result = <132.25>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<float> MultiplyExtendedScalar(Vector64<float> left, Vector64<float> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.multiplyextendedscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyExtendedScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M34730_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M34730_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            fmulx   d16, d16, d17
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M34730_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=985e7855) for method AdvSimdMethods:MultiplyExtendedScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 34. MultiplyExtendedScalarBySelectedScalar

`Vector64<double> MultiplyExtendedScalarBySelectedScalar(Vector64<double> left, Vector128<double> right, byte rightIndex)`

Performs 'MultiplyExtendedScalarBySelectedScalar' operation.

```csharp
private Vector64<double> MultiplyExtendedScalarBySelectedScalarTest(Vector64<double> left, Vector128<double> right, byte rightIndex)
{
  return AdvSimd.Arm64.MultiplyExtendedScalarBySelectedScalar(left, right, rightIndex);
}
// left = <11.5>
// right = <11.5, 12.5>
// rightIndex = 0
// Result = <132.25>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<float> MultiplyExtendedScalarBySelectedScalar(Vector64<float> left, Vector64<float> right, byte rightIndex)
Vector64<float> MultiplyExtendedScalarBySelectedScalar(Vector64<float> left, Vector128<float> right, byte rightIndex)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.multiplyextendedscalarbyselectedscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyExtendedScalarBySelectedScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector128`1[Double],ubyte):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T02] (  2,  4   )  simd16  ->   d1         HFA(simd16)  "Inlining Arg"
;
; Lcl frame size = 32

G_M34108_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     q1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M34108_IG02:
            ldr     d0, [fp,#40]
            ldr     q1, [fp,#16]
            uxtb    w0, w0
            bl      Arm64:MultiplyExtendedScalarBySelectedScalar(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector128`1[Double],ubyte):System.Runtime.Intrinsics.Vector64`1[Double]
						;; bbWeight=1    PerfScore 5.50
G_M34108_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=05e07ac3) for method AdvSimdMethods:MultiplyExtendedScalarBySelectedScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector128`1[Double],ubyte):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 35. MultiplyRoundedDoublingSaturateHighScalar

`Vector64<short> MultiplyRoundedDoublingSaturateHighScalar(Vector64<short> left, Vector64<short> right)`

Performs 'MultiplyRoundedDoublingSaturateHighScalar' operation.

```csharp
private Vector64<short> MultiplyRoundedDoublingSaturateHighScalarTest(Vector64<short> left, Vector64<short> right)
{
  return AdvSimd.Arm64.MultiplyRoundedDoublingSaturateHighScalar(left, right);
}
// left = <11, 12, 13, 14>
// right = <21, 22, 23, 24>
// Result = <0, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<int> MultiplyRoundedDoublingSaturateHighScalar(Vector64<int> left, Vector64<int> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.multiplyroundeddoublingsaturatehighscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyRoundedDoublingSaturateHighScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M19808_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M19808_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            sqrdmulh h16, h16, h17
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M19808_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=c960b29f) for method AdvSimdMethods:MultiplyRoundedDoublingSaturateHighScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 36. MultiplyRoundedDoublingScalarBySelectedScalarSaturateHigh

`Vector64<short> MultiplyRoundedDoublingScalarBySelectedScalarSaturateHigh(Vector64<short> left, Vector64<short> right, byte rightIndex)`

Performs 'MultiplyRoundedDoublingScalarBySelectedScalarSaturateHigh' operation.

```csharp
private Vector64<short> MultiplyRoundedDoublingScalarBySelectedScalarSaturateHighTest(Vector64<short> left, Vector64<short> right, byte rightIndex)
{
  return AdvSimd.Arm64.MultiplyRoundedDoublingScalarBySelectedScalarSaturateHigh(left, right, rightIndex);
}
// left = <11, 12, 13, 14>
// right = <21, 22, 23, 24>
// rightIndex = 0
// Result = <0, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<short> MultiplyRoundedDoublingScalarBySelectedScalarSaturateHigh(Vector64<short> left, Vector128<short> right, byte rightIndex)
Vector64<int> MultiplyRoundedDoublingScalarBySelectedScalarSaturateHigh(Vector64<int> left, Vector64<int> right, byte rightIndex)
Vector64<int> MultiplyRoundedDoublingScalarBySelectedScalarSaturateHigh(Vector64<int> left, Vector128<int> right, byte rightIndex)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.multiplyroundeddoublingscalarbyselectedscalarsaturatehigh?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyRoundedDoublingScalarBySelectedScalarSaturateHighTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M5999_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M5999_IG02:
            ldr     d0, [fp,#24]
            ldr     d1, [fp,#16]
            uxtb    w0, w0
            bl      Arm64:MultiplyRoundedDoublingScalarBySelectedScalarSaturateHigh(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
						;; bbWeight=1    PerfScore 5.50
G_M5999_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=42f7e890) for method AdvSimdMethods:MultiplyRoundedDoublingScalarBySelectedScalarSaturateHighTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 37. NegateSaturateScalar

`Vector64<short> NegateSaturateScalar(Vector64<short> value)`

Performs 'NegateSaturateScalar' operation.

```csharp
private Vector64<short> NegateSaturateScalarTest(Vector64<short> value)
{
  return AdvSimd.Arm64.NegateSaturateScalar(value);
}
// value = <11, 12, 13, 14>
// Result = <-11, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<int> NegateSaturateScalar(Vector64<int> value)
Vector64<long> NegateSaturateScalar(Vector64<long> value)
Vector64<sbyte> NegateSaturateScalar(Vector64<sbyte> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.negatesaturatescalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:NegateSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M11298_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M11298_IG02:
            ldr     d16, [fp,#24]
            sqneg   h16, h16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 4.50
G_M11298_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 12.20, (MethodHash=490ed3dd) for method AdvSimdMethods:NegateSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 38. ReciprocalEstimateScalar

`Vector64<double> ReciprocalEstimateScalar(Vector64<double> value)`

Performs 'ReciprocalEstimateScalar' operation.

```csharp
private Vector64<double> ReciprocalEstimateScalarTest(Vector64<double> value)
{
  return AdvSimd.Arm64.ReciprocalEstimateScalar(value);
}
// value = <11.5>
// Result = <0.0869140625>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<float> ReciprocalEstimateScalar(Vector64<float> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.reciprocalestimatescalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ReciprocalEstimateScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M53095_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M53095_IG02:
            ldr     d16, [fp,#24]
            frecpe  d16, d16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M53095_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=fb743098) for method AdvSimdMethods:ReciprocalEstimateScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 39. ReciprocalExponentScalar

`Vector64<double> ReciprocalExponentScalar(Vector64<double> value)`

Performs 'ReciprocalExponentScalar' operation.

```csharp
private Vector64<double> ReciprocalExponentScalarTest(Vector64<double> value)
{
  return AdvSimd.Arm64.ReciprocalExponentScalar(value);
}
// value = <11.5>
// Result = <0.25>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<float> ReciprocalExponentScalar(Vector64<float> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.reciprocalexponentscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ReciprocalExponentScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M17186_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M17186_IG02:
            ldr     d16, [fp,#24]
            frecpx  d16, d16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M17186_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=c12dbcdd) for method AdvSimdMethods:ReciprocalExponentScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 40. ReciprocalSquareRootEstimateScalar

`Vector64<double> ReciprocalSquareRootEstimateScalar(Vector64<double> value)`

Performs 'ReciprocalSquareRootEstimateScalar' operation.

```csharp
private Vector64<double> ReciprocalSquareRootEstimateScalarTest(Vector64<double> value)
{
  return AdvSimd.Arm64.ReciprocalSquareRootEstimateScalar(value);
}
// value = <11.5>
// Result = <0.294921875>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<float> ReciprocalSquareRootEstimateScalar(Vector64<float> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.reciprocalsquarerootestimatescalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ReciprocalSquareRootEstimateScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M57056_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M57056_IG02:
            ldr     d16, [fp,#24]
            frsqrte d16, d16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M57056_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=c33e211f) for method AdvSimdMethods:ReciprocalSquareRootEstimateScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 41. ReciprocalSquareRootStepScalar

`Vector64<double> ReciprocalSquareRootStepScalar(Vector64<double> left, Vector64<double> right)`

Performs 'ReciprocalSquareRootStepScalar' operation.

```csharp
private Vector64<double> ReciprocalSquareRootStepScalarTest(Vector64<double> left, Vector64<double> right)
{
  return AdvSimd.Arm64.ReciprocalSquareRootStepScalar(left, right);
}
// left = <11.5>
// right = <11.5>
// Result = <-64.625>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<float> ReciprocalSquareRootStepScalar(Vector64<float> left, Vector64<float> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.reciprocalsquarerootstepscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ReciprocalSquareRootStepScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M41706_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M41706_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            frsqrts d16, d16, d17
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M41706_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=bfce5d15) for method AdvSimdMethods:ReciprocalSquareRootStepScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 42. ReciprocalStepScalar

`Vector64<double> ReciprocalStepScalar(Vector64<double> left, Vector64<double> right)`

Performs 'ReciprocalStepScalar' operation.

```csharp
private Vector64<double> ReciprocalStepScalarTest(Vector64<double> left, Vector64<double> right)
{
  return AdvSimd.Arm64.ReciprocalStepScalar(left, right);
}
// left = <11.5>
// right = <11.5>
// Result = <-130.25>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<float> ReciprocalStepScalar(Vector64<float> left, Vector64<float> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.reciprocalstepscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ReciprocalStepScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M46733_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M46733_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            frecps  d16, d16, d17
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M46733_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=a4b44972) for method AdvSimdMethods:ReciprocalStepScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 43. ShiftRightArithmeticNarrowingSaturateScalar

`Vector64<short> ShiftRightArithmeticNarrowingSaturateScalar(Vector64<int> value, byte count)`

Performs 'ShiftRightArithmeticNarrowingSaturateScalar' operation.

```csharp
private Vector64<short> ShiftRightArithmeticNarrowingSaturateScalarTest(Vector64<int> value, byte count)
{
  return AdvSimd.Arm64.ShiftRightArithmeticNarrowingSaturateScalar(value, count);
}
// value = <11, 12>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<int> ShiftRightArithmeticNarrowingSaturateScalar(Vector64<long> value, byte count)
Vector64<sbyte> ShiftRightArithmeticNarrowingSaturateScalar(Vector64<short> value, byte count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.shiftrightarithmeticnarrowingsaturatescalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftRightArithmeticNarrowingSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[Int32],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M27980_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M27980_IG02:
            ldr     d0, [fp,#24]
            uxtb    w0, w0
            bl      Arm64:ShiftRightArithmeticNarrowingSaturateScalar(System.Runtime.Intrinsics.Vector64`1[Int32],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
						;; bbWeight=1    PerfScore 3.50
G_M27980_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=079392b3) for method AdvSimdMethods:ShiftRightArithmeticNarrowingSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[Int32],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 44. ShiftRightArithmeticNarrowingSaturateUnsignedScalar

`Vector64<byte> ShiftRightArithmeticNarrowingSaturateUnsignedScalar(Vector64<short> value, byte count)`

Performs 'ShiftRightArithmeticNarrowingSaturateUnsignedScalar' operation.

```csharp
private Vector64<byte> ShiftRightArithmeticNarrowingSaturateUnsignedScalarTest(Vector64<short> value, byte count)
{
  return AdvSimd.Arm64.ShiftRightArithmeticNarrowingSaturateUnsignedScalar(value, count);
}
// value = <11, 12, 13, 14>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<ushort> ShiftRightArithmeticNarrowingSaturateUnsignedScalar(Vector64<int> value, byte count)
Vector64<uint> ShiftRightArithmeticNarrowingSaturateUnsignedScalar(Vector64<long> value, byte count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.shiftrightarithmeticnarrowingsaturateunsignedscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftRightArithmeticNarrowingSaturateUnsignedScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M41341_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M41341_IG02:
            ldr     d0, [fp,#24]
            uxtb    w0, w0
            bl      Arm64:ShiftRightArithmeticNarrowingSaturateUnsignedScalar(System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
						;; bbWeight=1    PerfScore 3.50
G_M41341_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=bd5d5e82) for method AdvSimdMethods:ShiftRightArithmeticNarrowingSaturateUnsignedScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 45. ShiftRightArithmeticRoundedNarrowingSaturateScalar

`Vector64<short> ShiftRightArithmeticRoundedNarrowingSaturateScalar(Vector64<int> value, byte count)`

Performs 'ShiftRightArithmeticRoundedNarrowingSaturateScalar' operation.

```csharp
private Vector64<short> ShiftRightArithmeticRoundedNarrowingSaturateScalarTest(Vector64<int> value, byte count)
{
  return AdvSimd.Arm64.ShiftRightArithmeticRoundedNarrowingSaturateScalar(value, count);
}
// value = <11, 12>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<int> ShiftRightArithmeticRoundedNarrowingSaturateScalar(Vector64<long> value, byte count)
Vector64<sbyte> ShiftRightArithmeticRoundedNarrowingSaturateScalar(Vector64<short> value, byte count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.shiftrightarithmeticroundednarrowingsaturatescalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftRightArithmeticRoundedNarrowingSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[Int32],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M48431_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M48431_IG02:
            ldr     d0, [fp,#24]
            uxtb    w0, w0
            bl      Arm64:ShiftRightArithmeticRoundedNarrowingSaturateScalar(System.Runtime.Intrinsics.Vector64`1[Int32],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
						;; bbWeight=1    PerfScore 3.50
G_M48431_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=4eac42d0) for method AdvSimdMethods:ShiftRightArithmeticRoundedNarrowingSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[Int32],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 46. ShiftRightArithmeticRoundedNarrowingSaturateUnsignedScalar

`Vector64<byte> ShiftRightArithmeticRoundedNarrowingSaturateUnsignedScalar(Vector64<short> value, byte count)`

Performs 'ShiftRightArithmeticRoundedNarrowingSaturateUnsignedScalar' operation.

```csharp
private Vector64<byte> ShiftRightArithmeticRoundedNarrowingSaturateUnsignedScalarTest(Vector64<short> value, byte count)
{
  return AdvSimd.Arm64.ShiftRightArithmeticRoundedNarrowingSaturateUnsignedScalar(value, count);
}
// value = <11, 12, 13, 14>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<ushort> ShiftRightArithmeticRoundedNarrowingSaturateUnsignedScalar(Vector64<int> value, byte count)
Vector64<uint> ShiftRightArithmeticRoundedNarrowingSaturateUnsignedScalar(Vector64<long> value, byte count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.shiftrightarithmeticroundednarrowingsaturateunsignedscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftRightArithmeticRoundedNarrowingSaturateUnsignedScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M52798_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M52798_IG02:
            ldr     d0, [fp,#24]
            uxtb    w0, w0
            bl      Arm64:ShiftRightArithmeticRoundedNarrowingSaturateUnsignedScalar(System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
						;; bbWeight=1    PerfScore 3.50
G_M52798_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=fb1131c1) for method AdvSimdMethods:ShiftRightArithmeticRoundedNarrowingSaturateUnsignedScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 47. ShiftRightLogicalNarrowingSaturateScalar

`Vector64<byte> ShiftRightLogicalNarrowingSaturateScalar(Vector64<ushort> value, byte count)`

Performs 'ShiftRightLogicalNarrowingSaturateScalar' operation.

```csharp
private Vector64<byte> ShiftRightLogicalNarrowingSaturateScalarTest(Vector64<ushort> value, byte count)
{
  return AdvSimd.Arm64.ShiftRightLogicalNarrowingSaturateScalar(value, count);
}
// value = <11, 12, 13, 14>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<short> ShiftRightLogicalNarrowingSaturateScalar(Vector64<int> value, byte count)
Vector64<int> ShiftRightLogicalNarrowingSaturateScalar(Vector64<long> value, byte count)
Vector64<sbyte> ShiftRightLogicalNarrowingSaturateScalar(Vector64<short> value, byte count)
Vector64<ushort> ShiftRightLogicalNarrowingSaturateScalar(Vector64<uint> value, byte count)
Vector64<uint> ShiftRightLogicalNarrowingSaturateScalar(Vector64<ulong> value, byte count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.shiftrightlogicalnarrowingsaturatescalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftRightLogicalNarrowingSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[UInt16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M24082_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M24082_IG02:
            ldr     d0, [fp,#24]
            uxtb    w0, w0
            bl      Arm64:ShiftRightLogicalNarrowingSaturateScalar(System.Runtime.Intrinsics.Vector64`1[UInt16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
						;; bbWeight=1    PerfScore 3.50
G_M24082_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=724ea1ed) for method AdvSimdMethods:ShiftRightLogicalNarrowingSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[UInt16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 48. ShiftRightLogicalRoundedNarrowingSaturateScalar

`Vector64<byte> ShiftRightLogicalRoundedNarrowingSaturateScalar(Vector64<ushort> value, byte count)`

Performs 'ShiftRightLogicalRoundedNarrowingSaturateScalar' operation.

```csharp
private Vector64<byte> ShiftRightLogicalRoundedNarrowingSaturateScalarTest(Vector64<ushort> value, byte count)
{
  return AdvSimd.Arm64.ShiftRightLogicalRoundedNarrowingSaturateScalar(value, count);
}
// value = <11, 12, 13, 14>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<short> ShiftRightLogicalRoundedNarrowingSaturateScalar(Vector64<int> value, byte count)
Vector64<int> ShiftRightLogicalRoundedNarrowingSaturateScalar(Vector64<long> value, byte count)
Vector64<sbyte> ShiftRightLogicalRoundedNarrowingSaturateScalar(Vector64<short> value, byte count)
Vector64<ushort> ShiftRightLogicalRoundedNarrowingSaturateScalar(Vector64<uint> value, byte count)
Vector64<uint> ShiftRightLogicalRoundedNarrowingSaturateScalar(Vector64<ulong> value, byte count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.shiftrightlogicalroundednarrowingsaturatescalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftRightLogicalRoundedNarrowingSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[UInt16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M29009_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M29009_IG02:
            ldr     d0, [fp,#24]
            uxtb    w0, w0
            bl      Arm64:ShiftRightLogicalRoundedNarrowingSaturateScalar(System.Runtime.Intrinsics.Vector64`1[UInt16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
						;; bbWeight=1    PerfScore 3.50
G_M29009_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=61a88eae) for method AdvSimdMethods:ShiftRightLogicalRoundedNarrowingSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[UInt16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 49. Sqrt

`Vector64<float> Sqrt(Vector64<float> value)`

Performs 'Sqrt' operation.

```csharp
private Vector64<float> SqrtTest(Vector64<float> value)
{
  return AdvSimd.Arm64.Sqrt(value);
}
// value = <11.5, 12.5>
// Result = <3.391165, 3.535534>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> Sqrt(Vector128<double> value)
Vector128<float> Sqrt(Vector128<float> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.sqrt?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:SqrtTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M40773_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M40773_IG02:
            ldr     d16, [fp,#24]
            fsqrt   v16.2s, v16.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 12.50
G_M40773_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 20.20, (MethodHash=0ed260ba) for method AdvSimdMethods:SqrtTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================

; Assembly listing for method AdvSimdMethods:StorePairTest(long,System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte])
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00,T00] (  3,  3   )    long  ->   x0        
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M5284_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M5284_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            stp     d16, d17, [x0]
						;; bbWeight=1    PerfScore 5.00
G_M5284_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 36, prolog size 8, PerfScore 14.10, (MethodHash=59e5eb5b) for method AdvSimdMethods:StorePairTest(long,System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte])
; ============================================================


```
------------------------------------------------

### 50. StorePair

`void StorePair(byte* address, Vector64<byte> value1, Vector64<byte> value2)`

Performs 'StorePair' operation.

```csharp
private void StorePairTest(byte* address, Vector64<byte> value1, Vector64<byte> value2)
{
  AdvSimd.Arm64.StorePair(address, value1, value2);
}
// address = <address>
// value1 = <11, 12, 13, 14, 15, 16, 17, 18>
// value2 = <21, 22, 23, 24, 25, 26, 27, 28>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
void StorePair(double* address, Vector64<double> value1, Vector64<double> value2)
void StorePair(short* address, Vector64<short> value1, Vector64<short> value2)
void StorePair(int* address, Vector64<int> value1, Vector64<int> value2)
void StorePair(long* address, Vector64<long> value1, Vector64<long> value2)
void StorePair(sbyte* address, Vector64<sbyte> value1, Vector64<sbyte> value2)
void StorePair(float* address, Vector64<float> value1, Vector64<float> value2)
void StorePair(ushort* address, Vector64<ushort> value1, Vector64<ushort> value2)
void StorePair(uint* address, Vector64<uint> value1, Vector64<uint> value2)
void StorePair(ulong* address, Vector64<ulong> value1, Vector64<ulong> value2)
void StorePair(byte* address, Vector128<byte> value1, Vector128<byte> value2)
void StorePair(double* address, Vector128<double> value1, Vector128<double> value2)
void StorePair(short* address, Vector128<short> value1, Vector128<short> value2)
void StorePair(int* address, Vector128<int> value1, Vector128<int> value2)
void StorePair(long* address, Vector128<long> value1, Vector128<long> value2)
void StorePair(sbyte* address, Vector128<sbyte> value1, Vector128<sbyte> value2)
void StorePair(float* address, Vector128<float> value1, Vector128<float> value2)
void StorePair(ushort* address, Vector128<ushort> value1, Vector128<ushort> value2)
void StorePair(uint* address, Vector128<uint> value1, Vector128<uint> value2)
void StorePair(ulong* address, Vector128<ulong> value1, Vector128<ulong> value2)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.storepair?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:StorePairNonTemporalTest(long,System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte])
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00,T00] (  3,  3   )    long  ->   x0        
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M18903_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M18903_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            stnp    d16, d17, [x0]
						;; bbWeight=1    PerfScore 5.00
G_M18903_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 36, prolog size 8, PerfScore 14.10, (MethodHash=5233b628) for method AdvSimdMethods:StorePairNonTemporalTest(long,System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte])
; ============================================================


```
------------------------------------------------

### 51. StorePairNonTemporal

`void StorePairNonTemporal(byte* address, Vector64<byte> value1, Vector64<byte> value2)`

Performs 'StorePairNonTemporal' operation.

```csharp
private void StorePairNonTemporalTest(byte* address, Vector64<byte> value1, Vector64<byte> value2)
{
  AdvSimd.Arm64.StorePairNonTemporal(address, value1, value2);
}
// address = <address>
// value1 = <11, 12, 13, 14, 15, 16, 17, 18>
// value2 = <21, 22, 23, 24, 25, 26, 27, 28>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
void StorePairNonTemporal(double* address, Vector64<double> value1, Vector64<double> value2)
void StorePairNonTemporal(short* address, Vector64<short> value1, Vector64<short> value2)
void StorePairNonTemporal(int* address, Vector64<int> value1, Vector64<int> value2)
void StorePairNonTemporal(long* address, Vector64<long> value1, Vector64<long> value2)
void StorePairNonTemporal(sbyte* address, Vector64<sbyte> value1, Vector64<sbyte> value2)
void StorePairNonTemporal(float* address, Vector64<float> value1, Vector64<float> value2)
void StorePairNonTemporal(ushort* address, Vector64<ushort> value1, Vector64<ushort> value2)
void StorePairNonTemporal(uint* address, Vector64<uint> value1, Vector64<uint> value2)
void StorePairNonTemporal(ulong* address, Vector64<ulong> value1, Vector64<ulong> value2)
void StorePairNonTemporal(byte* address, Vector128<byte> value1, Vector128<byte> value2)
void StorePairNonTemporal(double* address, Vector128<double> value1, Vector128<double> value2)
void StorePairNonTemporal(short* address, Vector128<short> value1, Vector128<short> value2)
void StorePairNonTemporal(int* address, Vector128<int> value1, Vector128<int> value2)
void StorePairNonTemporal(long* address, Vector128<long> value1, Vector128<long> value2)
void StorePairNonTemporal(sbyte* address, Vector128<sbyte> value1, Vector128<sbyte> value2)
void StorePairNonTemporal(float* address, Vector128<float> value1, Vector128<float> value2)
void StorePairNonTemporal(ushort* address, Vector128<ushort> value1, Vector128<ushort> value2)
void StorePairNonTemporal(uint* address, Vector128<uint> value1, Vector128<uint> value2)
void StorePairNonTemporal(ulong* address, Vector128<ulong> value1, Vector128<ulong> value2)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.storepairnontemporal?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:StorePairScalarTest(long,System.Runtime.Intrinsics.Vector64`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int32])
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00,T00] (  3,  3   )    long  ->   x0        
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M6474_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M6474_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            stp     s16, s17, [x0]
						;; bbWeight=1    PerfScore 5.00
G_M6474_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 36, prolog size 8, PerfScore 14.10, (MethodHash=2812e6b5) for method AdvSimdMethods:StorePairScalarTest(long,System.Runtime.Intrinsics.Vector64`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int32])
; ============================================================


```
------------------------------------------------

### 52. StorePairScalar

`void StorePairScalar(int* address, Vector64<int> value1, Vector64<int> value2)`

Performs 'StorePairScalar' operation.

```csharp
private void StorePairScalarTest(int* address, Vector64<int> value1, Vector64<int> value2)
{
  AdvSimd.Arm64.StorePairScalar(address, value1, value2);
}
// address = <address>
// value1 = <11, 12>
// value2 = <21, 22>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
void StorePairScalar(float* address, Vector64<float> value1, Vector64<float> value2)
void StorePairScalar(uint* address, Vector64<uint> value1, Vector64<uint> value2)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.storepairscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:StorePairScalarNonTemporalTest(long,System.Runtime.Intrinsics.Vector64`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int32])
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00,T00] (  3,  3   )    long  ->   x0        
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M1721_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M1721_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            stnp    s16, s17, [x0]
						;; bbWeight=1    PerfScore 5.00
G_M1721_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 36, prolog size 8, PerfScore 14.10, (MethodHash=6f1ef946) for method AdvSimdMethods:StorePairScalarNonTemporalTest(long,System.Runtime.Intrinsics.Vector64`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int32])
; ============================================================


```
------------------------------------------------

### 53. StorePairScalarNonTemporal

`void StorePairScalarNonTemporal(int* address, Vector64<int> value1, Vector64<int> value2)`

Performs 'StorePairScalarNonTemporal' operation.

```csharp
private void StorePairScalarNonTemporalTest(int* address, Vector64<int> value1, Vector64<int> value2)
{
  AdvSimd.Arm64.StorePairScalarNonTemporal(address, value1, value2);
}
// address = <address>
// value1 = <11, 12>
// value2 = <21, 22>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
void StorePairScalarNonTemporal(float* address, Vector64<float> value1, Vector64<float> value2)
void StorePairScalarNonTemporal(uint* address, Vector64<uint> value1, Vector64<uint> value2)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.storepairscalarnontemporal?view=net-5.0).

Assembly generated:

```



```
------------------------------------------------

### 54. ReverseElementBits

`Vector64<byte> ReverseElementBits(Vector64<byte> value)`

Performs 'ReverseElementBits' operation.

```csharp
private Vector64<byte> ReverseElementBitsTest(Vector64<byte> value)
{
  return AdvSimd.Arm64.ReverseElementBits(value);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// Result = <208, 48, 176, 112, 240, 8, 136, 72>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<sbyte> ReverseElementBits(Vector64<sbyte> value)
Vector128<byte> ReverseElementBits(Vector128<byte> value)
Vector128<sbyte> ReverseElementBits(Vector128<sbyte> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.reverseelementbits?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ReverseElementBitsTest(System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M33011_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M33011_IG02:
            ldr     d16, [fp,#24]
            rbit    v16.8b, v16.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 3.50
G_M33011_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=06ea7f0c) for method AdvSimdMethods:ReverseElementBitsTest(System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 55. TransposeEven

`Vector64<byte> TransposeEven(Vector64<byte> left, Vector64<byte> right)`

Performs 'TransposeEven' operation.

```csharp
private Vector64<byte> TransposeEvenTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.Arm64.TransposeEven(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <11, 21, 13, 23, 15, 25, 17, 27>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<short> TransposeEven(Vector64<short> left, Vector64<short> right)
Vector64<int> TransposeEven(Vector64<int> left, Vector64<int> right)
Vector64<sbyte> TransposeEven(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<float> TransposeEven(Vector64<float> left, Vector64<float> right)
Vector64<ushort> TransposeEven(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> TransposeEven(Vector64<uint> left, Vector64<uint> right)
Vector128<byte> TransposeEven(Vector128<byte> left, Vector128<byte> right)
Vector128<double> TransposeEven(Vector128<double> left, Vector128<double> right)
Vector128<short> TransposeEven(Vector128<short> left, Vector128<short> right)
Vector128<int> TransposeEven(Vector128<int> left, Vector128<int> right)
Vector128<long> TransposeEven(Vector128<long> left, Vector128<long> right)
Vector128<sbyte> TransposeEven(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<float> TransposeEven(Vector128<float> left, Vector128<float> right)
Vector128<ushort> TransposeEven(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> TransposeEven(Vector128<uint> left, Vector128<uint> right)
Vector128<ulong> TransposeEven(Vector128<ulong> left, Vector128<ulong> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.transposeeven?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:TransposeEvenTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M3131_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M3131_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            trn1    v16.8b, v16.8b, v17.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M3131_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=8fa7f3c4) for method AdvSimdMethods:TransposeEvenTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 56. TransposeOdd

`Vector64<byte> TransposeOdd(Vector64<byte> left, Vector64<byte> right)`

Performs 'TransposeOdd' operation.

```csharp
private Vector64<byte> TransposeOddTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.Arm64.TransposeOdd(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <12, 22, 14, 24, 16, 26, 18, 28>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<short> TransposeOdd(Vector64<short> left, Vector64<short> right)
Vector64<int> TransposeOdd(Vector64<int> left, Vector64<int> right)
Vector64<sbyte> TransposeOdd(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<float> TransposeOdd(Vector64<float> left, Vector64<float> right)
Vector64<ushort> TransposeOdd(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> TransposeOdd(Vector64<uint> left, Vector64<uint> right)
Vector128<byte> TransposeOdd(Vector128<byte> left, Vector128<byte> right)
Vector128<double> TransposeOdd(Vector128<double> left, Vector128<double> right)
Vector128<short> TransposeOdd(Vector128<short> left, Vector128<short> right)
Vector128<int> TransposeOdd(Vector128<int> left, Vector128<int> right)
Vector128<long> TransposeOdd(Vector128<long> left, Vector128<long> right)
Vector128<sbyte> TransposeOdd(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<float> TransposeOdd(Vector128<float> left, Vector128<float> right)
Vector128<ushort> TransposeOdd(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> TransposeOdd(Vector128<uint> left, Vector128<uint> right)
Vector128<ulong> TransposeOdd(Vector128<ulong> left, Vector128<ulong> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.transposeodd?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:TransposeOddTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M49932_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M49932_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            trn2    v16.8b, v16.8b, v17.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M49932_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=a22e3cf3) for method AdvSimdMethods:TransposeOddTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 57. UnzipEven

`Vector64<byte> UnzipEven(Vector64<byte> left, Vector64<byte> right)`

Performs 'UnzipEven' operation.

```csharp
private Vector64<byte> UnzipEvenTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.Arm64.UnzipEven(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <11, 13, 15, 17, 21, 23, 25, 27>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<short> UnzipEven(Vector64<short> left, Vector64<short> right)
Vector64<int> UnzipEven(Vector64<int> left, Vector64<int> right)
Vector64<sbyte> UnzipEven(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<float> UnzipEven(Vector64<float> left, Vector64<float> right)
Vector64<ushort> UnzipEven(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> UnzipEven(Vector64<uint> left, Vector64<uint> right)
Vector128<byte> UnzipEven(Vector128<byte> left, Vector128<byte> right)
Vector128<double> UnzipEven(Vector128<double> left, Vector128<double> right)
Vector128<short> UnzipEven(Vector128<short> left, Vector128<short> right)
Vector128<int> UnzipEven(Vector128<int> left, Vector128<int> right)
Vector128<long> UnzipEven(Vector128<long> left, Vector128<long> right)
Vector128<sbyte> UnzipEven(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<float> UnzipEven(Vector128<float> left, Vector128<float> right)
Vector128<ushort> UnzipEven(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> UnzipEven(Vector128<uint> left, Vector128<uint> right)
Vector128<ulong> UnzipEven(Vector128<ulong> left, Vector128<ulong> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.unzipeven?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:UnzipEvenTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M51568_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M51568_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            uzp1    v16.8b, v16.8b, v17.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M51568_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=9001368f) for method AdvSimdMethods:UnzipEvenTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 58. UnzipOdd

`Vector64<byte> UnzipOdd(Vector64<byte> left, Vector64<byte> right)`

Performs 'UnzipOdd' operation.

```csharp
private Vector64<byte> UnzipOddTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.Arm64.UnzipOdd(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <12, 14, 16, 18, 22, 24, 26, 28>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<short> UnzipOdd(Vector64<short> left, Vector64<short> right)
Vector64<int> UnzipOdd(Vector64<int> left, Vector64<int> right)
Vector64<sbyte> UnzipOdd(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<float> UnzipOdd(Vector64<float> left, Vector64<float> right)
Vector64<ushort> UnzipOdd(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> UnzipOdd(Vector64<uint> left, Vector64<uint> right)
Vector128<byte> UnzipOdd(Vector128<byte> left, Vector128<byte> right)
Vector128<double> UnzipOdd(Vector128<double> left, Vector128<double> right)
Vector128<short> UnzipOdd(Vector128<short> left, Vector128<short> right)
Vector128<int> UnzipOdd(Vector128<int> left, Vector128<int> right)
Vector128<long> UnzipOdd(Vector128<long> left, Vector128<long> right)
Vector128<sbyte> UnzipOdd(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<float> UnzipOdd(Vector128<float> left, Vector128<float> right)
Vector128<ushort> UnzipOdd(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> UnzipOdd(Vector128<uint> left, Vector128<uint> right)
Vector128<ulong> UnzipOdd(Vector128<ulong> left, Vector128<ulong> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.unzipodd?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:UnzipOddTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M13863_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M13863_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            uzp2    v16.8b, v16.8b, v17.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M13863_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=71fdc9d8) for method AdvSimdMethods:UnzipOddTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 59. ZipHigh

`Vector64<byte> ZipHigh(Vector64<byte> left, Vector64<byte> right)`

Performs 'ZipHigh' operation.

```csharp
private Vector64<byte> ZipHighTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.Arm64.ZipHigh(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <15, 25, 16, 26, 17, 27, 18, 28>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<short> ZipHigh(Vector64<short> left, Vector64<short> right)
Vector64<int> ZipHigh(Vector64<int> left, Vector64<int> right)
Vector64<sbyte> ZipHigh(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<float> ZipHigh(Vector64<float> left, Vector64<float> right)
Vector64<ushort> ZipHigh(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> ZipHigh(Vector64<uint> left, Vector64<uint> right)
Vector128<byte> ZipHigh(Vector128<byte> left, Vector128<byte> right)
Vector128<double> ZipHigh(Vector128<double> left, Vector128<double> right)
Vector128<short> ZipHigh(Vector128<short> left, Vector128<short> right)
Vector128<int> ZipHigh(Vector128<int> left, Vector128<int> right)
Vector128<long> ZipHigh(Vector128<long> left, Vector128<long> right)
Vector128<sbyte> ZipHigh(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<float> ZipHigh(Vector128<float> left, Vector128<float> right)
Vector128<ushort> ZipHigh(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> ZipHigh(Vector128<uint> left, Vector128<uint> right)
Vector128<ulong> ZipHigh(Vector128<ulong> left, Vector128<ulong> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.ziphigh?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ZipHighTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M44509_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M44509_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            zip2    v16.8b, v16.8b, v17.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M44509_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=ba165222) for method AdvSimdMethods:ZipHighTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 60. ZipLow

`Vector64<byte> ZipLow(Vector64<byte> left, Vector64<byte> right)`

Performs 'ZipLow' operation.

```csharp
private Vector64<byte> ZipLowTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.Arm64.ZipLow(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <11, 21, 12, 22, 13, 23, 14, 24>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<short> ZipLow(Vector64<short> left, Vector64<short> right)
Vector64<int> ZipLow(Vector64<int> left, Vector64<int> right)
Vector64<sbyte> ZipLow(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<float> ZipLow(Vector64<float> left, Vector64<float> right)
Vector64<ushort> ZipLow(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> ZipLow(Vector64<uint> left, Vector64<uint> right)
Vector128<byte> ZipLow(Vector128<byte> left, Vector128<byte> right)
Vector128<double> ZipLow(Vector128<double> left, Vector128<double> right)
Vector128<short> ZipLow(Vector128<short> left, Vector128<short> right)
Vector128<int> ZipLow(Vector128<int> left, Vector128<int> right)
Vector128<long> ZipLow(Vector128<long> left, Vector128<long> right)
Vector128<sbyte> ZipLow(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<float> ZipLow(Vector128<float> left, Vector128<float> right)
Vector128<ushort> ZipLow(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> ZipLow(Vector128<uint> left, Vector128<uint> right)
Vector128<ulong> ZipLow(Vector128<ulong> left, Vector128<ulong> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.ziplow?view=net-5.0).

Assembly generated:

```

; Assembly listing for method AdvSimdMethods:ZipLowTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M18919_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M18919_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            zip1    v16.8b, v16.8b, v17.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M18919_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=41beb618) for method AdvSimdMethods:ZipLowTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================

```