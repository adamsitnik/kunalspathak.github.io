---
layout: post
title: Hardware Intrinsics APIs for ARM64 - Part 5
subtitle: With examples
tags: [work, arm64, intrinsics]
---

### Introduction

In my [last post](../2019-01-01-Vectorization-APIs), I describe SIMD datatypes `Vector64<T>` and `Vector128<T>` that operates on 'hardware intrisic' APIs. In this post I will describe the intrinsic APIs for ARM64 and how you can use them to optimize your code if you are writing a .NET API targetting ARM64. This is 3 post series TODO.


### API list

[ShiftArithmeticRoundedSaturateScalar](#1-shiftarithmeticroundedsaturatescalar), [ShiftArithmeticRoundedScalar](#2-shiftarithmeticroundedscalar), [ShiftArithmeticSaturate](#3-shiftarithmeticsaturate), [ShiftArithmeticSaturateScalar](#4-shiftarithmeticsaturatescalar), [ShiftArithmeticScalar](#5-shiftarithmeticscalar), [ShiftLeftAndInsert](#6-shiftleftandinsert), [ShiftLeftAndInsertScalar](#7-shiftleftandinsertscalar), [ShiftLeftLogical](#8-shiftleftlogical), [ShiftLeftLogicalSaturate](#9-shiftleftlogicalsaturate), [ShiftLeftLogicalSaturateScalar](#10-shiftleftlogicalsaturatescalar), [ShiftLeftLogicalSaturateUnsigned](#11-shiftleftlogicalsaturateunsigned), [ShiftLeftLogicalSaturateUnsignedScalar](#12-shiftleftlogicalsaturateunsignedscalar), [ShiftLeftLogicalScalar](#13-shiftleftlogicalscalar), [ShiftLeftLogicalWideningLower](#14-shiftleftlogicalwideninglower), [ShiftLeftLogicalWideningUpper](#15-shiftleftlogicalwideningupper), [ShiftLogical](#16-shiftlogical), [ShiftLogicalRounded](#17-shiftlogicalrounded), [ShiftLogicalRoundedSaturate](#18-shiftlogicalroundedsaturate), [ShiftLogicalRoundedSaturateScalar](#19-shiftlogicalroundedsaturatescalar), [ShiftLogicalRoundedScalar](#20-shiftlogicalroundedscalar), [ShiftLogicalSaturate](#21-shiftlogicalsaturate), [ShiftLogicalSaturateScalar](#22-shiftlogicalsaturatescalar), [ShiftLogicalScalar](#23-shiftlogicalscalar), [ShiftRightAndInsert](#24-shiftrightandinsert), [ShiftRightAndInsertScalar](#25-shiftrightandinsertscalar), [ShiftRightArithmetic](#26-shiftrightarithmetic), [ShiftRightArithmeticAdd](#27-shiftrightarithmeticadd), [ShiftRightArithmeticAddScalar](#28-shiftrightarithmeticaddscalar), [ShiftRightArithmeticNarrowingSaturateLower](#29-shiftrightarithmeticnarrowingsaturatelower), [ShiftRightArithmeticNarrowingSaturateUnsignedLower](#30-shiftrightarithmeticnarrowingsaturateunsignedlower), [ShiftRightArithmeticNarrowingSaturateUnsignedUpper](#31-shiftrightarithmeticnarrowingsaturateunsignedupper), [ShiftRightArithmeticNarrowingSaturateUpper](#32-shiftrightarithmeticnarrowingsaturateupper), [ShiftRightArithmeticRounded](#33-shiftrightarithmeticrounded), [ShiftRightArithmeticRoundedAdd](#34-shiftrightarithmeticroundedadd), [ShiftRightArithmeticRoundedAddScalar](#35-shiftrightarithmeticroundedaddscalar), [ShiftRightArithmeticRoundedNarrowingSaturateLower](#36-shiftrightarithmeticroundednarrowingsaturatelower), [ShiftRightArithmeticRoundedNarrowingSaturateUnsignedLower](#37-shiftrightarithmeticroundednarrowingsaturateunsignedlower), [ShiftRightArithmeticRoundedNarrowingSaturateUnsignedUpper](#38-shiftrightarithmeticroundednarrowingsaturateunsignedupper), [ShiftRightArithmeticRoundedNarrowingSaturateUpper](#39-shiftrightarithmeticroundednarrowingsaturateupper), [ShiftRightArithmeticRoundedScalar](#40-shiftrightarithmeticroundedscalar), [ShiftRightArithmeticScalar](#41-shiftrightarithmeticscalar), [ShiftRightLogical](#42-shiftrightlogical), [ShiftRightLogicalAdd](#43-shiftrightlogicaladd), [ShiftRightLogicalAddScalar](#44-shiftrightlogicaladdscalar), [ShiftRightLogicalNarrowingLower](#45-shiftrightlogicalnarrowinglower),[...](Part5.md)






### 1. ShiftArithmeticRoundedSaturateScalar

`Vector64<long> ShiftArithmeticRoundedSaturateScalar(Vector64<long> value, Vector64<long> count)`

This method takes 0th element in the `value` vector, shifts it by a value from the least significant byte of the corresponding 0th element in the `count` vector, places the results into a vector, and writes the vector to the destination SIMD&FP register. If the shift value is positive, the operation is a left shift. Otherwise, it is a right shift. The results are rounded.

```csharp
private Vector64<long> ShiftArithmeticRoundedSaturateScalarTest(Vector64<long> value, Vector64<long> count)
{
  return AdvSimd.ShiftArithmeticRoundedSaturateScalar(value, count);
}
// value = <11>
// count = <11>
// Result = <22528>

```

Similar APIs that operate on different sizes:

```csharp


// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<short> ShiftArithmeticRoundedSaturateScalar(Vector64<short> value, Vector64<short> count)
Vector64<int> ShiftArithmeticRoundedSaturateScalar(Vector64<int> value, Vector64<int> count)
Vector64<sbyte> ShiftArithmeticRoundedSaturateScalar(Vector64<sbyte> value, Vector64<sbyte> count)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftarithmeticroundedsaturatescalar?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.shiftarithmeticroundedsaturatescalar?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vqrshl_s64).

Assembly generated:

```

; Assembly listing for method AdvSimdMethods:ShiftArithmeticRoundedSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64]):System.Runtime.Intrinsics.Vector64`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
;
;  V00 arg0         [V00,T00] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T01] (  3,  3   )   simd8  ->   d1         HFA(simd8) 
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 0

G_M30407_IG01:
        A9BF7BFD          stp     fp, lr, [sp,#-16]!
        910003FD          mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M30407_IG02:
        5EE15C10          sqrshl  d16, d0, d1
        0EB01E00          mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 1.50
G_M30407_IG03:
        A8C17BFD          ldp     fp, lr, [sp],#16
        D65F03C0          ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 7.40, (MethodHash=4b728938) for method AdvSimdMethods:ShiftArithmeticRoundedSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64]):System.Runtime.Intrinsics.Vector64`1[Int64]
; ============================================================


```
------------------------------------------------

### 2. ShiftArithmeticRoundedScalar

`Vector64<long> ShiftArithmeticRoundedScalar(Vector64<long> value, Vector64<long> count)`

This method takes each signed integer value in the `value` vector, shifts it by a value from the least significant byte of the corresponding element of the `count` vector, places the results in a vector, and returns that vector. If the shift value is positive, the operation is a left shift. If the shift value is negative, it is a rounding right shift.

```csharp
private Vector64<long> ShiftArithmeticRoundedScalarTest(Vector64<long> value, Vector64<long> count)
{
  return AdvSimd.ShiftArithmeticRoundedScalar(value, count);
}
// value = <11>
// count = <11>
// Result = <22528>

```



See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftarithmeticroundedscalar?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vrshl_s64).

Assembly generated:

```

; Assembly listing for method AdvSimdMethods:ShiftArithmeticRoundedScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64]):System.Runtime.Intrinsics.Vector64`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
;
;  V00 arg0         [V00,T00] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T01] (  3,  3   )   simd8  ->   d1         HFA(simd8) 
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 0

G_M33718_IG01:
        A9BF7BFD          stp     fp, lr, [sp,#-16]!
        910003FD          mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M33718_IG02:
        5EE15410          srshl   d16, d0, d1
        0EB01E00          mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 1.50
G_M33718_IG03:
        A8C17BFD          ldp     fp, lr, [sp],#16
        D65F03C0          ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 7.40, (MethodHash=69517c49) for method AdvSimdMethods:ShiftArithmeticRoundedScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64]):System.Runtime.Intrinsics.Vector64`1[Int64]
; ============================================================


```
------------------------------------------------

### 3. ShiftArithmeticSaturate

`Vector64<short> ShiftArithmeticSaturate(Vector64<short> value, Vector64<short> count)`

This method takes each element in the `value` vector, shifts each element by a value from the least significant byte of the corresponding element of the `count` vector, places the results in a vector, and returns that vector. If the shift value is positive, the operation is a left shift. Otherwise, it is a right shift. The results are truncated.

```csharp
private Vector64<short> ShiftArithmeticSaturateTest(Vector64<short> value, Vector64<short> count)
{
  return AdvSimd.ShiftArithmeticSaturate(value, count);
}
// value = <11, 12, 13, 14>
// count = <21, 22, 23, 24>
// Result = <32767, 32767, 32767, 32767>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<int> ShiftArithmeticSaturate(Vector64<int> value, Vector64<int> count)
Vector64<sbyte> ShiftArithmeticSaturate(Vector64<sbyte> value, Vector64<sbyte> count)
Vector128<short> ShiftArithmeticSaturate(Vector128<short> value, Vector128<short> count)
Vector128<int> ShiftArithmeticSaturate(Vector128<int> value, Vector128<int> count)
Vector128<long> ShiftArithmeticSaturate(Vector128<long> value, Vector128<long> count)
Vector128<sbyte> ShiftArithmeticSaturate(Vector128<sbyte> value, Vector128<sbyte> count)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftarithmeticsaturate?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vqshl_s16).

Assembly generated:

```

; Assembly listing for method AdvSimdMethods:ShiftArithmeticSaturateTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
;
;  V00 arg0         [V00,T00] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T01] (  3,  3   )   simd8  ->   d1         HFA(simd8) 
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 0

G_M61071_IG01:
        A9BF7BFD          stp     fp, lr, [sp,#-16]!
        910003FD          mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M61071_IG02:
        0E614C10          sqshl   v16.4h, v0.4h, v1.4h
        0EB01E00          mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 3.50
G_M61071_IG03:
        A8C17BFD          ldp     fp, lr, [sp],#16
        D65F03C0          ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 9.40, (MethodHash=11d11170) for method AdvSimdMethods:ShiftArithmeticSaturateTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 4. ShiftArithmeticSaturateScalar

`Vector64<long> ShiftArithmeticSaturateScalar(Vector64<long> value, Vector64<long> count)`

This method takes each element in the `value` vector, shifts each element by a value from the least significant byte of the corresponding element of the `count` vector, places the results in a vector, and returns that vector. If the shift value is positive, the operation is a left shift. Otherwise, it is a right shift. The results are truncated.

```csharp
private Vector64<long> ShiftArithmeticSaturateScalarTest(Vector64<long> value, Vector64<long> count)
{
  return AdvSimd.ShiftArithmeticSaturateScalar(value, count);
}
// value = <11>
// count = <11>
// Result = <22528>

```

Similar APIs that operate on different sizes:

```csharp


// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<short> ShiftArithmeticSaturateScalar(Vector64<short> value, Vector64<short> count)
Vector64<int> ShiftArithmeticSaturateScalar(Vector64<int> value, Vector64<int> count)
Vector64<sbyte> ShiftArithmeticSaturateScalar(Vector64<sbyte> value, Vector64<sbyte> count)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftarithmeticsaturatescalar?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.shiftarithmeticsaturatescalar?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vqshl_s64).

Assembly generated:

```

; Assembly listing for method AdvSimdMethods:ShiftArithmeticSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64]):System.Runtime.Intrinsics.Vector64`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
;
;  V00 arg0         [V00,T00] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T01] (  3,  3   )   simd8  ->   d1         HFA(simd8) 
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 0

G_M42436_IG01:
        A9BF7BFD          stp     fp, lr, [sp,#-16]!
        910003FD          mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M42436_IG02:
        5EE14C10          sqshl   d16, d0, d1
        0EB01E00          mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 1.50
G_M42436_IG03:
        A8C17BFD          ldp     fp, lr, [sp],#16
        D65F03C0          ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 7.40, (MethodHash=34045a3b) for method AdvSimdMethods:ShiftArithmeticSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64]):System.Runtime.Intrinsics.Vector64`1[Int64]
; ============================================================


```
------------------------------------------------

### 5. ShiftArithmeticScalar

`Vector64<long> ShiftArithmeticScalar(Vector64<long> value, Vector64<long> count)`

This method takes each signed integer value in the `value` vector, shifts each value by a value from the least  significant byte of the corresponding element of the `count` vector, places the results in a vector, and returns that vector. If the shift value is positive, the operation is a left shift. If the shift value is negative, it is a truncating right shift.

```csharp
private Vector64<long> ShiftArithmeticScalarTest(Vector64<long> value, Vector64<long> count)
{
  return AdvSimd.ShiftArithmeticScalar(value, count);
}
// value = <11>
// count = <11>
// Result = <22528>

```



See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftarithmeticscalar?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vshl_s64).

Assembly generated:

```

; Assembly listing for method AdvSimdMethods:ShiftArithmeticScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64]):System.Runtime.Intrinsics.Vector64`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
;
;  V00 arg0         [V00,T00] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T01] (  3,  3   )   simd8  ->   d1         HFA(simd8) 
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 0

G_M18869_IG01:
        A9BF7BFD          stp     fp, lr, [sp,#-16]!
        910003FD          mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M18869_IG02:
        5EE14410          sshl    d16, d0, d1
        0EB01E00          mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 1.50
G_M18869_IG03:
        A8C17BFD          ldp     fp, lr, [sp],#16
        D65F03C0          ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 7.40, (MethodHash=9a96b64a) for method AdvSimdMethods:ShiftArithmeticScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64]):System.Runtime.Intrinsics.Vector64`1[Int64]
; ============================================================


```
------------------------------------------------

### 6. ShiftLeftAndInsert

`Vector64<byte> ShiftLeftAndInsert(Vector64<byte> left, Vector64<byte> right, byte shift)`

 This method reads each vector element in the `right` vector, left shifts each vector element by `shift` value, and inserts the result into the corresponding vector element in the `left` vector such that the new zero bits created by the shift are not inserted but retain their existing value as in `left` vector. Bits shifted out of the left of each vector element in the `right` are lost.

```csharp
private Vector64<byte> ShiftLeftAndInsertTest(Vector64<byte> left, Vector64<byte> right, byte shift)
{
  return AdvSimd.ShiftLeftAndInsert(left, right, shift);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <1, 2, 3, 4, 5, 6, 7, 8>
// shift = 1
// Result = <3, 4, 7, 8, 11, 12, 15, 16>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> ShiftLeftAndInsert(Vector64<short> left, Vector64<short> right, byte shift)
Vector64<int> ShiftLeftAndInsert(Vector64<int> left, Vector64<int> right, byte shift)
Vector64<sbyte> ShiftLeftAndInsert(Vector64<sbyte> left, Vector64<sbyte> right, byte shift)
Vector64<ushort> ShiftLeftAndInsert(Vector64<ushort> left, Vector64<ushort> right, byte shift)
Vector64<uint> ShiftLeftAndInsert(Vector64<uint> left, Vector64<uint> right, byte shift)
Vector128<byte> ShiftLeftAndInsert(Vector128<byte> left, Vector128<byte> right, byte shift)
Vector128<short> ShiftLeftAndInsert(Vector128<short> left, Vector128<short> right, byte shift)
Vector128<int> ShiftLeftAndInsert(Vector128<int> left, Vector128<int> right, byte shift)
Vector128<long> ShiftLeftAndInsert(Vector128<long> left, Vector128<long> right, byte shift)
Vector128<sbyte> ShiftLeftAndInsert(Vector128<sbyte> left, Vector128<sbyte> right, byte shift)
Vector128<ushort> ShiftLeftAndInsert(Vector128<ushort> left, Vector128<ushort> right, byte shift)
Vector128<uint> ShiftLeftAndInsert(Vector128<uint> left, Vector128<uint> right, byte shift)
Vector128<ulong> ShiftLeftAndInsert(Vector128<ulong> left, Vector128<ulong> right, byte shift)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftleftandinsert?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vsli_n_u8).

Assembly generated:

```

; Assembly listing for method AdvSimdMethods:ShiftLeftAndInsertTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
;
;  V00 arg0         [V00,T01] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T02] (  3,  3   )   simd8  ->   d1         HFA(simd8) 
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T03] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T04] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 0

G_M65508_IG01:
        A9BF7BFD          stp     fp, lr, [sp,#-16]!
        910003FD          mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M65508_IG02:
        53001C00          uxtb    w0, w0
        97ED0E83          bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftLeftAndInsert(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
						;; bbWeight=1    PerfScore 1.50
G_M65508_IG03:
        A8C17BFD          ldp     fp, lr, [sp],#16
        D65F03C0          ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 7.40, (MethodHash=5fe0001b) for method AdvSimdMethods:ShiftLeftAndInsertTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 7. ShiftLeftAndInsertScalar

`Vector64<long> ShiftLeftAndInsertScalar(Vector64<long> left, Vector64<long> right, byte shift)`

 This method reads each vector element in the `right` vector, left shifts each vector element by `shift` value, and inserts the result into the corresponding vector element in the `left` vector such that the new zero bits created by the shift are not inserted but retain their existing value as in `left` vector. Bits shifted out of the left of each vector element in the `right` are lost.

```csharp
private Vector64<long> ShiftLeftAndInsertScalarTest(Vector64<long> left, Vector64<long> right, byte shift)
{
  return AdvSimd.ShiftLeftAndInsertScalar(left, right, shift);
}
// left = <50000>
// right = <60000>
// shift = 1
// Result = <120000>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<ulong> ShiftLeftAndInsertScalar(Vector64<ulong> left, Vector64<ulong> right, byte shift)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftleftandinsertscalar?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vslid_n_s64).

Assembly generated:

```

; Assembly listing for method AdvSimdMethods:ShiftLeftAndInsertScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
;
;  V00 arg0         [V00,T01] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T02] (  3,  3   )   simd8  ->   d1         HFA(simd8) 
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T03] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T04] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 0

G_M45713_IG01:
        A9BF7BFD          stp     fp, lr, [sp,#-16]!
        910003FD          mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M45713_IG02:
        53001C00          uxtb    w0, w0
        97ED0E2D          bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftLeftAndInsertScalar(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
						;; bbWeight=1    PerfScore 1.50
G_M45713_IG03:
        A8C17BFD          ldp     fp, lr, [sp],#16
        D65F03C0          ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 7.40, (MethodHash=2e634d6e) for method AdvSimdMethods:ShiftLeftAndInsertScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
; ============================================================


```
------------------------------------------------

### 8. ShiftLeftLogical

`Vector64<byte> ShiftLeftLogical(Vector64<byte> value, byte count)`

This method reads each value from a vector, left shifts each result by `count`, writes the final result to a vector, and writes the vector to the destination SIMD&FP register.

```csharp
private Vector64<byte> ShiftLeftLogicalTest(Vector64<byte> value, byte count)
{
  return AdvSimd.ShiftLeftLogical(value, count);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// count = 1
// Result = <22, 24, 26, 28, 30, 32, 34, 36>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> ShiftLeftLogical(Vector64<short> value, byte count)
Vector64<int> ShiftLeftLogical(Vector64<int> value, byte count)
Vector64<sbyte> ShiftLeftLogical(Vector64<sbyte> value, byte count)
Vector64<ushort> ShiftLeftLogical(Vector64<ushort> value, byte count)
Vector64<uint> ShiftLeftLogical(Vector64<uint> value, byte count)
Vector128<byte> ShiftLeftLogical(Vector128<byte> value, byte count)
Vector128<short> ShiftLeftLogical(Vector128<short> value, byte count)
Vector128<long> ShiftLeftLogical(Vector128<long> value, byte count)
Vector128<sbyte> ShiftLeftLogical(Vector128<sbyte> value, byte count)
Vector128<ushort> ShiftLeftLogical(Vector128<ushort> value, byte count)
Vector128<uint> ShiftLeftLogical(Vector128<uint> value, byte count)
Vector128<ulong> ShiftLeftLogical(Vector128<ulong> value, byte count)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftleftlogical?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vshl_n_u8).

Assembly generated:

```

; Assembly listing for method AdvSimdMethods:ShiftLeftLogicalTest(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
;
;  V00 arg0         [V00,T01] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T02] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 0

G_M1386_IG01:
        A9BF7BFD          stp     fp, lr, [sp,#-16]!
        910003FD          mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M1386_IG02:
        53001C00          uxtb    w0, w0
        97ED0DFF          bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftLeftLogical(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
						;; bbWeight=1    PerfScore 1.50
G_M1386_IG03:
        A8C17BFD          ldp     fp, lr, [sp],#16
        D65F03C0          ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 7.40, (MethodHash=7a1ffa95) for method AdvSimdMethods:ShiftLeftLogicalTest(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 9. ShiftLeftLogicalSaturate

`Vector64<byte> ShiftLeftLogicalSaturate(Vector64<byte> value, byte count)`

This method takes each vector element in the `value` vector, shifts it by `count`, places the results in a vector, and returns that vector. The results are truncated.

```csharp
private Vector64<byte> ShiftLeftLogicalSaturateTest(Vector64<byte> value, byte count)
{
  return AdvSimd.ShiftLeftLogicalSaturate(value, count);
}
// value = <11, 112, 13, 14, 15, 16, 17, 18>
// count = 6
// Result = <64, 255, 255, 255, 255, 255, 255, 255>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> ShiftLeftLogicalSaturate(Vector64<short> value, byte count)
Vector64<int> ShiftLeftLogicalSaturate(Vector64<int> value, byte count)
Vector64<sbyte> ShiftLeftLogicalSaturate(Vector64<sbyte> value, byte count)
Vector64<ushort> ShiftLeftLogicalSaturate(Vector64<ushort> value, byte count)
Vector64<uint> ShiftLeftLogicalSaturate(Vector64<uint> value, byte count)
Vector128<byte> ShiftLeftLogicalSaturate(Vector128<byte> value, byte count)
Vector128<short> ShiftLeftLogicalSaturate(Vector128<short> value, byte count)
Vector128<int> ShiftLeftLogicalSaturate(Vector128<int> value, byte count)
Vector128<long> ShiftLeftLogicalSaturate(Vector128<long> value, byte count)
Vector128<sbyte> ShiftLeftLogicalSaturate(Vector128<sbyte> value, byte count)
Vector128<ushort> ShiftLeftLogicalSaturate(Vector128<ushort> value, byte count)
Vector128<uint> ShiftLeftLogicalSaturate(Vector128<uint> value, byte count)
Vector128<ulong> ShiftLeftLogicalSaturate(Vector128<ulong> value, byte count)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftleftlogicalsaturate?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vqshl_n_u8).

Assembly generated:

```

; Assembly listing for method AdvSimdMethods:ShiftLeftLogicalSaturateTest(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
;
;  V00 arg0         [V00,T01] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T02] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 0

G_M3675_IG01:
        A9BF7BFD          stp     fp, lr, [sp,#-16]!
        910003FD          mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M3675_IG02:
        53001C00          uxtb    w0, w0
        97ED0C8F          bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftLeftLogicalSaturate(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
						;; bbWeight=1    PerfScore 1.50
G_M3675_IG03:
        A8C17BFD          ldp     fp, lr, [sp],#16
        D65F03C0          ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 7.40, (MethodHash=3951f1a4) for method AdvSimdMethods:ShiftLeftLogicalSaturateTest(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 10. ShiftLeftLogicalSaturateScalar

`Vector64<long> ShiftLeftLogicalSaturateScalar(Vector64<long> value, byte count)`

This method takes each vector element in the `value` vector, shifts it by `count`, places the results in a vector, and returns that vector. The results are truncated.

```csharp
private Vector64<long> ShiftLeftLogicalSaturateScalarTest(Vector64<long> value, byte count)
{
  return AdvSimd.ShiftLeftLogicalSaturateScalar(value, count);
}
// value = <11>
// count = 0
// Result = <11>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<ulong> ShiftLeftLogicalSaturateScalar(Vector64<ulong> value, byte count)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<byte> ShiftLeftLogicalSaturateScalar(Vector64<byte> value, byte count)
Vector64<short> ShiftLeftLogicalSaturateScalar(Vector64<short> value, byte count)
Vector64<int> ShiftLeftLogicalSaturateScalar(Vector64<int> value, byte count)
Vector64<sbyte> ShiftLeftLogicalSaturateScalar(Vector64<sbyte> value, byte count)
Vector64<ushort> ShiftLeftLogicalSaturateScalar(Vector64<ushort> value, byte count)
Vector64<uint> ShiftLeftLogicalSaturateScalar(Vector64<uint> value, byte count)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftleftlogicalsaturatescalar?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.shiftleftlogicalsaturatescalar?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vqshl_n_s64).

Assembly generated:

```

; Assembly listing for method AdvSimdMethods:ShiftLeftLogicalSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
;
;  V00 arg0         [V00,T01] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T02] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 0

G_M9941_IG01:
        A9BF7BFD          stp     fp, lr, [sp,#-16]!
        910003FD          mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M9941_IG02:
        53001C00          uxtb    w0, w0
        97ED0C39          bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftLeftLogicalSaturateScalar(System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
						;; bbWeight=1    PerfScore 1.50
G_M9941_IG03:
        A8C17BFD          ldp     fp, lr, [sp],#16
        D65F03C0          ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 7.40, (MethodHash=14a1d92a) for method AdvSimdMethods:ShiftLeftLogicalSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
; ============================================================


```
------------------------------------------------

### 11. ShiftLeftLogicalSaturateUnsigned

`Vector64<ushort> ShiftLeftLogicalSaturateUnsigned(Vector64<short> value, byte count)`

This method reads each signed integer value in the `value` vector, shifts each value by `count`, saturates the shifted result to an unsigned integer value, places the result in a vector, and writes the vector to the destination SIMD&FP register. The results are truncated.

```csharp
private Vector64<ushort> ShiftLeftLogicalSaturateUnsignedTest(Vector64<short> value, byte count)
{
  return AdvSimd.ShiftLeftLogicalSaturateUnsigned(value, count);
}
// value = <11, 12, 13, 14>
// count = 1
// Result = <22, 24, 26, 28>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<uint> ShiftLeftLogicalSaturateUnsigned(Vector64<int> value, byte count)
Vector64<byte> ShiftLeftLogicalSaturateUnsigned(Vector64<sbyte> value, byte count)
Vector128<ushort> ShiftLeftLogicalSaturateUnsigned(Vector128<short> value, byte count)
Vector128<uint> ShiftLeftLogicalSaturateUnsigned(Vector128<int> value, byte count)
Vector128<ulong> ShiftLeftLogicalSaturateUnsigned(Vector128<long> value, byte count)
Vector128<byte> ShiftLeftLogicalSaturateUnsigned(Vector128<sbyte> value, byte count)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftleftlogicalsaturateunsigned?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vqshlu_n_s16).

Assembly generated:

```

; Assembly listing for method AdvSimdMethods:ShiftLeftLogicalSaturateUnsignedTest(System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[UInt16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
;
;  V00 arg0         [V00,T01] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T02] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 0

G_M17511_IG01:
        A9BF7BFD          stp     fp, lr, [sp,#-16]!
        910003FD          mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M17511_IG02:
        53001C00          uxtb    w0, w0
        97ED0BFB          bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftLeftLogicalSaturateUnsigned(System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[UInt16]
						;; bbWeight=1    PerfScore 1.50
G_M17511_IG03:
        A8C17BFD          ldp     fp, lr, [sp],#16
        D65F03C0          ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 7.40, (MethodHash=a77ebb98) for method AdvSimdMethods:ShiftLeftLogicalSaturateUnsignedTest(System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[UInt16]
; ============================================================


```
------------------------------------------------

### 12. ShiftLeftLogicalSaturateUnsignedScalar

`Vector64<ulong> ShiftLeftLogicalSaturateUnsignedScalar(Vector64<long> value, byte count)`

This method reads each signed integer value in the `value` vector, shifts each value by `count`, saturates the shifted result to an unsigned integer value, places the result in a vector, and writes the vector to the destination SIMD&FP register. The results are truncated.

```csharp
private Vector64<ulong> ShiftLeftLogicalSaturateUnsignedScalarTest(Vector64<long> value, byte count)
{
  return AdvSimd.ShiftLeftLogicalSaturateUnsignedScalar(value, count);
}
// value = <11>
// count = 0
// Result = <11>

```

Similar APIs that operate on different sizes:

```csharp


// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<ushort> ShiftLeftLogicalSaturateUnsignedScalar(Vector64<short> value, byte count)
Vector64<uint> ShiftLeftLogicalSaturateUnsignedScalar(Vector64<int> value, byte count)
Vector64<byte> ShiftLeftLogicalSaturateUnsignedScalar(Vector64<sbyte> value, byte count)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftleftlogicalsaturateunsignedscalar?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.shiftleftlogicalsaturateunsignedscalar?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vqshlu_n_s64).

Assembly generated:

```

; Assembly listing for method AdvSimdMethods:ShiftLeftLogicalSaturateUnsignedScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[UInt64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
;
;  V00 arg0         [V00,T01] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T02] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 0

G_M35113_IG01:
        A9BF7BFD          stp     fp, lr, [sp,#-16]!
        910003FD          mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M35113_IG02:
        53001C00          uxtb    w0, w0
        97ED09E5          bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftLeftLogicalSaturateUnsignedScalar(System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[UInt64]
						;; bbWeight=1    PerfScore 1.50
G_M35113_IG03:
        A8C17BFD          ldp     fp, lr, [sp],#16
        D65F03C0          ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 7.40, (MethodHash=4bed76d6) for method AdvSimdMethods:ShiftLeftLogicalSaturateUnsignedScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[UInt64]
; ============================================================


```
------------------------------------------------

### 13. ShiftLeftLogicalScalar

`Vector64<long> ShiftLeftLogicalScalar(Vector64<long> value, byte count)`

This method reads each value from a `value` vector, left shifts each result by `count`, writes the final result to a vector, and writes the vector to the destination SIMD&FP register.

```csharp
private Vector64<long> ShiftLeftLogicalScalarTest(Vector64<long> value, byte count)
{
  return AdvSimd.ShiftLeftLogicalScalar(value, count);
}
// value = <971324>
// count = 1
// Result = <1942648>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<ulong> ShiftLeftLogicalScalar(Vector64<ulong> value, byte count)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftleftlogicalscalar?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vshl_n_s64).

Assembly generated:

```

; Assembly listing for method AdvSimdMethods:ShiftLeftLogicalScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
;
;  V00 arg0         [V00,T01] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T02] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 0

G_M61220_IG01:
        A9BF7BFD          stp     fp, lr, [sp,#-16]!
        910003FD          mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M61220_IG02:
        53001C00          uxtb    w0, w0
        97ED0941          bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftLeftLogicalScalar(System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
						;; bbWeight=1    PerfScore 1.50
G_M61220_IG03:
        A8C17BFD          ldp     fp, lr, [sp],#16
        D65F03C0          ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 7.40, (MethodHash=f0cb10db) for method AdvSimdMethods:ShiftLeftLogicalScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
; ============================================================


```
------------------------------------------------

### 14. ShiftLeftLogicalWideningLower

`Vector128<ushort> ShiftLeftLogicalWideningLower(Vector64<byte> value, byte count)`

This method reads each vector element in the `value` vector, shifts the unsigned integer value left by the specified number of bits in `count`, places the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.

```csharp
private Vector128<ushort> ShiftLeftLogicalWideningLowerTest(Vector64<byte> value, byte count)
{
  return AdvSimd.ShiftLeftLogicalWideningLower(value, count);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// count = 0
// Result = <11, 12, 13, 14, 15, 16, 17, 18>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<int> ShiftLeftLogicalWideningLower(Vector64<short> value, byte count)
Vector128<long> ShiftLeftLogicalWideningLower(Vector64<int> value, byte count)
Vector128<short> ShiftLeftLogicalWideningLower(Vector64<sbyte> value, byte count)
Vector128<uint> ShiftLeftLogicalWideningLower(Vector64<ushort> value, byte count)
Vector128<ulong> ShiftLeftLogicalWideningLower(Vector64<uint> value, byte count)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftleftlogicalwideninglower?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vshll_n_u8).

Assembly generated:

```

; Assembly listing for method AdvSimdMethods:ShiftLeftLogicalWideningLowerTest(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector128`1[UInt16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
;
;  V00 arg0         [V00,T01] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T02] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 0

G_M58250_IG01:
        A9BF7BFD          stp     fp, lr, [sp,#-16]!
        910003FD          mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M58250_IG02:
        53001C00          uxtb    w0, w0
        97ED0913          bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftLeftLogicalWideningLower(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector128`1[UInt16]
						;; bbWeight=1    PerfScore 1.50
G_M58250_IG03:
        A8C17BFD          ldp     fp, lr, [sp],#16
        D65F03C0          ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 7.40, (MethodHash=4eca1c75) for method AdvSimdMethods:ShiftLeftLogicalWideningLowerTest(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector128`1[UInt16]
; ============================================================


```
------------------------------------------------

### 15. ShiftLeftLogicalWideningUpper

`Vector128<ushort> ShiftLeftLogicalWideningUpper(Vector128<byte> value, byte count)`

This method reads each vector element in the upper-half of `value` vector, shifts the unsigned integer value left by the specified number of bits in `count`, places the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.

```csharp
private Vector128<ushort> ShiftLeftLogicalWideningUpperTest(Vector128<byte> value, byte count)
{
  return AdvSimd.ShiftLeftLogicalWideningUpper(value, count);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26>
// count = 1
// Result = <38, 40, 42, 44, 46, 48, 50, 52>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<int> ShiftLeftLogicalWideningUpper(Vector128<short> value, byte count)
Vector128<long> ShiftLeftLogicalWideningUpper(Vector128<int> value, byte count)
Vector128<short> ShiftLeftLogicalWideningUpper(Vector128<sbyte> value, byte count)
Vector128<uint> ShiftLeftLogicalWideningUpper(Vector128<ushort> value, byte count)
Vector128<ulong> ShiftLeftLogicalWideningUpper(Vector128<uint> value, byte count)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftleftlogicalwideningupper?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vshll_high_n_u8).

Assembly generated:

```

; Assembly listing for method AdvSimdMethods:ShiftLeftLogicalWideningUpperTest(System.Runtime.Intrinsics.Vector128`1[Byte],ubyte):System.Runtime.Intrinsics.Vector128`1[UInt16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
;
;  V00 arg0         [V00,T01] (  3,  3   )  simd16  ->   d0         HFA(simd16) 
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T02] (  2,  4   )  simd16  ->   d0         HFA(simd16)  "Inlining Arg"
;
; Lcl frame size = 0

G_M36338_IG01:
        A9BF7BFD          stp     fp, lr, [sp,#-16]!
        910003FD          mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M36338_IG02:
        53001C00          uxtb    w0, w0
        97ED08FD          bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftLeftLogicalWideningUpper(System.Runtime.Intrinsics.Vector128`1[Byte],ubyte):System.Runtime.Intrinsics.Vector128`1[UInt16]
						;; bbWeight=1    PerfScore 1.50
G_M36338_IG03:
        A8C17BFD          ldp     fp, lr, [sp],#16
        D65F03C0          ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 7.40, (MethodHash=fcbf720d) for method AdvSimdMethods:ShiftLeftLogicalWideningUpperTest(System.Runtime.Intrinsics.Vector128`1[Byte],ubyte):System.Runtime.Intrinsics.Vector128`1[UInt16]
; ============================================================


```
------------------------------------------------

### 16. ShiftLogical

`Vector64<byte> ShiftLogical(Vector64<byte> value, Vector64<sbyte> count)`

This method takes each element in the `value` vector , shifts each element by a value from the least significant byte of the corresponding element of the `count` vector, places the results in a vector, and returns that vector. If the shift value is positive, the operation is a left shift. If the shift value is negative, it is a truncating right shift.

```csharp
private Vector64<byte> ShiftLogicalTest(Vector64<byte> value, Vector64<sbyte> count)
{
  return AdvSimd.ShiftLogical(value, count);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// count = <-3, 2, 3, 5, 6, 7, -7, 0>
// Result = <1, 48, 104, 192, 192, 0, 0, 18>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> ShiftLogical(Vector64<short> value, Vector64<short> count)
Vector64<int> ShiftLogical(Vector64<int> value, Vector64<int> count)
Vector64<sbyte> ShiftLogical(Vector64<sbyte> value, Vector64<sbyte> count)
Vector64<ushort> ShiftLogical(Vector64<ushort> value, Vector64<short> count)
Vector64<uint> ShiftLogical(Vector64<uint> value, Vector64<int> count)
Vector128<byte> ShiftLogical(Vector128<byte> value, Vector128<sbyte> count)
Vector128<short> ShiftLogical(Vector128<short> value, Vector128<short> count)
Vector128<int> ShiftLogical(Vector128<int> value, Vector128<int> count)
Vector128<long> ShiftLogical(Vector128<long> value, Vector128<long> count)
Vector128<sbyte> ShiftLogical(Vector128<sbyte> value, Vector128<sbyte> count)
Vector128<ushort> ShiftLogical(Vector128<ushort> value, Vector128<short> count)
Vector128<uint> ShiftLogical(Vector128<uint> value, Vector128<int> count)
Vector128<ulong> ShiftLogical(Vector128<ulong> value, Vector128<long> count)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftlogical?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vshl_u8).

Assembly generated:

```

; Assembly listing for method AdvSimdMethods:ShiftLogicalTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[SByte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
;
;  V00 arg0         [V00,T00] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T01] (  3,  3   )   simd8  ->   d1         HFA(simd8) 
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 0

G_M31328_IG01:
        A9BF7BFD          stp     fp, lr, [sp,#-16]!
        910003FD          mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M31328_IG02:
        2E214410          ushl    v16.8b, v0.8b, v1.8b
        0EB01E00          mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 1.50
G_M31328_IG03:
        A8C17BFD          ldp     fp, lr, [sp],#16
        D65F03C0          ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 7.40, (MethodHash=388f859f) for method AdvSimdMethods:ShiftLogicalTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[SByte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 17. ShiftLogicalRounded

`Vector64<byte> ShiftLogicalRounded(Vector64<byte> value, Vector64<sbyte> count)`

This method takes each element in the `value` vector , shifts each element by a value from the least significant byte of the corresponding element of the `count` vector, places the results in a vector, and returns that vector. If the shift value is positive, the operation is a left shift. If the shift value is negative, it is a rounding right shift.

```csharp
private Vector64<byte> ShiftLogicalRoundedTest(Vector64<byte> value, Vector64<sbyte> count)
{
  return AdvSimd.ShiftLogicalRounded(value, count);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// count = <-3, 2, 3, 5, 6, 7, -7, 0>
// Result = <1, 48, 104, 192, 192, 0, 0, 18>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> ShiftLogicalRounded(Vector64<short> value, Vector64<short> count)
Vector64<int> ShiftLogicalRounded(Vector64<int> value, Vector64<int> count)
Vector64<sbyte> ShiftLogicalRounded(Vector64<sbyte> value, Vector64<sbyte> count)
Vector64<ushort> ShiftLogicalRounded(Vector64<ushort> value, Vector64<short> count)
Vector64<uint> ShiftLogicalRounded(Vector64<uint> value, Vector64<int> count)
Vector128<byte> ShiftLogicalRounded(Vector128<byte> value, Vector128<sbyte> count)
Vector128<short> ShiftLogicalRounded(Vector128<short> value, Vector128<short> count)
Vector128<int> ShiftLogicalRounded(Vector128<int> value, Vector128<int> count)
Vector128<long> ShiftLogicalRounded(Vector128<long> value, Vector128<long> count)
Vector128<sbyte> ShiftLogicalRounded(Vector128<sbyte> value, Vector128<sbyte> count)
Vector128<ushort> ShiftLogicalRounded(Vector128<ushort> value, Vector128<short> count)
Vector128<uint> ShiftLogicalRounded(Vector128<uint> value, Vector128<int> count)
Vector128<ulong> ShiftLogicalRounded(Vector128<ulong> value, Vector128<long> count)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftlogicalrounded?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vrshl_u8).

Assembly generated:

```

; Assembly listing for method AdvSimdMethods:ShiftLogicalRoundedTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[SByte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
;
;  V00 arg0         [V00,T00] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T01] (  3,  3   )   simd8  ->   d1         HFA(simd8) 
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 0

G_M16387_IG01:
        A9BF7BFD          stp     fp, lr, [sp,#-16]!
        910003FD          mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M16387_IG02:
        2E215410          urshl   v16.8b, v0.8b, v1.8b
        0EB01E00          mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 1.50
G_M16387_IG03:
        A8C17BFD          ldp     fp, lr, [sp],#16
        D65F03C0          ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 7.40, (MethodHash=ba44bffc) for method AdvSimdMethods:ShiftLogicalRoundedTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[SByte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 18. ShiftLogicalRoundedSaturate

`Vector64<byte> ShiftLogicalRoundedSaturate(Vector64<byte> value, Vector64<sbyte> count)`

This method takes each vector element of the `value` vector, shifts the vector element by a value from the least significant byte of the corresponding vector element of the `count` vector, places the results into a vector, and writes the vector to the destination SIMD&FP register. If the shift value is positive, the operation is a left shift. Otherwise, it is a right shift. The results are rounded. If overflow occurs with any of the results, those results are saturated.

```csharp
private Vector64<byte> ShiftLogicalRoundedSaturateTest(Vector64<byte> value, Vector64<sbyte> count)
{
  return AdvSimd.ShiftLogicalRoundedSaturate(value, count);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// count = <11, 12, 13, 14, 15, 16, 17, 18>
// Result = <255, 255, 255, 255, 255, 255, 255, 255>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> ShiftLogicalRoundedSaturate(Vector64<short> value, Vector64<short> count)
Vector64<int> ShiftLogicalRoundedSaturate(Vector64<int> value, Vector64<int> count)
Vector64<sbyte> ShiftLogicalRoundedSaturate(Vector64<sbyte> value, Vector64<sbyte> count)
Vector64<ushort> ShiftLogicalRoundedSaturate(Vector64<ushort> value, Vector64<short> count)
Vector64<uint> ShiftLogicalRoundedSaturate(Vector64<uint> value, Vector64<int> count)
Vector128<byte> ShiftLogicalRoundedSaturate(Vector128<byte> value, Vector128<sbyte> count)
Vector128<short> ShiftLogicalRoundedSaturate(Vector128<short> value, Vector128<short> count)
Vector128<int> ShiftLogicalRoundedSaturate(Vector128<int> value, Vector128<int> count)
Vector128<long> ShiftLogicalRoundedSaturate(Vector128<long> value, Vector128<long> count)
Vector128<sbyte> ShiftLogicalRoundedSaturate(Vector128<sbyte> value, Vector128<sbyte> count)
Vector128<ushort> ShiftLogicalRoundedSaturate(Vector128<ushort> value, Vector128<short> count)
Vector128<uint> ShiftLogicalRoundedSaturate(Vector128<uint> value, Vector128<int> count)
Vector128<ulong> ShiftLogicalRoundedSaturate(Vector128<ulong> value, Vector128<long> count)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftlogicalroundedsaturate?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vqrshl_u8).

Assembly generated:

```

; Assembly listing for method AdvSimdMethods:ShiftLogicalRoundedSaturateTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[SByte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
;
;  V00 arg0         [V00,T00] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T01] (  3,  3   )   simd8  ->   d1         HFA(simd8) 
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 0

G_M16754_IG01:
        A9BF7BFD          stp     fp, lr, [sp,#-16]!
        910003FD          mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M16754_IG02:
        2E215C10          uqrshl  v16.8b, v0.8b, v1.8b
        0EB01E00          mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 3.50
G_M16754_IG03:
        A8C17BFD          ldp     fp, lr, [sp],#16
        D65F03C0          ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 9.40, (MethodHash=a55cbe8d) for method AdvSimdMethods:ShiftLogicalRoundedSaturateTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[SByte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 19. ShiftLogicalRoundedSaturateScalar

`Vector64<long> ShiftLogicalRoundedSaturateScalar(Vector64<long> value, Vector64<long> count)`

This method takes each vector element of the `value` vector, shifts the vector element by a value from the least significant byte of the corresponding vector element of the `count` vector, places the results into a vector, and writes the vector to the destination SIMD&FP register. If the shift value is positive, the operation is a left shift. Otherwise, it is a right shift. The results are rounded. If overflow occurs with any of the results, those results are saturated.

```csharp
private Vector64<long> ShiftLogicalRoundedSaturateScalarTest(Vector64<long> value, Vector64<long> count)
{
  return AdvSimd.ShiftLogicalRoundedSaturateScalar(value, count);
}
// value = <11>
// count = <11>
// Result = <22528>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<ulong> ShiftLogicalRoundedSaturateScalar(Vector64<ulong> value, Vector64<long> count)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<byte> ShiftLogicalRoundedSaturateScalar(Vector64<byte> value, Vector64<sbyte> count)
Vector64<short> ShiftLogicalRoundedSaturateScalar(Vector64<short> value, Vector64<short> count)
Vector64<int> ShiftLogicalRoundedSaturateScalar(Vector64<int> value, Vector64<int> count)
Vector64<sbyte> ShiftLogicalRoundedSaturateScalar(Vector64<sbyte> value, Vector64<sbyte> count)
Vector64<ushort> ShiftLogicalRoundedSaturateScalar(Vector64<ushort> value, Vector64<short> count)
Vector64<uint> ShiftLogicalRoundedSaturateScalar(Vector64<uint> value, Vector64<int> count)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftlogicalroundedsaturatescalar?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.shiftlogicalroundedsaturatescalar?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vqrshl_u64).

Assembly generated:

```

; Assembly listing for method AdvSimdMethods:ShiftLogicalRoundedSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64]):System.Runtime.Intrinsics.Vector64`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
;
;  V00 arg0         [V00,T00] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T01] (  3,  3   )   simd8  ->   d1         HFA(simd8) 
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 0

G_M17268_IG01:
        A9BF7BFD          stp     fp, lr, [sp,#-16]!
        910003FD          mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M17268_IG02:
        7EE15C10          uqrshl  d16, d0, d1
        0EB01E00          mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 1.50
G_M17268_IG03:
        A8C17BFD          ldp     fp, lr, [sp],#16
        D65F03C0          ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 7.40, (MethodHash=d5f7bc8b) for method AdvSimdMethods:ShiftLogicalRoundedSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64]):System.Runtime.Intrinsics.Vector64`1[Int64]
; ============================================================


```
------------------------------------------------

### 20. ShiftLogicalRoundedScalar

`Vector64<long> ShiftLogicalRoundedScalar(Vector64<long> value, Vector64<long> count)`

This method takes each element in the `value` vector, shifts the vector element by a value from the least significant byte of the corresponding element of the `count` vector, places the results in a vector, and returns that vector. If the shift value is positive, the operation is a left shift. If the shift value is negative, it is a rounding right shift.

```csharp
private Vector64<long> ShiftLogicalRoundedScalarTest(Vector64<long> value, Vector64<long> count)
{
  return AdvSimd.ShiftLogicalRoundedScalar(value, count);
}
// value = <11>
// count = <11>
// Result = <22528>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<ulong> ShiftLogicalRoundedScalar(Vector64<ulong> value, Vector64<long> count)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftlogicalroundedscalar?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vrshl_u64).

Assembly generated:

```

; Assembly listing for method AdvSimdMethods:ShiftLogicalRoundedScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64]):System.Runtime.Intrinsics.Vector64`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
;
;  V00 arg0         [V00,T00] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T01] (  3,  3   )   simd8  ->   d1         HFA(simd8) 
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 0

G_M12677_IG01:
        A9BF7BFD          stp     fp, lr, [sp,#-16]!
        910003FD          mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M12677_IG02:
        7EE15410          urshl   d16, d0, d1
        0EB01E00          mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 1.50
G_M12677_IG03:
        A8C17BFD          ldp     fp, lr, [sp],#16
        D65F03C0          ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 7.40, (MethodHash=c599ce7a) for method AdvSimdMethods:ShiftLogicalRoundedScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64]):System.Runtime.Intrinsics.Vector64`1[Int64]
; ============================================================


```
------------------------------------------------

### 21. ShiftLogicalSaturate

`Vector64<byte> ShiftLogicalSaturate(Vector64<byte> value, Vector64<sbyte> count)`

Performs 'ShiftLogicalSaturate' operation

```csharp
private Vector64<byte> ShiftLogicalSaturateTest(Vector64<byte> value, Vector64<sbyte> count)
{
  return AdvSimd.ShiftLogicalSaturate(value, count);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// count = <11, 12, 13, 14, 15, 16, 17, 18>
// Result = <255, 255, 255, 255, 255, 255, 255, 255>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> ShiftLogicalSaturate(Vector64<short> value, Vector64<short> count)
Vector64<int> ShiftLogicalSaturate(Vector64<int> value, Vector64<int> count)
Vector64<sbyte> ShiftLogicalSaturate(Vector64<sbyte> value, Vector64<sbyte> count)
Vector64<ushort> ShiftLogicalSaturate(Vector64<ushort> value, Vector64<short> count)
Vector64<uint> ShiftLogicalSaturate(Vector64<uint> value, Vector64<int> count)
Vector128<byte> ShiftLogicalSaturate(Vector128<byte> value, Vector128<sbyte> count)
Vector128<short> ShiftLogicalSaturate(Vector128<short> value, Vector128<short> count)
Vector128<int> ShiftLogicalSaturate(Vector128<int> value, Vector128<int> count)
Vector128<long> ShiftLogicalSaturate(Vector128<long> value, Vector128<long> count)
Vector128<sbyte> ShiftLogicalSaturate(Vector128<sbyte> value, Vector128<sbyte> count)
Vector128<ushort> ShiftLogicalSaturate(Vector128<ushort> value, Vector128<short> count)
Vector128<uint> ShiftLogicalSaturate(Vector128<uint> value, Vector128<int> count)
Vector128<ulong> ShiftLogicalSaturate(Vector128<ulong> value, Vector128<long> count)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftlogicalsaturate?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vqshl_u8).

Assembly generated:

```

; Assembly listing for method AdvSimdMethods:ShiftLogicalSaturateTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[SByte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
;
;  V00 arg0         [V00,T00] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T01] (  3,  3   )   simd8  ->   d1         HFA(simd8) 
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 0

G_M7441_IG01:
        A9BF7BFD          stp     fp, lr, [sp,#-16]!
        910003FD          mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M7441_IG02:
        2E214C10          uqshl   v16.8b, v0.8b, v1.8b
        0EB01E00          mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 3.50
G_M7441_IG03:
        A8C17BFD          ldp     fp, lr, [sp],#16
        D65F03C0          ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 9.40, (MethodHash=475fe2ee) for method AdvSimdMethods:ShiftLogicalSaturateTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[SByte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 22. ShiftLogicalSaturateScalar

`Vector64<long> ShiftLogicalSaturateScalar(Vector64<long> value, Vector64<long> count)`

Performs 'ShiftLogicalSaturateScalar' operation

```csharp
private Vector64<long> ShiftLogicalSaturateScalarTest(Vector64<long> value, Vector64<long> count)
{
  return AdvSimd.ShiftLogicalSaturateScalar(value, count);
}
// value = <11>
// count = <11>
// Result = <22528>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<ulong> ShiftLogicalSaturateScalar(Vector64<ulong> value, Vector64<long> count)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<byte> ShiftLogicalSaturateScalar(Vector64<byte> value, Vector64<sbyte> count)
Vector64<short> ShiftLogicalSaturateScalar(Vector64<short> value, Vector64<short> count)
Vector64<int> ShiftLogicalSaturateScalar(Vector64<int> value, Vector64<int> count)
Vector64<sbyte> ShiftLogicalSaturateScalar(Vector64<sbyte> value, Vector64<sbyte> count)
Vector64<ushort> ShiftLogicalSaturateScalar(Vector64<ushort> value, Vector64<short> count)
Vector64<uint> ShiftLogicalSaturateScalar(Vector64<uint> value, Vector64<int> count)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftlogicalsaturatescalar?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.shiftlogicalsaturatescalar?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vqshl_u64).

Assembly generated:

```

; Assembly listing for method AdvSimdMethods:ShiftLogicalSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64]):System.Runtime.Intrinsics.Vector64`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
;
;  V00 arg0         [V00,T00] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T01] (  3,  3   )   simd8  ->   d1         HFA(simd8) 
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 0

G_M40855_IG01:
        A9BF7BFD          stp     fp, lr, [sp,#-16]!
        910003FD          mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M40855_IG02:
        7EE14C10          uqshl   d16, d0, d1
        0EB01E00          mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 1.50
G_M40855_IG03:
        A8C17BFD          ldp     fp, lr, [sp],#16
        D65F03C0          ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 7.40, (MethodHash=e7ec6068) for method AdvSimdMethods:ShiftLogicalSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64]):System.Runtime.Intrinsics.Vector64`1[Int64]
; ============================================================


```
------------------------------------------------

### 23. ShiftLogicalScalar

`Vector64<long> ShiftLogicalScalar(Vector64<long> value, Vector64<long> count)`

Performs 'ShiftLogicalScalar' operation

```csharp
private Vector64<long> ShiftLogicalScalarTest(Vector64<long> value, Vector64<long> count)
{
  return AdvSimd.ShiftLogicalScalar(value, count);
}
// value = <11>
// count = <11>
// Result = <22528>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<ulong> ShiftLogicalScalar(Vector64<ulong> value, Vector64<long> count)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftlogicalscalar?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vshl_u64).

Assembly generated:

```

; Assembly listing for method AdvSimdMethods:ShiftLogicalScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64]):System.Runtime.Intrinsics.Vector64`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
;
;  V00 arg0         [V00,T00] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T01] (  3,  3   )   simd8  ->   d1         HFA(simd8) 
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 0

G_M46694_IG01:
        A9BF7BFD          stp     fp, lr, [sp,#-16]!
        910003FD          mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M46694_IG02:
        7EE14410          ushl    d16, d0, d1
        0EB01E00          mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 1.50
G_M46694_IG03:
        A8C17BFD          ldp     fp, lr, [sp],#16
        D65F03C0          ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 7.40, (MethodHash=1ce74999) for method AdvSimdMethods:ShiftLogicalScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64]):System.Runtime.Intrinsics.Vector64`1[Int64]
; ============================================================


```
------------------------------------------------

### 24. ShiftRightAndInsert

`Vector64<byte> ShiftRightAndInsert(Vector64<byte> left, Vector64<byte> right, byte shift)`

Performs 'ShiftRightAndInsert' operation

```csharp
private Vector64<byte> ShiftRightAndInsertTest(Vector64<byte> left, Vector64<byte> right, byte shift)
{
  return AdvSimd.ShiftRightAndInsert(left, right, shift);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// shift = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> ShiftRightAndInsert(Vector64<short> left, Vector64<short> right, byte shift)
Vector64<int> ShiftRightAndInsert(Vector64<int> left, Vector64<int> right, byte shift)
Vector64<sbyte> ShiftRightAndInsert(Vector64<sbyte> left, Vector64<sbyte> right, byte shift)
Vector64<ushort> ShiftRightAndInsert(Vector64<ushort> left, Vector64<ushort> right, byte shift)
Vector64<uint> ShiftRightAndInsert(Vector64<uint> left, Vector64<uint> right, byte shift)
Vector128<byte> ShiftRightAndInsert(Vector128<byte> left, Vector128<byte> right, byte shift)
Vector128<short> ShiftRightAndInsert(Vector128<short> left, Vector128<short> right, byte shift)
Vector128<int> ShiftRightAndInsert(Vector128<int> left, Vector128<int> right, byte shift)
Vector128<long> ShiftRightAndInsert(Vector128<long> left, Vector128<long> right, byte shift)
Vector128<sbyte> ShiftRightAndInsert(Vector128<sbyte> left, Vector128<sbyte> right, byte shift)
Vector128<ushort> ShiftRightAndInsert(Vector128<ushort> left, Vector128<ushort> right, byte shift)
Vector128<uint> ShiftRightAndInsert(Vector128<uint> left, Vector128<uint> right, byte shift)
Vector128<ulong> ShiftRightAndInsert(Vector128<ulong> left, Vector128<ulong> right, byte shift)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightandinsert?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vsri_n_u8).

Assembly generated:

```

; Assembly listing for method AdvSimdMethods:ShiftRightAndInsertTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
;
;  V00 arg0         [V00,T01] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T02] (  3,  3   )   simd8  ->   d1         HFA(simd8) 
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T03] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T04] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 0

G_M53631_IG01:
        A9BF7BFD          stp     fp, lr, [sp,#-16]!
        910003FD          mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M53631_IG02:
        53001C00          uxtb    w0, w0
        97ECCF0B          bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightAndInsert(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
						;; bbWeight=1    PerfScore 1.50
G_M53631_IG03:
        A8C17BFD          ldp     fp, lr, [sp],#16
        D65F03C0          ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 7.40, (MethodHash=19f42e80) for method AdvSimdMethods:ShiftRightAndInsertTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 25. ShiftRightAndInsertScalar

`Vector64<long> ShiftRightAndInsertScalar(Vector64<long> left, Vector64<long> right, byte shift)`

Performs 'ShiftRightAndInsertScalar' operation

```csharp
private Vector64<long> ShiftRightAndInsertScalarTest(Vector64<long> left, Vector64<long> right, byte shift)
{
  return AdvSimd.ShiftRightAndInsertScalar(left, right, shift);
}
// left = <11>
// right = <11>
// shift = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<ulong> ShiftRightAndInsertScalar(Vector64<ulong> left, Vector64<ulong> right, byte shift)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightandinsertscalar?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vsrid_n_s64).

Assembly generated:

```

; Assembly listing for method AdvSimdMethods:ShiftRightAndInsertScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
;
;  V00 arg0         [V00,T01] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T02] (  3,  3   )   simd8  ->   d1         HFA(simd8) 
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T03] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T04] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 0

G_M29418_IG01:
        A9BF7BFD          stp     fp, lr, [sp,#-16]!
        910003FD          mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M29418_IG02:
        53001C00          uxtb    w0, w0
        97ECCEB3          bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightAndInsertScalar(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
						;; bbWeight=1    PerfScore 1.50
G_M29418_IG03:
        A8C17BFD          ldp     fp, lr, [sp],#16
        D65F03C0          ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 7.40, (MethodHash=f19f8d15) for method AdvSimdMethods:ShiftRightAndInsertScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
; ============================================================


```
------------------------------------------------

### 26. ShiftRightArithmetic

`Vector64<short> ShiftRightArithmetic(Vector64<short> value, byte count)`

Performs 'ShiftRightArithmetic' operation

```csharp
private Vector64<short> ShiftRightArithmeticTest(Vector64<short> value, byte count)
{
  return AdvSimd.ShiftRightArithmetic(value, count);
}
// value = <11, 12, 13, 14>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<int> ShiftRightArithmetic(Vector64<int> value, byte count)
Vector64<sbyte> ShiftRightArithmetic(Vector64<sbyte> value, byte count)
Vector128<short> ShiftRightArithmetic(Vector128<short> value, byte count)
Vector128<int> ShiftRightArithmetic(Vector128<int> value, byte count)
Vector128<long> ShiftRightArithmetic(Vector128<long> value, byte count)
Vector128<sbyte> ShiftRightArithmetic(Vector128<sbyte> value, byte count)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightarithmetic?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vshr_n_s16).

Assembly generated:

```

; Assembly listing for method AdvSimdMethods:ShiftRightArithmeticTest(System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
;
;  V00 arg0         [V00,T01] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T02] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 0

G_M23266_IG01:
        A9BF7BFD          stp     fp, lr, [sp,#-16]!
        910003FD          mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M23266_IG02:
        53001C00          uxtb    w0, w0
        97ECCCEF          bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightArithmetic(System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
						;; bbWeight=1    PerfScore 1.50
G_M23266_IG03:
        A8C17BFD          ldp     fp, lr, [sp],#16
        D65F03C0          ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 7.40, (MethodHash=851aa51d) for method AdvSimdMethods:ShiftRightArithmeticTest(System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 27. ShiftRightArithmeticAdd

`Vector64<short> ShiftRightArithmeticAdd(Vector64<short> addend, Vector64<short> value, byte count)`

Performs 'ShiftRightArithmeticAdd' operation

```csharp
private Vector64<short> ShiftRightArithmeticAddTest(Vector64<short> addend, Vector64<short> value, byte count)
{
  return AdvSimd.ShiftRightArithmeticAdd(addend, value, count);
}
// addend = <11, 12, 13, 14>
// value = <21, 22, 23, 24>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<int> ShiftRightArithmeticAdd(Vector64<int> addend, Vector64<int> value, byte count)
Vector64<sbyte> ShiftRightArithmeticAdd(Vector64<sbyte> addend, Vector64<sbyte> value, byte count)
Vector128<short> ShiftRightArithmeticAdd(Vector128<short> addend, Vector128<short> value, byte count)
Vector128<int> ShiftRightArithmeticAdd(Vector128<int> addend, Vector128<int> value, byte count)
Vector128<long> ShiftRightArithmeticAdd(Vector128<long> addend, Vector128<long> value, byte count)
Vector128<sbyte> ShiftRightArithmeticAdd(Vector128<sbyte> addend, Vector128<sbyte> value, byte count)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightarithmeticadd?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vsra_n_s16).

Assembly generated:

```

; Assembly listing for method AdvSimdMethods:ShiftRightArithmeticAddTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
;
;  V00 arg0         [V00,T01] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T02] (  3,  3   )   simd8  ->   d1         HFA(simd8) 
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T03] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T04] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 0

G_M26636_IG01:
        A9BF7BFD          stp     fp, lr, [sp,#-16]!
        910003FD          mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M26636_IG02:
        53001C00          uxtb    w0, w0
        97ECCCCD          bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightArithmeticAdd(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
						;; bbWeight=1    PerfScore 1.50
G_M26636_IG03:
        A8C17BFD          ldp     fp, lr, [sp],#16
        D65F03C0          ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 7.40, (MethodHash=981d97f3) for method AdvSimdMethods:ShiftRightArithmeticAddTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 28. ShiftRightArithmeticAddScalar

`Vector64<long> ShiftRightArithmeticAddScalar(Vector64<long> addend, Vector64<long> value, byte count)`

Performs 'ShiftRightArithmeticAddScalar' operation

```csharp
private Vector64<long> ShiftRightArithmeticAddScalarTest(Vector64<long> addend, Vector64<long> value, byte count)
{
  return AdvSimd.ShiftRightArithmeticAddScalar(addend, value, count);
}
// addend = <11>
// value = <11>
// count = 0
// Result = TODO

```



See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightarithmeticaddscalar?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vsra_n_s64).

Assembly generated:

```

; Assembly listing for method AdvSimdMethods:ShiftRightArithmeticAddScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
;
;  V00 arg0         [V00,T01] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T02] (  3,  3   )   simd8  ->   d1         HFA(simd8) 
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T03] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T04] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 0

G_M60167_IG01:
        A9BF7BFD          stp     fp, lr, [sp,#-16]!
        910003FD          mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M60167_IG02:
        53001C00          uxtb    w0, w0
        97ECCC4B          bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightArithmeticAddScalar(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
						;; bbWeight=1    PerfScore 1.50
G_M60167_IG03:
        A8C17BFD          ldp     fp, lr, [sp],#16
        D65F03C0          ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 7.40, (MethodHash=532a14f8) for method AdvSimdMethods:ShiftRightArithmeticAddScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
; ============================================================


```
------------------------------------------------

### 29. ShiftRightArithmeticNarrowingSaturateLower

`Vector64<short> ShiftRightArithmeticNarrowingSaturateLower(Vector128<int> value, byte count)`

Performs 'ShiftRightArithmeticNarrowingSaturateLower' operation

```csharp
private Vector64<short> ShiftRightArithmeticNarrowingSaturateLowerTest(Vector128<int> value, byte count)
{
  return AdvSimd.ShiftRightArithmeticNarrowingSaturateLower(value, count);
}
// value = <11, 12, 13, 14>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<int> ShiftRightArithmeticNarrowingSaturateLower(Vector128<long> value, byte count)
Vector64<sbyte> ShiftRightArithmeticNarrowingSaturateLower(Vector128<short> value, byte count)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightarithmeticnarrowingsaturatelower?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vqshrn_n_s32).

Assembly generated:

```

; Assembly listing for method AdvSimdMethods:ShiftRightArithmeticNarrowingSaturateLowerTest(System.Runtime.Intrinsics.Vector128`1[Int32],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
;
;  V00 arg0         [V00,T01] (  3,  3   )  simd16  ->   d0         HFA(simd16) 
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T02] (  2,  4   )  simd16  ->   d0         HFA(simd16)  "Inlining Arg"
;
; Lcl frame size = 0

G_M5432_IG01:
        A9BF7BFD          stp     fp, lr, [sp,#-16]!
        910003FD          mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M5432_IG02:
        53001C00          uxtb    w0, w0
        97ECCC05          bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightArithmeticNarrowingSaturateLower(System.Runtime.Intrinsics.Vector128`1[Int32],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
						;; bbWeight=1    PerfScore 1.50
G_M5432_IG03:
        A8C17BFD          ldp     fp, lr, [sp],#16
        D65F03C0          ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 7.40, (MethodHash=2129eac7) for method AdvSimdMethods:ShiftRightArithmeticNarrowingSaturateLowerTest(System.Runtime.Intrinsics.Vector128`1[Int32],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 30. ShiftRightArithmeticNarrowingSaturateUnsignedLower

`Vector64<byte> ShiftRightArithmeticNarrowingSaturateUnsignedLower(Vector128<short> value, byte count)`

Performs 'ShiftRightArithmeticNarrowingSaturateUnsignedLower' operation

```csharp
private Vector64<byte> ShiftRightArithmeticNarrowingSaturateUnsignedLowerTest(Vector128<short> value, byte count)
{
  return AdvSimd.ShiftRightArithmeticNarrowingSaturateUnsignedLower(value, count);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<ushort> ShiftRightArithmeticNarrowingSaturateUnsignedLower(Vector128<int> value, byte count)
Vector64<uint> ShiftRightArithmeticNarrowingSaturateUnsignedLower(Vector128<long> value, byte count)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightarithmeticnarrowingsaturateunsignedlower?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vqshrun_n_s16).

Assembly generated:

```

; Assembly listing for method AdvSimdMethods:ShiftRightArithmeticNarrowingSaturateUnsignedLowerTest(System.Runtime.Intrinsics.Vector128`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
;
;  V00 arg0         [V00,T01] (  3,  3   )  simd16  ->   d0         HFA(simd16) 
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T02] (  2,  4   )  simd16  ->   d0         HFA(simd16)  "Inlining Arg"
;
; Lcl frame size = 0

G_M27529_IG01:
        A9BF7BFD          stp     fp, lr, [sp,#-16]!
        910003FD          mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M27529_IG02:
        53001C00          uxtb    w0, w0
        97ECCBDB          bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightArithmeticNarrowingSaturateUnsignedLower(System.Runtime.Intrinsics.Vector128`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
						;; bbWeight=1    PerfScore 1.50
G_M27529_IG03:
        A8C17BFD          ldp     fp, lr, [sp],#16
        D65F03C0          ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 7.40, (MethodHash=ce1f9476) for method AdvSimdMethods:ShiftRightArithmeticNarrowingSaturateUnsignedLowerTest(System.Runtime.Intrinsics.Vector128`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 31. ShiftRightArithmeticNarrowingSaturateUnsignedUpper

`Vector128<byte> ShiftRightArithmeticNarrowingSaturateUnsignedUpper(Vector64<byte> lower, Vector128<short> value, byte count)`

Performs 'ShiftRightArithmeticNarrowingSaturateUnsignedUpper' operation

```csharp
private Vector128<byte> ShiftRightArithmeticNarrowingSaturateUnsignedUpperTest(Vector64<byte> lower, Vector128<short> value, byte count)
{
  return AdvSimd.ShiftRightArithmeticNarrowingSaturateUnsignedUpper(lower, value, count);
}
// lower = <11, 12, 13, 14, 15, 16, 17, 18>
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<ushort> ShiftRightArithmeticNarrowingSaturateUnsignedUpper(Vector64<ushort> lower, Vector128<int> value, byte count)
Vector128<uint> ShiftRightArithmeticNarrowingSaturateUnsignedUpper(Vector64<uint> lower, Vector128<long> value, byte count)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightarithmeticnarrowingsaturateunsignedupper?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vqshrun_high_n_s16).

Assembly generated:

```

; Assembly listing for method AdvSimdMethods:ShiftRightArithmeticNarrowingSaturateUnsignedUpperTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
;
;  V00 arg0         [V00,T01] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T02] (  3,  3   )  simd16  ->   d1         HFA(simd16) 
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T03] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T04] (  2,  4   )  simd16  ->   d1         HFA(simd16)  "Inlining Arg"
;
; Lcl frame size = 0

G_M1312_IG01:
        A9BF7BFD          stp     fp, lr, [sp,#-16]!
        910003FD          mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M1312_IG02:
        53001C00          uxtb    w0, w0
        97ECCBB1          bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightArithmeticNarrowingSaturateUnsignedUpper(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Byte]
						;; bbWeight=1    PerfScore 1.50
G_M1312_IG03:
        A8C17BFD          ldp     fp, lr, [sp],#16
        D65F03C0          ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 7.40, (MethodHash=6456fadf) for method AdvSimdMethods:ShiftRightArithmeticNarrowingSaturateUnsignedUpperTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Byte]
; ============================================================


```
------------------------------------------------

### 32. ShiftRightArithmeticNarrowingSaturateUpper

`Vector128<short> ShiftRightArithmeticNarrowingSaturateUpper(Vector64<short> lower, Vector128<int> value, byte count)`

Performs 'ShiftRightArithmeticNarrowingSaturateUpper' operation

```csharp
private Vector128<short> ShiftRightArithmeticNarrowingSaturateUpperTest(Vector64<short> lower, Vector128<int> value, byte count)
{
  return AdvSimd.ShiftRightArithmeticNarrowingSaturateUpper(lower, value, count);
}
// lower = <11, 12, 13, 14>
// value = <11, 12, 13, 14>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<int> ShiftRightArithmeticNarrowingSaturateUpper(Vector64<int> lower, Vector128<long> value, byte count)
Vector128<sbyte> ShiftRightArithmeticNarrowingSaturateUpper(Vector64<sbyte> lower, Vector128<short> value, byte count)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightarithmeticnarrowingsaturateupper?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vqshrn_high_n_s32).

Assembly generated:

```

; Assembly listing for method AdvSimdMethods:ShiftRightArithmeticNarrowingSaturateUpperTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector128`1[Int32],ubyte):System.Runtime.Intrinsics.Vector128`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
;
;  V00 arg0         [V00,T01] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T02] (  3,  3   )  simd16  ->   d1         HFA(simd16) 
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T03] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T04] (  2,  4   )  simd16  ->   d1         HFA(simd16)  "Inlining Arg"
;
; Lcl frame size = 0

G_M46415_IG01:
        A9BF7BFD          stp     fp, lr, [sp,#-16]!
        910003FD          mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M46415_IG02:
        53001C00          uxtb    w0, w0
        97ECCB77          bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightArithmeticNarrowingSaturateUpper(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector128`1[Int32],ubyte):System.Runtime.Intrinsics.Vector128`1[Int16]
						;; bbWeight=1    PerfScore 1.50
G_M46415_IG03:
        A8C17BFD          ldp     fp, lr, [sp],#16
        D65F03C0          ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 7.40, (MethodHash=e8ad4ab0) for method AdvSimdMethods:ShiftRightArithmeticNarrowingSaturateUpperTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector128`1[Int32],ubyte):System.Runtime.Intrinsics.Vector128`1[Int16]
; ============================================================


```
------------------------------------------------

### 33. ShiftRightArithmeticRounded

`Vector64<short> ShiftRightArithmeticRounded(Vector64<short> value, byte count)`

Performs 'ShiftRightArithmeticRounded' operation

```csharp
private Vector64<short> ShiftRightArithmeticRoundedTest(Vector64<short> value, byte count)
{
  return AdvSimd.ShiftRightArithmeticRounded(value, count);
}
// value = <11, 12, 13, 14>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<int> ShiftRightArithmeticRounded(Vector64<int> value, byte count)
Vector64<sbyte> ShiftRightArithmeticRounded(Vector64<sbyte> value, byte count)
Vector128<short> ShiftRightArithmeticRounded(Vector128<short> value, byte count)
Vector128<int> ShiftRightArithmeticRounded(Vector128<int> value, byte count)
Vector128<long> ShiftRightArithmeticRounded(Vector128<long> value, byte count)
Vector128<sbyte> ShiftRightArithmeticRounded(Vector128<sbyte> value, byte count)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightarithmeticrounded?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vrshr_n_s16).

Assembly generated:

```

; Assembly listing for method AdvSimdMethods:ShiftRightArithmeticRoundedTest(System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
;
;  V00 arg0         [V00,T01] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T02] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 0

G_M4321_IG01:
        A9BF7BFD          stp     fp, lr, [sp,#-16]!
        910003FD          mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M4321_IG02:
        53001C00          uxtb    w0, w0
        97ECCB3D          bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightArithmeticRounded(System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
						;; bbWeight=1    PerfScore 1.50
G_M4321_IG03:
        A8C17BFD          ldp     fp, lr, [sp],#16
        D65F03C0          ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 7.40, (MethodHash=15beef1e) for method AdvSimdMethods:ShiftRightArithmeticRoundedTest(System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 34. ShiftRightArithmeticRoundedAdd

`Vector64<short> ShiftRightArithmeticRoundedAdd(Vector64<short> addend, Vector64<short> value, byte count)`

Performs 'ShiftRightArithmeticRoundedAdd' operation

```csharp
private Vector64<short> ShiftRightArithmeticRoundedAddTest(Vector64<short> addend, Vector64<short> value, byte count)
{
  return AdvSimd.ShiftRightArithmeticRoundedAdd(addend, value, count);
}
// addend = <11, 12, 13, 14>
// value = <21, 22, 23, 24>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<int> ShiftRightArithmeticRoundedAdd(Vector64<int> addend, Vector64<int> value, byte count)
Vector64<sbyte> ShiftRightArithmeticRoundedAdd(Vector64<sbyte> addend, Vector64<sbyte> value, byte count)
Vector128<short> ShiftRightArithmeticRoundedAdd(Vector128<short> addend, Vector128<short> value, byte count)
Vector128<int> ShiftRightArithmeticRoundedAdd(Vector128<int> addend, Vector128<int> value, byte count)
Vector128<long> ShiftRightArithmeticRoundedAdd(Vector128<long> addend, Vector128<long> value, byte count)
Vector128<sbyte> ShiftRightArithmeticRoundedAdd(Vector128<sbyte> addend, Vector128<sbyte> value, byte count)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightarithmeticroundedadd?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vrsra_n_s16).

Assembly generated:

```

; Assembly listing for method AdvSimdMethods:ShiftRightArithmeticRoundedAddTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
;
;  V00 arg0         [V00,T01] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T02] (  3,  3   )   simd8  ->   d1         HFA(simd8) 
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T03] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T04] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 0

G_M4591_IG01:
        A9BF7BFD          stp     fp, lr, [sp,#-16]!
        910003FD          mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M4591_IG02:
        53001C00          uxtb    w0, w0
        97ECC997          bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightArithmeticRoundedAdd(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
						;; bbWeight=1    PerfScore 1.50
G_M4591_IG03:
        A8C17BFD          ldp     fp, lr, [sp],#16
        D65F03C0          ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 7.40, (MethodHash=6aa6ee10) for method AdvSimdMethods:ShiftRightArithmeticRoundedAddTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 35. ShiftRightArithmeticRoundedAddScalar

`Vector64<long> ShiftRightArithmeticRoundedAddScalar(Vector64<long> addend, Vector64<long> value, byte count)`

Performs 'ShiftRightArithmeticRoundedAddScalar' operation

```csharp
private Vector64<long> ShiftRightArithmeticRoundedAddScalarTest(Vector64<long> addend, Vector64<long> value, byte count)
{
  return AdvSimd.ShiftRightArithmeticRoundedAddScalar(addend, value, count);
}
// addend = <11>
// value = <11>
// count = 0
// Result = TODO

```



See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightarithmeticroundedaddscalar?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vrsra_n_s64).

Assembly generated:

```

; Assembly listing for method AdvSimdMethods:ShiftRightArithmeticRoundedAddScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
;
;  V00 arg0         [V00,T01] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T02] (  3,  3   )   simd8  ->   d1         HFA(simd8) 
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T03] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T04] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 0

G_M24164_IG01:
        A9BF7BFD          stp     fp, lr, [sp,#-16]!
        910003FD          mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M24164_IG02:
        53001C00          uxtb    w0, w0
        97ECC915          bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightArithmeticRoundedAddScalar(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
						;; bbWeight=1    PerfScore 1.50
G_M24164_IG03:
        A8C17BFD          ldp     fp, lr, [sp],#16
        D65F03C0          ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 7.40, (MethodHash=4f01a19b) for method AdvSimdMethods:ShiftRightArithmeticRoundedAddScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
; ============================================================


```
------------------------------------------------

### 36. ShiftRightArithmeticRoundedNarrowingSaturateLower

`Vector64<short> ShiftRightArithmeticRoundedNarrowingSaturateLower(Vector128<int> value, byte count)`

Performs 'ShiftRightArithmeticRoundedNarrowingSaturateLower' operation

```csharp
private Vector64<short> ShiftRightArithmeticRoundedNarrowingSaturateLowerTest(Vector128<int> value, byte count)
{
  return AdvSimd.ShiftRightArithmeticRoundedNarrowingSaturateLower(value, count);
}
// value = <11, 12, 13, 14>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<int> ShiftRightArithmeticRoundedNarrowingSaturateLower(Vector128<long> value, byte count)
Vector64<sbyte> ShiftRightArithmeticRoundedNarrowingSaturateLower(Vector128<short> value, byte count)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightarithmeticroundednarrowingsaturatelower?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vqrshrn_n_s32).

Assembly generated:

```

; Assembly listing for method AdvSimdMethods:ShiftRightArithmeticRoundedNarrowingSaturateLowerTest(System.Runtime.Intrinsics.Vector128`1[Int32],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
;
;  V00 arg0         [V00,T01] (  3,  3   )  simd16  ->   d0         HFA(simd16) 
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T02] (  2,  4   )  simd16  ->   d0         HFA(simd16)  "Inlining Arg"
;
; Lcl frame size = 0

G_M48795_IG01:
        A9BF7BFD          stp     fp, lr, [sp,#-16]!
        910003FD          mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M48795_IG02:
        53001C00          uxtb    w0, w0
        97ECC8CF          bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightArithmeticRoundedNarrowingSaturateLower(System.Runtime.Intrinsics.Vector128`1[Int32],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
						;; bbWeight=1    PerfScore 1.50
G_M48795_IG03:
        A8C17BFD          ldp     fp, lr, [sp],#16
        D65F03C0          ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 7.40, (MethodHash=e4264164) for method AdvSimdMethods:ShiftRightArithmeticRoundedNarrowingSaturateLowerTest(System.Runtime.Intrinsics.Vector128`1[Int32],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 37. ShiftRightArithmeticRoundedNarrowingSaturateUnsignedLower

`Vector64<byte> ShiftRightArithmeticRoundedNarrowingSaturateUnsignedLower(Vector128<short> value, byte count)`

Performs 'ShiftRightArithmeticRoundedNarrowingSaturateUnsignedLower' operation

```csharp
private Vector64<byte> ShiftRightArithmeticRoundedNarrowingSaturateUnsignedLowerTest(Vector128<short> value, byte count)
{
  return AdvSimd.ShiftRightArithmeticRoundedNarrowingSaturateUnsignedLower(value, count);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<ushort> ShiftRightArithmeticRoundedNarrowingSaturateUnsignedLower(Vector128<int> value, byte count)
Vector64<uint> ShiftRightArithmeticRoundedNarrowingSaturateUnsignedLower(Vector128<long> value, byte count)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightarithmeticroundednarrowingsaturateunsignedlower?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vqrshrun_n_s16).

Assembly generated:

```

; Assembly listing for method AdvSimdMethods:ShiftRightArithmeticRoundedNarrowingSaturateUnsignedLowerTest(System.Runtime.Intrinsics.Vector128`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
;
;  V00 arg0         [V00,T01] (  3,  3   )  simd16  ->   d0         HFA(simd16) 
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T02] (  2,  4   )  simd16  ->   d0         HFA(simd16)  "Inlining Arg"
;
; Lcl frame size = 0

G_M41034_IG01:
        A9BF7BFD          stp     fp, lr, [sp,#-16]!
        910003FD          mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M41034_IG02:
        53001C00          uxtb    w0, w0
        97ECC8A5          bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightArithmeticRoundedNarrowingSaturateUnsignedLower(System.Runtime.Intrinsics.Vector128`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
						;; bbWeight=1    PerfScore 1.50
G_M41034_IG03:
        A8C17BFD          ldp     fp, lr, [sp],#16
        D65F03C0          ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 7.40, (MethodHash=120c5fb5) for method AdvSimdMethods:ShiftRightArithmeticRoundedNarrowingSaturateUnsignedLowerTest(System.Runtime.Intrinsics.Vector128`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 38. ShiftRightArithmeticRoundedNarrowingSaturateUnsignedUpper

`Vector128<byte> ShiftRightArithmeticRoundedNarrowingSaturateUnsignedUpper(Vector64<byte> lower, Vector128<short> value, byte count)`

Performs 'ShiftRightArithmeticRoundedNarrowingSaturateUnsignedUpper' operation

```csharp
private Vector128<byte> ShiftRightArithmeticRoundedNarrowingSaturateUnsignedUpperTest(Vector64<byte> lower, Vector128<short> value, byte count)
{
  return AdvSimd.ShiftRightArithmeticRoundedNarrowingSaturateUnsignedUpper(lower, value, count);
}
// lower = <11, 12, 13, 14, 15, 16, 17, 18>
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<ushort> ShiftRightArithmeticRoundedNarrowingSaturateUnsignedUpper(Vector64<ushort> lower, Vector128<int> value, byte count)
Vector128<uint> ShiftRightArithmeticRoundedNarrowingSaturateUnsignedUpper(Vector64<uint> lower, Vector128<long> value, byte count)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightarithmeticroundednarrowingsaturateunsignedupper?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vqrshrun_high_n_s16).

Assembly generated:

```

; Assembly listing for method AdvSimdMethods:ShiftRightArithmeticRoundedNarrowingSaturateUnsignedUpperTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
;
;  V00 arg0         [V00,T01] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T02] (  3,  3   )  simd16  ->   d1         HFA(simd16) 
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T03] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T04] (  2,  4   )  simd16  ->   d1         HFA(simd16)  "Inlining Arg"
;
; Lcl frame size = 0

G_M30179_IG01:
        A9BF7BFD          stp     fp, lr, [sp,#-16]!
        910003FD          mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M30179_IG02:
        53001C00          uxtb    w0, w0
        97ECC87B          bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightArithmeticRoundedNarrowingSaturateUnsignedUpper(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Byte]
						;; bbWeight=1    PerfScore 1.50
G_M30179_IG03:
        A8C17BFD          ldp     fp, lr, [sp],#16
        D65F03C0          ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 7.40, (MethodHash=2b028a1c) for method AdvSimdMethods:ShiftRightArithmeticRoundedNarrowingSaturateUnsignedUpperTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Byte]
; ============================================================


```
------------------------------------------------

### 39. ShiftRightArithmeticRoundedNarrowingSaturateUpper

`Vector128<short> ShiftRightArithmeticRoundedNarrowingSaturateUpper(Vector64<short> lower, Vector128<int> value, byte count)`

Performs 'ShiftRightArithmeticRoundedNarrowingSaturateUpper' operation

```csharp
private Vector128<short> ShiftRightArithmeticRoundedNarrowingSaturateUpperTest(Vector64<short> lower, Vector128<int> value, byte count)
{
  return AdvSimd.ShiftRightArithmeticRoundedNarrowingSaturateUpper(lower, value, count);
}
// lower = <11, 12, 13, 14>
// value = <11, 12, 13, 14>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<int> ShiftRightArithmeticRoundedNarrowingSaturateUpper(Vector64<int> lower, Vector128<long> value, byte count)
Vector128<sbyte> ShiftRightArithmeticRoundedNarrowingSaturateUpper(Vector64<sbyte> lower, Vector128<short> value, byte count)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightarithmeticroundednarrowingsaturateupper?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vqrshrn_high_n_s32).

Assembly generated:

```

; Assembly listing for method AdvSimdMethods:ShiftRightArithmeticRoundedNarrowingSaturateUpperTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector128`1[Int32],ubyte):System.Runtime.Intrinsics.Vector128`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
;
;  V00 arg0         [V00,T01] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T02] (  3,  3   )  simd16  ->   d1         HFA(simd16) 
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T03] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T04] (  2,  4   )  simd16  ->   d1         HFA(simd16)  "Inlining Arg"
;
; Lcl frame size = 0

G_M41932_IG01:
        A9BF7BFD          stp     fp, lr, [sp,#-16]!
        910003FD          mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M41932_IG02:
        53001C00          uxtb    w0, w0
        97ECC841          bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightArithmeticRoundedNarrowingSaturateUpper(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector128`1[Int32],ubyte):System.Runtime.Intrinsics.Vector128`1[Int16]
						;; bbWeight=1    PerfScore 1.50
G_M41932_IG03:
        A8C17BFD          ldp     fp, lr, [sp],#16
        D65F03C0          ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 7.40, (MethodHash=d22b5c33) for method AdvSimdMethods:ShiftRightArithmeticRoundedNarrowingSaturateUpperTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector128`1[Int32],ubyte):System.Runtime.Intrinsics.Vector128`1[Int16]
; ============================================================


```
------------------------------------------------

### 40. ShiftRightArithmeticRoundedScalar

`Vector64<long> ShiftRightArithmeticRoundedScalar(Vector64<long> value, byte count)`

Performs 'ShiftRightArithmeticRoundedScalar' operation

```csharp
private Vector64<long> ShiftRightArithmeticRoundedScalarTest(Vector64<long> value, byte count)
{
  return AdvSimd.ShiftRightArithmeticRoundedScalar(value, count);
}
// value = <11>
// count = 0
// Result = TODO

```



See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightarithmeticroundedscalar?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vrshr_n_s64).

Assembly generated:

```

; Assembly listing for method AdvSimdMethods:ShiftRightArithmeticRoundedScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
;
;  V00 arg0         [V00,T01] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T02] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 0

G_M5903_IG01:
        A9BF7BFD          stp     fp, lr, [sp,#-16]!
        910003FD          mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M5903_IG02:
        53001C00          uxtb    w0, w0
        97ECC7A7          bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightArithmeticRoundedScalar(System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
						;; bbWeight=1    PerfScore 1.50
G_M5903_IG03:
        A8C17BFD          ldp     fp, lr, [sp],#16
        D65F03C0          ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 7.40, (MethodHash=1fd8e8f0) for method AdvSimdMethods:ShiftRightArithmeticRoundedScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
; ============================================================


```
------------------------------------------------

### 41. ShiftRightArithmeticScalar

`Vector64<long> ShiftRightArithmeticScalar(Vector64<long> value, byte count)`

Performs 'ShiftRightArithmeticScalar' operation

```csharp
private Vector64<long> ShiftRightArithmeticScalarTest(Vector64<long> value, byte count)
{
  return AdvSimd.ShiftRightArithmeticScalar(value, count);
}
// value = <11>
// count = 0
// Result = TODO

```



See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightarithmeticscalar?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vshr_n_s64).

Assembly generated:

```

; Assembly listing for method AdvSimdMethods:ShiftRightArithmeticScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
;
;  V00 arg0         [V00,T01] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T02] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 0

G_M38156_IG01:
        A9BF7BFD          stp     fp, lr, [sp,#-16]!
        910003FD          mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M38156_IG02:
        53001C00          uxtb    w0, w0
        97ECC701          bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightArithmeticScalar(System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
						;; bbWeight=1    PerfScore 1.50
G_M38156_IG03:
        A8C17BFD          ldp     fp, lr, [sp],#16
        D65F03C0          ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 7.40, (MethodHash=10616af3) for method AdvSimdMethods:ShiftRightArithmeticScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
; ============================================================


```
------------------------------------------------

### 42. ShiftRightLogical

`Vector64<byte> ShiftRightLogical(Vector64<byte> value, byte count)`

Performs 'ShiftRightLogical' operation

```csharp
private Vector64<byte> ShiftRightLogicalTest(Vector64<byte> value, byte count)
{
  return AdvSimd.ShiftRightLogical(value, count);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> ShiftRightLogical(Vector64<short> value, byte count)
Vector64<int> ShiftRightLogical(Vector64<int> value, byte count)
Vector64<sbyte> ShiftRightLogical(Vector64<sbyte> value, byte count)
Vector64<ushort> ShiftRightLogical(Vector64<ushort> value, byte count)
Vector64<uint> ShiftRightLogical(Vector64<uint> value, byte count)
Vector128<byte> ShiftRightLogical(Vector128<byte> value, byte count)
Vector128<short> ShiftRightLogical(Vector128<short> value, byte count)
Vector128<int> ShiftRightLogical(Vector128<int> value, byte count)
Vector128<long> ShiftRightLogical(Vector128<long> value, byte count)
Vector128<sbyte> ShiftRightLogical(Vector128<sbyte> value, byte count)
Vector128<ushort> ShiftRightLogical(Vector128<ushort> value, byte count)
Vector128<uint> ShiftRightLogical(Vector128<uint> value, byte count)
Vector128<ulong> ShiftRightLogical(Vector128<ulong> value, byte count)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightlogical?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vshr_n_u8).

Assembly generated:

```

; Assembly listing for method AdvSimdMethods:ShiftRightLogicalTest(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
;
;  V00 arg0         [V00,T01] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T02] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 0

G_M5713_IG01:
        A9BF7BFD          stp     fp, lr, [sp,#-16]!
        910003FD          mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M5713_IG02:
        53001C00          uxtb    w0, w0
        97ECC6CB          bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightLogical(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
						;; bbWeight=1    PerfScore 1.50
G_M5713_IG03:
        A8C17BFD          ldp     fp, lr, [sp],#16
        D65F03C0          ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 7.40, (MethodHash=dddbe9ae) for method AdvSimdMethods:ShiftRightLogicalTest(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 43. ShiftRightLogicalAdd

`Vector64<byte> ShiftRightLogicalAdd(Vector64<byte> addend, Vector64<byte> value, byte count)`

Performs 'ShiftRightLogicalAdd' operation

```csharp
private Vector64<byte> ShiftRightLogicalAddTest(Vector64<byte> addend, Vector64<byte> value, byte count)
{
  return AdvSimd.ShiftRightLogicalAdd(addend, value, count);
}
// addend = <11, 12, 13, 14, 15, 16, 17, 18>
// value = <21, 22, 23, 24, 25, 26, 27, 28>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> ShiftRightLogicalAdd(Vector64<short> addend, Vector64<short> value, byte count)
Vector64<int> ShiftRightLogicalAdd(Vector64<int> addend, Vector64<int> value, byte count)
Vector64<sbyte> ShiftRightLogicalAdd(Vector64<sbyte> addend, Vector64<sbyte> value, byte count)
Vector64<ushort> ShiftRightLogicalAdd(Vector64<ushort> addend, Vector64<ushort> value, byte count)
Vector64<uint> ShiftRightLogicalAdd(Vector64<uint> addend, Vector64<uint> value, byte count)
Vector128<byte> ShiftRightLogicalAdd(Vector128<byte> addend, Vector128<byte> value, byte count)
Vector128<short> ShiftRightLogicalAdd(Vector128<short> addend, Vector128<short> value, byte count)
Vector128<int> ShiftRightLogicalAdd(Vector128<int> addend, Vector128<int> value, byte count)
Vector128<long> ShiftRightLogicalAdd(Vector128<long> addend, Vector128<long> value, byte count)
Vector128<sbyte> ShiftRightLogicalAdd(Vector128<sbyte> addend, Vector128<sbyte> value, byte count)
Vector128<ushort> ShiftRightLogicalAdd(Vector128<ushort> addend, Vector128<ushort> value, byte count)
Vector128<uint> ShiftRightLogicalAdd(Vector128<uint> addend, Vector128<uint> value, byte count)
Vector128<ulong> ShiftRightLogicalAdd(Vector128<ulong> addend, Vector128<ulong> value, byte count)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightlogicaladd?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vsra_n_u8).

Assembly generated:

```

; Assembly listing for method AdvSimdMethods:ShiftRightLogicalAddTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
;
;  V00 arg0         [V00,T01] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T02] (  3,  3   )   simd8  ->   d1         HFA(simd8) 
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T03] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T04] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 0

G_M61281_IG01:
        A9BF7BFD          stp     fp, lr, [sp,#-16]!
        910003FD          mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M61281_IG02:
        53001C00          uxtb    w0, w0
        97ECC55F          bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightLogicalAdd(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
						;; bbWeight=1    PerfScore 1.50
G_M61281_IG03:
        A8C17BFD          ldp     fp, lr, [sp],#16
        D65F03C0          ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 7.40, (MethodHash=4eb4109e) for method AdvSimdMethods:ShiftRightLogicalAddTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 44. ShiftRightLogicalAddScalar

`Vector64<long> ShiftRightLogicalAddScalar(Vector64<long> addend, Vector64<long> value, byte count)`

Performs 'ShiftRightLogicalAddScalar' operation

```csharp
private Vector64<long> ShiftRightLogicalAddScalarTest(Vector64<long> addend, Vector64<long> value, byte count)
{
  return AdvSimd.ShiftRightLogicalAddScalar(addend, value, count);
}
// addend = <11>
// value = <11>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<ulong> ShiftRightLogicalAddScalar(Vector64<ulong> addend, Vector64<ulong> value, byte count)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightlogicaladdscalar?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vsra_n_u64).

Assembly generated:

```

; Assembly listing for method AdvSimdMethods:ShiftRightLogicalAddScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
;
;  V00 arg0         [V00,T01] (  3,  3   )   simd8  ->   d0         HFA(simd8) 
;  V01 arg1         [V01,T02] (  3,  3   )   simd8  ->   d1         HFA(simd8) 
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T03] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T04] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 0

G_M23860_IG01:
        A9BF7BFD          stp     fp, lr, [sp,#-16]!
        910003FD          mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M23860_IG02:
        53001C00          uxtb    w0, w0
        97ECC507          bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightLogicalAddScalar(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
						;; bbWeight=1    PerfScore 1.50
G_M23860_IG03:
        A8C17BFD          ldp     fp, lr, [sp],#16
        D65F03C0          ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 7.40, (MethodHash=1c87a2cb) for method AdvSimdMethods:ShiftRightLogicalAddScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
; ============================================================


```
------------------------------------------------

### 45. ShiftRightLogicalNarrowingLower

`Vector64<byte> ShiftRightLogicalNarrowingLower(Vector128<ushort> value, byte count)`

Performs 'ShiftRightLogicalNarrowingLower' operation

```csharp
private Vector64<byte> ShiftRightLogicalNarrowingLowerTest(Vector128<ushort> value, byte count)
{
  return AdvSimd.ShiftRightLogicalNarrowingLower(value, count);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> ShiftRightLogicalNarrowingLower(Vector128<int> value, byte count)
Vector64<int> ShiftRightLogicalNarrowingLower(Vector128<long> value, byte count)
Vector64<sbyte> ShiftRightLogicalNarrowingLower(Vector128<short> value, byte count)
Vector64<ushort> ShiftRightLogicalNarrowingLower(Vector128<uint> value, byte count)
Vector64<uint> ShiftRightLogicalNarrowingLower(Vector128<ulong> value, byte count)
```


See Microsoft docs [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightlogicalnarrowinglower?view=net-5.0), ARM docs [here](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics?search=vshrn_n_u16).

Assembly generated:

```

; Assembly listing for method AdvSimdMethods:ShiftRightLogicalNarrowingLowerTest(System.Runtime.Intrinsics.Vector128`1[UInt16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
;
;  V00 arg0         [V00,T01] (  3,  3   )  simd16  ->   d0         HFA(simd16) 
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T02] (  2,  4   )  simd16  ->   d0         HFA(simd16)  "Inlining Arg"
;
; Lcl frame size = 0

G_M21911_IG01:
        A9BF7BFD          stp     fp, lr, [sp,#-16]!
        910003FD          mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M21911_IG02:
        53001C00          uxtb    w0, w0
        97ECC4D7          bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightLogicalNarrowingLower(System.Runtime.Intrinsics.Vector128`1[UInt16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
						;; bbWeight=1    PerfScore 1.50
G_M21911_IG03:
        A8C17BFD          ldp     fp, lr, [sp],#16
        D65F03C0          ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 7.40, (MethodHash=da22aa68) for method AdvSimdMethods:ShiftRightLogicalNarrowingLowerTest(System.Runtime.Intrinsics.Vector128`1[UInt16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================

```

