---
STARTlayout:post
title: Hardware Intrinsics APIs for ARM64 - Part 1
subtitle: With examples
tags: [work, arm64, intrinsics]
---

### Introduction

In my [last post](../2019-01-01-Vectorization-APIs), I describe SIMD datatypes `Vector64<T>` and `Vector128<T>` that operates on 'hardware intrisic' APIs. In this post I will describe the intrinsic APIs for ARM64 and how you can use them to optimize your code if you are writing a .NET API targetting ARM64. This is 3 post series TODO.


### API list

[Abs](#1-abs), [AbsSaturate](#2-abssaturate), [AbsScalar](#3-absscalar), [AbsoluteCompareGreaterThan](#4-absolutecomparegreaterthan), [AbsoluteCompareGreaterThanOrEqual](#5-absolutecomparegreaterthanorequal), [AbsoluteCompareLessThan](#6-absolutecomparelessthan), [AbsoluteCompareLessThanOrEqual](#7-absolutecomparelessthanorequal), [AbsoluteDifference](#8-absolutedifference), [AbsoluteDifferenceAdd](#9-absolutedifferenceadd), [AbsoluteDifferenceWideningLower](#10-absolutedifferencewideninglower), [AbsoluteDifferenceWideningLowerAndAdd](#11-absolutedifferencewideninglowerandadd), [AbsoluteDifferenceWideningUpper](#12-absolutedifferencewideningupper), [AbsoluteDifferenceWideningUpperAndAdd](#13-absolutedifferencewideningupperandadd), [Add](#14-add), [AddHighNarrowingLower](#15-addhighnarrowinglower), [AddHighNarrowingUpper](#16-addhighnarrowingupper), [AddPairwise](#17-addpairwise), [AddPairwiseWidening](#18-addpairwisewidening), [AddPairwiseWideningAndAdd](#19-addpairwisewideningandadd), [AddPairwiseWideningAndAddScalar](#20-addpairwisewideningandaddscalar), [AddPairwiseWideningScalar](#21-addpairwisewideningscalar), [AddRoundedHighNarrowingLower](#22-addroundedhighnarrowinglower), [AddRoundedHighNarrowingUpper](#23-addroundedhighnarrowingupper), [AddSaturate](#24-addsaturate), [AddSaturateScalar](#25-addsaturatescalar), [AddScalar](#26-addscalar), [AddWideningLower](#27-addwideninglower), [AddWideningUpper](#28-addwideningupper), [And](#29-and), [BitwiseClear](#30-bitwiseclear), [BitwiseSelect](#31-bitwiseselect), [Ceiling](#32-ceiling), [CeilingScalar](#33-ceilingscalar), [CompareEqual](#34-compareequal), [CompareGreaterThan](#35-comparegreaterthan), [CompareGreaterThanOrEqual](#36-comparegreaterthanorequal), [CompareLessThan](#37-comparelessthan), [CompareLessThanOrEqual](#38-comparelessthanorequal), [CompareTest](#39-comparetest), [ConvertToInt32RoundAwayFromZero](#40-converttoint32roundawayfromzero), [ConvertToInt32RoundAwayFromZeroScalar](#41-converttoint32roundawayfromzeroscalar), [ConvertToInt32RoundToEven](#42-converttoint32roundtoeven), [ConvertToInt32RoundToEvenScalar](#43-converttoint32roundtoevenscalar), [ConvertToInt32RoundToNegativeInfinity](#44-converttoint32roundtonegativeinfinity), [ConvertToInt32RoundToNegativeInfinityScalar](#45-converttoint32roundtonegativeinfinityscalar), [ConvertToInt32RoundToPositiveInfinity](#46-converttoint32roundtopositiveinfinity), [ConvertToInt32RoundToPositiveInfinityScalar](#47-converttoint32roundtopositiveinfinityscalar), [ConvertToInt32RoundToZero](#48-converttoint32roundtozero), [ConvertToInt32RoundToZeroScalar](#49-converttoint32roundtozeroscalar), [ConvertToSingle](#50-converttosingle), [ConvertToSingleScalar](#51-converttosinglescalar), [ConvertToUInt32RoundAwayFromZero](#52-converttouint32roundawayfromzero), [ConvertToUInt32RoundAwayFromZeroScalar](#53-converttouint32roundawayfromzeroscalar), [ConvertToUInt32RoundToEven](#54-converttouint32roundtoeven), [ConvertToUInt32RoundToEvenScalar](#55-converttouint32roundtoevenscalar), [ConvertToUInt32RoundToNegativeInfinity](#56-converttouint32roundtonegativeinfinity), [ConvertToUInt32RoundToNegativeInfinityScalar](#57-converttouint32roundtonegativeinfinityscalar), [ConvertToUInt32RoundToPositiveInfinity](#58-converttouint32roundtopositiveinfinity), [ConvertToUInt32RoundToPositiveInfinityScalar](#59-converttouint32roundtopositiveinfinityscalar), [ConvertToUInt32RoundToZero](#60-converttouint32roundtozero),[...](Part1.md)






### 1. Abs

`Vector64<ushort> Abs(Vector64<short> value)`

Performs 'Abs' operation.

```csharp
private Vector64<ushort> AbsTest(Vector64<short> value)
{
  return AdvSimd.Abs(value);
}
// value = <11, 12, 13, 14>
// Result = <11, 12, 13, 14>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<uint> Abs(Vector64<int> value)
Vector64<byte> Abs(Vector64<sbyte> value)
Vector64<float> Abs(Vector64<float> value)
Vector128<ushort> Abs(Vector128<short> value)
Vector128<uint> Abs(Vector128<int> value)
Vector128<byte> Abs(Vector128<sbyte> value)
Vector128<float> Abs(Vector128<float> value)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> Abs(Vector128<double> value)
Vector128<ulong> Abs(Vector128<long> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.abs?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.abs?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:AbsTest(System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[UInt16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M59396_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M59396_IG02:
            ldr     d16, [fp,#24]
            abs     v16.4h, v16.4h
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 4.50
G_M59396_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 12.20, (MethodHash=8faf17fb) for method AdvSimdMethods:AbsTest(System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[UInt16]
; ============================================================


```
------------------------------------------------

### 2. AbsSaturate

`Vector64<short> AbsSaturate(Vector64<short> value)`

Performs 'AbsSaturate' operation.

```csharp
private Vector64<short> AbsSaturateTest(Vector64<short> value)
{
  return AdvSimd.AbsSaturate(value);
}
// value = <11, 12, 13, 14>
// Result = <11, 12, 13, 14>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<int> AbsSaturate(Vector64<int> value)
Vector64<sbyte> AbsSaturate(Vector64<sbyte> value)
Vector128<short> AbsSaturate(Vector128<short> value)
Vector128<int> AbsSaturate(Vector128<int> value)
Vector128<sbyte> AbsSaturate(Vector128<sbyte> value)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<long> AbsSaturate(Vector128<long> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.abssaturate?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.abssaturate?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:AbsSaturateTest(System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M20416_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M20416_IG02:
            ldr     d16, [fp,#24]
            sqabs   v16.4h, v16.4h
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M20416_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=edc1b03f) for method AdvSimdMethods:AbsSaturateTest(System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 3. AbsScalar

`Vector64<double> AbsScalar(Vector64<double> value)`

Performs 'AbsScalar' operation.

```csharp
private Vector64<double> AbsScalarTest(Vector64<double> value)
{
  return AdvSimd.AbsScalar(value);
}
// value = <11.5>
// Result = <11.5>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<float> AbsScalar(Vector64<float> value)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<ulong> AbsScalar(Vector64<long> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.absscalar?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.absscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:AbsScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M37567_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M37567_IG02:
            ldr     d16, [fp,#24]
            fabs    d16, d16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 4.50
G_M37567_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 12.20, (MethodHash=3f1e6d40) for method AdvSimdMethods:AbsScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 4. AbsoluteCompareGreaterThan

`Vector64<float> AbsoluteCompareGreaterThan(Vector64<float> left, Vector64<float> right)`

Performs 'AbsoluteCompareGreaterThan' operation.

```csharp
private Vector64<float> AbsoluteCompareGreaterThanTest(Vector64<float> left, Vector64<float> right)
{
  return AdvSimd.AbsoluteCompareGreaterThan(left, right);
}
// left = <11.5, 12.5>
// right = <21.5, 22.5>
// Result = <0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<float> AbsoluteCompareGreaterThan(Vector128<float> left, Vector128<float> right)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> AbsoluteCompareGreaterThan(Vector128<double> left, Vector128<double> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.absolutecomparegreaterthan?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.absolutecomparegreaterthan?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:AbsoluteCompareGreaterThanTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M11025_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M11025_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            facgt   v16.2s, v16.2s, v17.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M11025_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=fa32d4ee) for method AdvSimdMethods:AbsoluteCompareGreaterThanTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 5. AbsoluteCompareGreaterThanOrEqual

`Vector64<float> AbsoluteCompareGreaterThanOrEqual(Vector64<float> left, Vector64<float> right)`

Performs 'AbsoluteCompareGreaterThanOrEqual' operation.

```csharp
private Vector64<float> AbsoluteCompareGreaterThanOrEqualTest(Vector64<float> left, Vector64<float> right)
{
  return AdvSimd.AbsoluteCompareGreaterThanOrEqual(left, right);
}
// left = <11.5, 12.5>
// right = <21.5, 22.5>
// Result = <0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<float> AbsoluteCompareGreaterThanOrEqual(Vector128<float> left, Vector128<float> right)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> AbsoluteCompareGreaterThanOrEqual(Vector128<double> left, Vector128<double> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.absolutecomparegreaterthanorequal?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.absolutecomparegreaterthanorequal?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:AbsoluteCompareGreaterThanOrEqualTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M57568_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M57568_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            facge   v16.2s, v16.2s, v17.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M57568_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=ff3c1f1f) for method AdvSimdMethods:AbsoluteCompareGreaterThanOrEqualTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 6. AbsoluteCompareLessThan

`Vector64<float> AbsoluteCompareLessThan(Vector64<float> left, Vector64<float> right)`

Performs 'AbsoluteCompareLessThan' operation.

```csharp
private Vector64<float> AbsoluteCompareLessThanTest(Vector64<float> left, Vector64<float> right)
{
  return AdvSimd.AbsoluteCompareLessThan(left, right);
}
// left = <11.5, 12.5>
// right = <21.5, 22.5>
// Result = <NaN, NaN>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<float> AbsoluteCompareLessThan(Vector128<float> left, Vector128<float> right)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> AbsoluteCompareLessThan(Vector128<double> left, Vector128<double> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.absolutecomparelessthan?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.absolutecomparelessthan?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:AbsoluteCompareLessThanTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M25962_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M25962_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            facgt   v16.2s, v17.2s, v16.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M25962_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=621d9a95) for method AdvSimdMethods:AbsoluteCompareLessThanTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 7. AbsoluteCompareLessThanOrEqual

`Vector64<float> AbsoluteCompareLessThanOrEqual(Vector64<float> left, Vector64<float> right)`

Performs 'AbsoluteCompareLessThanOrEqual' operation.

```csharp
private Vector64<float> AbsoluteCompareLessThanOrEqualTest(Vector64<float> left, Vector64<float> right)
{
  return AdvSimd.AbsoluteCompareLessThanOrEqual(left, right);
}
// left = <11.5, 12.5>
// right = <21.5, 22.5>
// Result = <NaN, NaN>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<float> AbsoluteCompareLessThanOrEqual(Vector128<float> left, Vector128<float> right)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> AbsoluteCompareLessThanOrEqual(Vector128<double> left, Vector128<double> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.absolutecomparelessthanorequal?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.absolutecomparelessthanorequal?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:AbsoluteCompareLessThanOrEqualTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M18683_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M18683_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            facge   v16.2s, v17.2s, v16.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M18683_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=8af0b704) for method AdvSimdMethods:AbsoluteCompareLessThanOrEqualTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 8. AbsoluteDifference

`Vector64<byte> AbsoluteDifference(Vector64<byte> left, Vector64<byte> right)`

Performs 'AbsoluteDifference' operation.

```csharp
private Vector64<byte> AbsoluteDifferenceTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.AbsoluteDifference(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <10, 10, 10, 10, 10, 10, 10, 10>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<ushort> AbsoluteDifference(Vector64<short> left, Vector64<short> right)
Vector64<uint> AbsoluteDifference(Vector64<int> left, Vector64<int> right)
Vector64<byte> AbsoluteDifference(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<float> AbsoluteDifference(Vector64<float> left, Vector64<float> right)
Vector64<ushort> AbsoluteDifference(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> AbsoluteDifference(Vector64<uint> left, Vector64<uint> right)
Vector128<byte> AbsoluteDifference(Vector128<byte> left, Vector128<byte> right)
Vector128<ushort> AbsoluteDifference(Vector128<short> left, Vector128<short> right)
Vector128<uint> AbsoluteDifference(Vector128<int> left, Vector128<int> right)
Vector128<byte> AbsoluteDifference(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<float> AbsoluteDifference(Vector128<float> left, Vector128<float> right)
Vector128<ushort> AbsoluteDifference(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> AbsoluteDifference(Vector128<uint> left, Vector128<uint> right)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> AbsoluteDifference(Vector128<double> left, Vector128<double> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.absolutedifference?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.absolutedifference?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:AbsoluteDifferenceTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M18416_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M18416_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            uabd    v16.8b, v16.8b, v17.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 6.50
G_M18416_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 16.00, (MethodHash=1851b80f) for method AdvSimdMethods:AbsoluteDifferenceTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 9. AbsoluteDifferenceAdd

`Vector64<byte> AbsoluteDifferenceAdd(Vector64<byte> addend, Vector64<byte> left, Vector64<byte> right)`

Performs 'AbsoluteDifferenceAdd' operation.

```csharp
private Vector64<byte> AbsoluteDifferenceAddTest(Vector64<byte> addend, Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.AbsoluteDifferenceAdd(addend, left, right);
}
// addend = <11, 12, 13, 14, 15, 16, 17, 18>
// left = <21, 22, 23, 24, 25, 26, 27, 28>
// right = <31, 32, 33, 34, 35, 36, 37, 38>
// Result = <21, 22, 23, 24, 25, 26, 27, 28>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> AbsoluteDifferenceAdd(Vector64<short> addend, Vector64<short> left, Vector64<short> right)
Vector64<int> AbsoluteDifferenceAdd(Vector64<int> addend, Vector64<int> left, Vector64<int> right)
Vector64<sbyte> AbsoluteDifferenceAdd(Vector64<sbyte> addend, Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<ushort> AbsoluteDifferenceAdd(Vector64<ushort> addend, Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> AbsoluteDifferenceAdd(Vector64<uint> addend, Vector64<uint> left, Vector64<uint> right)
Vector128<byte> AbsoluteDifferenceAdd(Vector128<byte> addend, Vector128<byte> left, Vector128<byte> right)
Vector128<short> AbsoluteDifferenceAdd(Vector128<short> addend, Vector128<short> left, Vector128<short> right)
Vector128<int> AbsoluteDifferenceAdd(Vector128<int> addend, Vector128<int> left, Vector128<int> right)
Vector128<sbyte> AbsoluteDifferenceAdd(Vector128<sbyte> addend, Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<ushort> AbsoluteDifferenceAdd(Vector128<ushort> addend, Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> AbsoluteDifferenceAdd(Vector128<uint> addend, Vector128<uint> left, Vector128<uint> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.absolutedifferenceadd?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:AbsoluteDifferenceAddTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x20]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M13696_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     d1, [fp,#32]
            str     d2, [fp,#24]
						;; bbWeight=1    PerfScore 4.50
G_M13696_IG02:
            ldr     d16, [fp,#40]
            ldr     d17, [fp,#32]
            ldr     d18, [fp,#24]
            uaba    v16.8b, v17.8b, v18.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 9.50
G_M13696_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 20.80, (MethodHash=51a8ca7f) for method AdvSimdMethods:AbsoluteDifferenceAddTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 10. AbsoluteDifferenceWideningLower

`Vector128<ushort> AbsoluteDifferenceWideningLower(Vector64<byte> left, Vector64<byte> right)`

Performs 'AbsoluteDifferenceWideningLower' operation.

```csharp
private Vector128<ushort> AbsoluteDifferenceWideningLowerTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.AbsoluteDifferenceWideningLower(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <10, 10, 10, 10, 10, 10, 10, 10>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<uint> AbsoluteDifferenceWideningLower(Vector64<short> left, Vector64<short> right)
Vector128<ulong> AbsoluteDifferenceWideningLower(Vector64<int> left, Vector64<int> right)
Vector128<ushort> AbsoluteDifferenceWideningLower(Vector64<sbyte> left, Vector64<sbyte> right)
Vector128<uint> AbsoluteDifferenceWideningLower(Vector64<ushort> left, Vector64<ushort> right)
Vector128<ulong> AbsoluteDifferenceWideningLower(Vector64<uint> left, Vector64<uint> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.absolutedifferencewideninglower?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:AbsoluteDifferenceWideningLowerTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector128`1[UInt16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M51216_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M51216_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            uabdl   v16.8h, v16.8b, v17.8b
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 6.50
G_M51216_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 16.00, (MethodHash=96cd37ef) for method AdvSimdMethods:AbsoluteDifferenceWideningLowerTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector128`1[UInt16]
; ============================================================


```
------------------------------------------------

### 11. AbsoluteDifferenceWideningLowerAndAdd

`Vector128<ushort> AbsoluteDifferenceWideningLowerAndAdd(Vector128<ushort> addend, Vector64<byte> left, Vector64<byte> right)`

Performs 'AbsoluteDifferenceWideningLowerAndAdd' operation.

```csharp
private Vector128<ushort> AbsoluteDifferenceWideningLowerAndAddTest(Vector128<ushort> addend, Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.AbsoluteDifferenceWideningLowerAndAdd(addend, left, right);
}
// addend = <11, 12, 13, 14, 15, 16, 17, 18>
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <21, 22, 23, 24, 25, 26, 27, 28>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<int> AbsoluteDifferenceWideningLowerAndAdd(Vector128<int> addend, Vector64<short> left, Vector64<short> right)
Vector128<long> AbsoluteDifferenceWideningLowerAndAdd(Vector128<long> addend, Vector64<int> left, Vector64<int> right)
Vector128<short> AbsoluteDifferenceWideningLowerAndAdd(Vector128<short> addend, Vector64<sbyte> left, Vector64<sbyte> right)
Vector128<uint> AbsoluteDifferenceWideningLowerAndAdd(Vector128<uint> addend, Vector64<ushort> left, Vector64<ushort> right)
Vector128<ulong> AbsoluteDifferenceWideningLowerAndAdd(Vector128<ulong> addend, Vector64<uint> left, Vector64<uint> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.absolutedifferencewideninglowerandadd?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:AbsoluteDifferenceWideningLowerAndAddTest(System.Runtime.Intrinsics.Vector128`1[UInt16],System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector128`1[UInt16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M13817_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     q0, [fp,#32]
            str     d1, [fp,#24]
            str     d2, [fp,#16]
						;; bbWeight=1    PerfScore 4.50
G_M13817_IG02:
            ldr     q16, [fp,#32]
            ldr     d17, [fp,#24]
            ldr     d18, [fp,#16]
            uabal   v16.8h, v17.8b, v18.8b
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 9.50
G_M13817_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 20.80, (MethodHash=a479ca06) for method AdvSimdMethods:AbsoluteDifferenceWideningLowerAndAddTest(System.Runtime.Intrinsics.Vector128`1[UInt16],System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector128`1[UInt16]
; ============================================================


```
------------------------------------------------

### 12. AbsoluteDifferenceWideningUpper

`Vector128<ushort> AbsoluteDifferenceWideningUpper(Vector128<byte> left, Vector128<byte> right)`

Performs 'AbsoluteDifferenceWideningUpper' operation.

```csharp
private Vector128<ushort> AbsoluteDifferenceWideningUpperTest(Vector128<byte> left, Vector128<byte> right)
{
  return AdvSimd.AbsoluteDifferenceWideningUpper(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26>
// right = <21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36>
// Result = <10, 10, 10, 10, 10, 10, 10, 10>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<uint> AbsoluteDifferenceWideningUpper(Vector128<short> left, Vector128<short> right)
Vector128<ulong> AbsoluteDifferenceWideningUpper(Vector128<int> left, Vector128<int> right)
Vector128<ushort> AbsoluteDifferenceWideningUpper(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<uint> AbsoluteDifferenceWideningUpper(Vector128<ushort> left, Vector128<ushort> right)
Vector128<ulong> AbsoluteDifferenceWideningUpper(Vector128<uint> left, Vector128<uint> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.absolutedifferencewideningupper?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:AbsoluteDifferenceWideningUpperTest(System.Runtime.Intrinsics.Vector128`1[Byte],System.Runtime.Intrinsics.Vector128`1[Byte]):System.Runtime.Intrinsics.Vector128`1[UInt16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M10161_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     q0, [fp,#32]
            str     q1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M10161_IG02:
            ldr     q16, [fp,#32]
            ldr     q17, [fp,#16]
            uabdl2  v16.8h, v16.16b, v17.16b
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 6.50
G_M10161_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 16.00, (MethodHash=9288d84e) for method AdvSimdMethods:AbsoluteDifferenceWideningUpperTest(System.Runtime.Intrinsics.Vector128`1[Byte],System.Runtime.Intrinsics.Vector128`1[Byte]):System.Runtime.Intrinsics.Vector128`1[UInt16]
; ============================================================


```
------------------------------------------------

### 13. AbsoluteDifferenceWideningUpperAndAdd

`Vector128<ushort> AbsoluteDifferenceWideningUpperAndAdd(Vector128<ushort> addend, Vector128<byte> left, Vector128<byte> right)`

Performs 'AbsoluteDifferenceWideningUpperAndAdd' operation.

```csharp
private Vector128<ushort> AbsoluteDifferenceWideningUpperAndAddTest(Vector128<ushort> addend, Vector128<byte> left, Vector128<byte> right)
{
  return AdvSimd.AbsoluteDifferenceWideningUpperAndAdd(addend, left, right);
}
// addend = <11, 12, 13, 14, 15, 16, 17, 18>
// left = <11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26>
// right = <21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36>
// Result = <21, 22, 23, 24, 25, 26, 27, 28>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<int> AbsoluteDifferenceWideningUpperAndAdd(Vector128<int> addend, Vector128<short> left, Vector128<short> right)
Vector128<long> AbsoluteDifferenceWideningUpperAndAdd(Vector128<long> addend, Vector128<int> left, Vector128<int> right)
Vector128<short> AbsoluteDifferenceWideningUpperAndAdd(Vector128<short> addend, Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<uint> AbsoluteDifferenceWideningUpperAndAdd(Vector128<uint> addend, Vector128<ushort> left, Vector128<ushort> right)
Vector128<ulong> AbsoluteDifferenceWideningUpperAndAdd(Vector128<ulong> addend, Vector128<uint> left, Vector128<uint> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.absolutedifferencewideningupperandadd?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:AbsoluteDifferenceWideningUpperAndAddTest(System.Runtime.Intrinsics.Vector128`1[UInt16],System.Runtime.Intrinsics.Vector128`1[Byte],System.Runtime.Intrinsics.Vector128`1[Byte]):System.Runtime.Intrinsics.Vector128`1[UInt16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x30]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 48

G_M16792_IG01:
            stp     fp, lr, [sp,#-64]!
            mov     fp, sp
            str     q0, [fp,#48]
            str     q1, [fp,#32]
            str     q2, [fp,#16]
						;; bbWeight=1    PerfScore 4.50
G_M16792_IG02:
            ldr     q16, [fp,#48]
            ldr     q17, [fp,#32]
            ldr     q18, [fp,#16]
            uabal2  v16.8h, v17.16b, v18.16b
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 9.50
G_M16792_IG03:
            ldp     fp, lr, [sp],#64
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 20.80, (MethodHash=4108be67) for method AdvSimdMethods:AbsoluteDifferenceWideningUpperAndAddTest(System.Runtime.Intrinsics.Vector128`1[UInt16],System.Runtime.Intrinsics.Vector128`1[Byte],System.Runtime.Intrinsics.Vector128`1[Byte]):System.Runtime.Intrinsics.Vector128`1[UInt16]
; ============================================================


```
------------------------------------------------

### 14. Add

`Vector64<byte> Add(Vector64<byte> left, Vector64<byte> right)`

Performs 'Add' operation.

```csharp
private Vector64<byte> AddTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.Add(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <32, 34, 36, 38, 40, 42, 44, 46>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> Add(Vector64<short> left, Vector64<short> right)
Vector64<int> Add(Vector64<int> left, Vector64<int> right)
Vector64<sbyte> Add(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<float> Add(Vector64<float> left, Vector64<float> right)
Vector64<ushort> Add(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> Add(Vector64<uint> left, Vector64<uint> right)
Vector128<byte> Add(Vector128<byte> left, Vector128<byte> right)
Vector128<short> Add(Vector128<short> left, Vector128<short> right)
Vector128<int> Add(Vector128<int> left, Vector128<int> right)
Vector128<long> Add(Vector128<long> left, Vector128<long> right)
Vector128<sbyte> Add(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<float> Add(Vector128<float> left, Vector128<float> right)
Vector128<ushort> Add(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> Add(Vector128<uint> left, Vector128<uint> right)
Vector128<ulong> Add(Vector128<ulong> left, Vector128<ulong> right)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> Add(Vector128<double> left, Vector128<double> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.add?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.add?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:AddTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M3057_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M3057_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            add     v16.8b, v16.8b, v17.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M3057_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=1d7ff40e) for method AdvSimdMethods:AddTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 15. AddHighNarrowingLower

`Vector64<byte> AddHighNarrowingLower(Vector128<ushort> left, Vector128<ushort> right)`

Performs 'AddHighNarrowingLower' operation.

```csharp
private Vector64<byte> AddHighNarrowingLowerTest(Vector128<ushort> left, Vector128<ushort> right)
{
  return AdvSimd.AddHighNarrowingLower(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <11, 12, 13, 14, 15, 16, 17, 18>
// Result = <0, 0, 0, 0, 0, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> AddHighNarrowingLower(Vector128<int> left, Vector128<int> right)
Vector64<int> AddHighNarrowingLower(Vector128<long> left, Vector128<long> right)
Vector64<sbyte> AddHighNarrowingLower(Vector128<short> left, Vector128<short> right)
Vector64<ushort> AddHighNarrowingLower(Vector128<uint> left, Vector128<uint> right)
Vector64<uint> AddHighNarrowingLower(Vector128<ulong> left, Vector128<ulong> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.addhighnarrowinglower?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:AddHighNarrowingLowerTest(System.Runtime.Intrinsics.Vector128`1[UInt16],System.Runtime.Intrinsics.Vector128`1[UInt16]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M875_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     q0, [fp,#32]
            str     q1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M875_IG02:
            ldr     q16, [fp,#32]
            ldr     q17, [fp,#16]
            addhn   v16.8b, v16.8h, v17.8h
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 6.50
G_M875_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 16.00, (MethodHash=256ffc94) for method AdvSimdMethods:AddHighNarrowingLowerTest(System.Runtime.Intrinsics.Vector128`1[UInt16],System.Runtime.Intrinsics.Vector128`1[UInt16]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 16. AddHighNarrowingUpper

`Vector128<byte> AddHighNarrowingUpper(Vector64<byte> lower, Vector128<ushort> left, Vector128<ushort> right)`

Performs 'AddHighNarrowingUpper' operation.

```csharp
private Vector128<byte> AddHighNarrowingUpperTest(Vector64<byte> lower, Vector128<ushort> left, Vector128<ushort> right)
{
  return AdvSimd.AddHighNarrowingUpper(lower, left, right);
}
// lower = <11, 12, 13, 14, 15, 16, 17, 18>
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <11, 12, 13, 14, 15, 16, 17, 18>
// Result = <11, 12, 13, 14, 15, 16, 17, 18, 0, 0, 0, 0, 0, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<short> AddHighNarrowingUpper(Vector64<short> lower, Vector128<int> left, Vector128<int> right)
Vector128<int> AddHighNarrowingUpper(Vector64<int> lower, Vector128<long> left, Vector128<long> right)
Vector128<sbyte> AddHighNarrowingUpper(Vector64<sbyte> lower, Vector128<short> left, Vector128<short> right)
Vector128<ushort> AddHighNarrowingUpper(Vector64<ushort> lower, Vector128<uint> left, Vector128<uint> right)
Vector128<uint> AddHighNarrowingUpper(Vector64<uint> lower, Vector128<ulong> left, Vector128<ulong> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.addhighnarrowingupper?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:AddHighNarrowingUpperTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[UInt16],System.Runtime.Intrinsics.Vector128`1[UInt16]):System.Runtime.Intrinsics.Vector128`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x38]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 48

G_M57890_IG01:
            stp     fp, lr, [sp,#-64]!
            mov     fp, sp
            str     d0, [fp,#56]
            str     q1, [fp,#32]
            str     q2, [fp,#16]
						;; bbWeight=1    PerfScore 4.50
G_M57890_IG02:
            ldr     d16, [fp,#56]
            ldr     q17, [fp,#32]
            ldr     q18, [fp,#16]
            addhn2  v16.16b, v17.8h, v18.8h
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 8.50
G_M57890_IG03:
            ldp     fp, lr, [sp],#64
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 19.80, (MethodHash=a91d1ddd) for method AdvSimdMethods:AddHighNarrowingUpperTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[UInt16],System.Runtime.Intrinsics.Vector128`1[UInt16]):System.Runtime.Intrinsics.Vector128`1[Byte]
; ============================================================


```
------------------------------------------------

### 17. AddPairwise

`Vector64<byte> AddPairwise(Vector64<byte> left, Vector64<byte> right)`

Performs 'AddPairwise' operation.

```csharp
private Vector64<byte> AddPairwiseTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.AddPairwise(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <23, 27, 31, 35, 43, 47, 51, 55>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> AddPairwise(Vector64<short> left, Vector64<short> right)
Vector64<int> AddPairwise(Vector64<int> left, Vector64<int> right)
Vector64<sbyte> AddPairwise(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<float> AddPairwise(Vector64<float> left, Vector64<float> right)
Vector64<ushort> AddPairwise(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> AddPairwise(Vector64<uint> left, Vector64<uint> right)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<byte> AddPairwise(Vector128<byte> left, Vector128<byte> right)
Vector128<double> AddPairwise(Vector128<double> left, Vector128<double> right)
Vector128<short> AddPairwise(Vector128<short> left, Vector128<short> right)
Vector128<int> AddPairwise(Vector128<int> left, Vector128<int> right)
Vector128<long> AddPairwise(Vector128<long> left, Vector128<long> right)
Vector128<sbyte> AddPairwise(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<float> AddPairwise(Vector128<float> left, Vector128<float> right)
Vector128<ushort> AddPairwise(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> AddPairwise(Vector128<uint> left, Vector128<uint> right)
Vector128<ulong> AddPairwise(Vector128<ulong> left, Vector128<ulong> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.addpairwise?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.addpairwise?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:AddPairwiseTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M7219_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M7219_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            addp    v16.8b, v16.8b, v17.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 6.50
G_M7219_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 16.00, (MethodHash=882de3cc) for method AdvSimdMethods:AddPairwiseTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 18. AddPairwiseWidening

`Vector64<ushort> AddPairwiseWidening(Vector64<byte> value)`

Performs 'AddPairwiseWidening' operation.

```csharp
private Vector64<ushort> AddPairwiseWideningTest(Vector64<byte> value)
{
  return AdvSimd.AddPairwiseWidening(value);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// Result = <23, 27, 31, 35>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<int> AddPairwiseWidening(Vector64<short> value)
Vector64<short> AddPairwiseWidening(Vector64<sbyte> value)
Vector64<uint> AddPairwiseWidening(Vector64<ushort> value)
Vector128<ushort> AddPairwiseWidening(Vector128<byte> value)
Vector128<int> AddPairwiseWidening(Vector128<short> value)
Vector128<long> AddPairwiseWidening(Vector128<int> value)
Vector128<short> AddPairwiseWidening(Vector128<sbyte> value)
Vector128<uint> AddPairwiseWidening(Vector128<ushort> value)
Vector128<ulong> AddPairwiseWidening(Vector128<uint> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.addpairwisewidening?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:AddPairwiseWideningTest(System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[UInt16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M49848_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M49848_IG02:
            ldr     d16, [fp,#24]
            uaddlp  v16.4h, v16.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 4.50
G_M49848_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 12.20, (MethodHash=522d3d47) for method AdvSimdMethods:AddPairwiseWideningTest(System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[UInt16]
; ============================================================


```
------------------------------------------------

### 19. AddPairwiseWideningAndAdd

`Vector64<ushort> AddPairwiseWideningAndAdd(Vector64<ushort> addend, Vector64<byte> value)`

Performs 'AddPairwiseWideningAndAdd' operation.

```csharp
private Vector64<ushort> AddPairwiseWideningAndAddTest(Vector64<ushort> addend, Vector64<byte> value)
{
  return AdvSimd.AddPairwiseWideningAndAdd(addend, value);
}
// addend = <11, 12, 13, 14>
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// Result = <34, 39, 44, 49>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<int> AddPairwiseWideningAndAdd(Vector64<int> addend, Vector64<short> value)
Vector64<short> AddPairwiseWideningAndAdd(Vector64<short> addend, Vector64<sbyte> value)
Vector64<uint> AddPairwiseWideningAndAdd(Vector64<uint> addend, Vector64<ushort> value)
Vector128<ushort> AddPairwiseWideningAndAdd(Vector128<ushort> addend, Vector128<byte> value)
Vector128<int> AddPairwiseWideningAndAdd(Vector128<int> addend, Vector128<short> value)
Vector128<long> AddPairwiseWideningAndAdd(Vector128<long> addend, Vector128<int> value)
Vector128<short> AddPairwiseWideningAndAdd(Vector128<short> addend, Vector128<sbyte> value)
Vector128<uint> AddPairwiseWideningAndAdd(Vector128<uint> addend, Vector128<ushort> value)
Vector128<ulong> AddPairwiseWideningAndAdd(Vector128<ulong> addend, Vector128<uint> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.addpairwisewideningandadd?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:AddPairwiseWideningAndAddTest(System.Runtime.Intrinsics.Vector64`1[UInt16],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[UInt16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M57320_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M57320_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            uadalp  v16.4h, v17.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M57320_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=75222017) for method AdvSimdMethods:AddPairwiseWideningAndAddTest(System.Runtime.Intrinsics.Vector64`1[UInt16],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[UInt16]
; ============================================================


```
------------------------------------------------

### 20. AddPairwiseWideningAndAddScalar

`Vector64<long> AddPairwiseWideningAndAddScalar(Vector64<long> addend, Vector64<int> value)`

Performs 'AddPairwiseWideningAndAddScalar' operation.

```csharp
private Vector64<long> AddPairwiseWideningAndAddScalarTest(Vector64<long> addend, Vector64<int> value)
{
  return AdvSimd.AddPairwiseWideningAndAddScalar(addend, value);
}
// addend = <11>
// value = <11, 12>
// Result = <34>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<ulong> AddPairwiseWideningAndAddScalar(Vector64<ulong> addend, Vector64<uint> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.addpairwisewideningandaddscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:AddPairwiseWideningAndAddScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int32]):System.Runtime.Intrinsics.Vector64`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M44510_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M44510_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            sadalp  v16.1d, v17.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M44510_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=bc3d5221) for method AdvSimdMethods:AddPairwiseWideningAndAddScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int32]):System.Runtime.Intrinsics.Vector64`1[Int64]
; ============================================================


```
------------------------------------------------

### 21. AddPairwiseWideningScalar

`Vector64<long> AddPairwiseWideningScalar(Vector64<int> value)`

Performs 'AddPairwiseWideningScalar' operation.

```csharp
private Vector64<long> AddPairwiseWideningScalarTest(Vector64<int> value)
{
  return AdvSimd.AddPairwiseWideningScalar(value);
}
// value = <11, 12>
// Result = <23>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<ulong> AddPairwiseWideningScalar(Vector64<uint> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.addpairwisewideningscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:AddPairwiseWideningScalarTest(System.Runtime.Intrinsics.Vector64`1[Int32]):System.Runtime.Intrinsics.Vector64`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M42814_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M42814_IG02:
            ldr     d16, [fp,#24]
            saddlp  v16.1d, v16.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 4.50
G_M42814_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 12.20, (MethodHash=7ab358c1) for method AdvSimdMethods:AddPairwiseWideningScalarTest(System.Runtime.Intrinsics.Vector64`1[Int32]):System.Runtime.Intrinsics.Vector64`1[Int64]
; ============================================================


```
------------------------------------------------

### 22. AddRoundedHighNarrowingLower

`Vector64<byte> AddRoundedHighNarrowingLower(Vector128<ushort> left, Vector128<ushort> right)`

Performs 'AddRoundedHighNarrowingLower' operation.

```csharp
private Vector64<byte> AddRoundedHighNarrowingLowerTest(Vector128<ushort> left, Vector128<ushort> right)
{
  return AdvSimd.AddRoundedHighNarrowingLower(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <11, 12, 13, 14, 15, 16, 17, 18>
// Result = <0, 0, 0, 0, 0, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> AddRoundedHighNarrowingLower(Vector128<int> left, Vector128<int> right)
Vector64<int> AddRoundedHighNarrowingLower(Vector128<long> left, Vector128<long> right)
Vector64<sbyte> AddRoundedHighNarrowingLower(Vector128<short> left, Vector128<short> right)
Vector64<ushort> AddRoundedHighNarrowingLower(Vector128<uint> left, Vector128<uint> right)
Vector64<uint> AddRoundedHighNarrowingLower(Vector128<ulong> left, Vector128<ulong> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.addroundedhighnarrowinglower?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:AddRoundedHighNarrowingLowerTest(System.Runtime.Intrinsics.Vector128`1[UInt16],System.Runtime.Intrinsics.Vector128`1[UInt16]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M65448_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     q0, [fp,#32]
            str     q1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M65448_IG02:
            ldr     q16, [fp,#32]
            ldr     q17, [fp,#16]
            raddhn  v16.8b, v16.8h, v17.8h
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M65448_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=ce5d0057) for method AdvSimdMethods:AddRoundedHighNarrowingLowerTest(System.Runtime.Intrinsics.Vector128`1[UInt16],System.Runtime.Intrinsics.Vector128`1[UInt16]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 23. AddRoundedHighNarrowingUpper

`Vector128<byte> AddRoundedHighNarrowingUpper(Vector64<byte> lower, Vector128<ushort> left, Vector128<ushort> right)`

Performs 'AddRoundedHighNarrowingUpper' operation.

```csharp
private Vector128<byte> AddRoundedHighNarrowingUpperTest(Vector64<byte> lower, Vector128<ushort> left, Vector128<ushort> right)
{
  return AdvSimd.AddRoundedHighNarrowingUpper(lower, left, right);
}
// lower = <11, 12, 13, 14, 15, 16, 17, 18>
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <11, 12, 13, 14, 15, 16, 17, 18>
// Result = <11, 12, 13, 14, 15, 16, 17, 18, 0, 0, 0, 0, 0, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<short> AddRoundedHighNarrowingUpper(Vector64<short> lower, Vector128<int> left, Vector128<int> right)
Vector128<int> AddRoundedHighNarrowingUpper(Vector64<int> lower, Vector128<long> left, Vector128<long> right)
Vector128<sbyte> AddRoundedHighNarrowingUpper(Vector64<sbyte> lower, Vector128<short> left, Vector128<short> right)
Vector128<ushort> AddRoundedHighNarrowingUpper(Vector64<ushort> lower, Vector128<uint> left, Vector128<uint> right)
Vector128<uint> AddRoundedHighNarrowingUpper(Vector64<uint> lower, Vector128<ulong> left, Vector128<ulong> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.addroundedhighnarrowingupper?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:AddRoundedHighNarrowingUpperTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[UInt16],System.Runtime.Intrinsics.Vector128`1[UInt16]):System.Runtime.Intrinsics.Vector128`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x38]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 48

G_M24353_IG01:
            stp     fp, lr, [sp,#-64]!
            mov     fp, sp
            str     d0, [fp,#56]
            str     q1, [fp,#32]
            str     q2, [fp,#16]
						;; bbWeight=1    PerfScore 4.50
G_M24353_IG02:
            ldr     d16, [fp,#56]
            ldr     q17, [fp,#32]
            ldr     q18, [fp,#16]
            raddhn2 v16.16b, v17.8h, v18.8h
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 9.50
G_M24353_IG03:
            ldp     fp, lr, [sp],#64
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 20.80, (MethodHash=cb76a0de) for method AdvSimdMethods:AddRoundedHighNarrowingUpperTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[UInt16],System.Runtime.Intrinsics.Vector128`1[UInt16]):System.Runtime.Intrinsics.Vector128`1[Byte]
; ============================================================


```
------------------------------------------------

### 24. AddSaturate

`Vector64<byte> AddSaturate(Vector64<byte> left, Vector64<byte> right)`

Performs 'AddSaturate' operation.

```csharp
private Vector64<byte> AddSaturateTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.AddSaturate(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <32, 34, 36, 38, 40, 42, 44, 46>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> AddSaturate(Vector64<short> left, Vector64<short> right)
Vector64<int> AddSaturate(Vector64<int> left, Vector64<int> right)
Vector64<sbyte> AddSaturate(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<ushort> AddSaturate(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> AddSaturate(Vector64<uint> left, Vector64<uint> right)
Vector128<byte> AddSaturate(Vector128<byte> left, Vector128<byte> right)
Vector128<short> AddSaturate(Vector128<short> left, Vector128<short> right)
Vector128<int> AddSaturate(Vector128<int> left, Vector128<int> right)
Vector128<long> AddSaturate(Vector128<long> left, Vector128<long> right)
Vector128<sbyte> AddSaturate(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<ushort> AddSaturate(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> AddSaturate(Vector128<uint> left, Vector128<uint> right)
Vector128<ulong> AddSaturate(Vector128<ulong> left, Vector128<ulong> right)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<byte> AddSaturate(Vector64<byte> left, Vector64<sbyte> right)
Vector64<short> AddSaturate(Vector64<short> left, Vector64<ushort> right)
Vector64<int> AddSaturate(Vector64<int> left, Vector64<uint> right)
Vector64<sbyte> AddSaturate(Vector64<sbyte> left, Vector64<byte> right)
Vector64<ushort> AddSaturate(Vector64<ushort> left, Vector64<short> right)
Vector64<uint> AddSaturate(Vector64<uint> left, Vector64<int> right)
Vector128<byte> AddSaturate(Vector128<byte> left, Vector128<sbyte> right)
Vector128<short> AddSaturate(Vector128<short> left, Vector128<ushort> right)
Vector128<int> AddSaturate(Vector128<int> left, Vector128<uint> right)
Vector128<long> AddSaturate(Vector128<long> left, Vector128<ulong> right)
Vector128<sbyte> AddSaturate(Vector128<sbyte> left, Vector128<byte> right)
Vector128<ushort> AddSaturate(Vector128<ushort> left, Vector128<short> right)
Vector128<uint> AddSaturate(Vector128<uint> left, Vector128<int> right)
Vector128<ulong> AddSaturate(Vector128<ulong> left, Vector128<long> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.addsaturate?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.addsaturate?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:AddSaturateTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M31904_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M31904_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            uqadd   v16.8b, v16.8b, v17.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 6.50
G_M31904_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 16.00, (MethodHash=f62a835f) for method AdvSimdMethods:AddSaturateTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 25. AddSaturateScalar

`Vector64<long> AddSaturateScalar(Vector64<long> left, Vector64<long> right)`

Performs 'AddSaturateScalar' operation.

```csharp
private Vector64<long> AddSaturateScalarTest(Vector64<long> left, Vector64<long> right)
{
  return AdvSimd.AddSaturateScalar(left, right);
}
// left = <11>
// right = <11>
// Result = <22>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<ulong> AddSaturateScalar(Vector64<ulong> left, Vector64<ulong> right)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<byte> AddSaturateScalar(Vector64<byte> left, Vector64<byte> right)
Vector64<byte> AddSaturateScalar(Vector64<byte> left, Vector64<sbyte> right)
Vector64<short> AddSaturateScalar(Vector64<short> left, Vector64<short> right)
Vector64<short> AddSaturateScalar(Vector64<short> left, Vector64<ushort> right)
Vector64<int> AddSaturateScalar(Vector64<int> left, Vector64<int> right)
Vector64<int> AddSaturateScalar(Vector64<int> left, Vector64<uint> right)
Vector64<long> AddSaturateScalar(Vector64<long> left, Vector64<ulong> right)
Vector64<sbyte> AddSaturateScalar(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<sbyte> AddSaturateScalar(Vector64<sbyte> left, Vector64<byte> right)
Vector64<ushort> AddSaturateScalar(Vector64<ushort> left, Vector64<ushort> right)
Vector64<ushort> AddSaturateScalar(Vector64<ushort> left, Vector64<short> right)
Vector64<uint> AddSaturateScalar(Vector64<uint> left, Vector64<uint> right)
Vector64<uint> AddSaturateScalar(Vector64<uint> left, Vector64<int> right)
Vector64<ulong> AddSaturateScalar(Vector64<ulong> left, Vector64<long> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.addsaturatescalar?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.addsaturatescalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:AddSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64]):System.Runtime.Intrinsics.Vector64`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M25813_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M25813_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            sqadd   d16, d16, d17
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M25813_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=6c779b2a) for method AdvSimdMethods:AddSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64]):System.Runtime.Intrinsics.Vector64`1[Int64]
; ============================================================


```
------------------------------------------------

### 26. AddScalar

`Vector64<double> AddScalar(Vector64<double> left, Vector64<double> right)`

Performs 'AddScalar' operation.

```csharp
private Vector64<double> AddScalarTest(Vector64<double> left, Vector64<double> right)
{
  return AdvSimd.AddScalar(left, right);
}
// left = <11.5>
// right = <11.5>
// Result = <23>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<long> AddScalar(Vector64<long> left, Vector64<long> right)
Vector64<float> AddScalar(Vector64<float> left, Vector64<float> right)
Vector64<ulong> AddScalar(Vector64<ulong> left, Vector64<ulong> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.addscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:AddScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M19584_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M19584_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            fadd    d16, d16, d17
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M19584_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=a1f2b37f) for method AdvSimdMethods:AddScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 27. AddWideningLower

`Vector128<ushort> AddWideningLower(Vector64<byte> left, Vector64<byte> right)`

Performs 'AddWideningLower' operation.

```csharp
private Vector128<ushort> AddWideningLowerTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.AddWideningLower(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <32, 34, 36, 38, 40, 42, 44, 46>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<int> AddWideningLower(Vector64<short> left, Vector64<short> right)
Vector128<long> AddWideningLower(Vector64<int> left, Vector64<int> right)
Vector128<short> AddWideningLower(Vector64<sbyte> left, Vector64<sbyte> right)
Vector128<uint> AddWideningLower(Vector64<ushort> left, Vector64<ushort> right)
Vector128<ulong> AddWideningLower(Vector64<uint> left, Vector64<uint> right)
Vector128<short> AddWideningLower(Vector128<short> left, Vector64<sbyte> right)
Vector128<int> AddWideningLower(Vector128<int> left, Vector64<short> right)
Vector128<long> AddWideningLower(Vector128<long> left, Vector64<int> right)
Vector128<ushort> AddWideningLower(Vector128<ushort> left, Vector64<byte> right)
Vector128<uint> AddWideningLower(Vector128<uint> left, Vector64<ushort> right)
Vector128<ulong> AddWideningLower(Vector128<ulong> left, Vector64<uint> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.addwideninglower?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:AddWideningLowerTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector128`1[UInt16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M26129_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M26129_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            uaddl   v16.8h, v16.8b, v17.8b
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 6.50
G_M26129_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 16.00, (MethodHash=77e099ee) for method AdvSimdMethods:AddWideningLowerTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector128`1[UInt16]
; ============================================================


```
------------------------------------------------

### 28. AddWideningUpper

`Vector128<ushort> AddWideningUpper(Vector128<byte> left, Vector128<byte> right)`

Performs 'AddWideningUpper' operation.

```csharp
private Vector128<ushort> AddWideningUpperTest(Vector128<byte> left, Vector128<byte> right)
{
  return AdvSimd.AddWideningUpper(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26>
// right = <21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36>
// Result = <48, 50, 52, 54, 56, 58, 60, 62>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<int> AddWideningUpper(Vector128<short> left, Vector128<short> right)
Vector128<short> AddWideningUpper(Vector128<short> left, Vector128<sbyte> right)
Vector128<int> AddWideningUpper(Vector128<int> left, Vector128<short> right)
Vector128<long> AddWideningUpper(Vector128<int> left, Vector128<int> right)
Vector128<long> AddWideningUpper(Vector128<long> left, Vector128<int> right)
Vector128<short> AddWideningUpper(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<ushort> AddWideningUpper(Vector128<ushort> left, Vector128<byte> right)
Vector128<uint> AddWideningUpper(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> AddWideningUpper(Vector128<uint> left, Vector128<ushort> right)
Vector128<ulong> AddWideningUpper(Vector128<uint> left, Vector128<uint> right)
Vector128<ulong> AddWideningUpper(Vector128<ulong> left, Vector128<uint> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.addwideningupper?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:AddWideningUpperTest(System.Runtime.Intrinsics.Vector128`1[Byte],System.Runtime.Intrinsics.Vector128`1[Byte]):System.Runtime.Intrinsics.Vector128`1[UInt16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M32432_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     q0, [fp,#32]
            str     q1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M32432_IG02:
            ldr     q16, [fp,#32]
            ldr     q17, [fp,#16]
            uaddl2  v16.8h, v16.16b, v17.16b
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 6.50
G_M32432_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 16.00, (MethodHash=e5a8814f) for method AdvSimdMethods:AddWideningUpperTest(System.Runtime.Intrinsics.Vector128`1[Byte],System.Runtime.Intrinsics.Vector128`1[Byte]):System.Runtime.Intrinsics.Vector128`1[UInt16]
; ============================================================


```
------------------------------------------------

### 29. And

`Vector64<byte> And(Vector64<byte> left, Vector64<byte> right)`

Performs 'And' operation.

```csharp
private Vector64<byte> AndTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.And(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <1, 4, 5, 8, 9, 16, 17, 16>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<double> And(Vector64<double> left, Vector64<double> right)
Vector64<short> And(Vector64<short> left, Vector64<short> right)
Vector64<int> And(Vector64<int> left, Vector64<int> right)
Vector64<long> And(Vector64<long> left, Vector64<long> right)
Vector64<sbyte> And(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<float> And(Vector64<float> left, Vector64<float> right)
Vector64<ushort> And(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> And(Vector64<uint> left, Vector64<uint> right)
Vector64<ulong> And(Vector64<ulong> left, Vector64<ulong> right)
Vector128<byte> And(Vector128<byte> left, Vector128<byte> right)
Vector128<double> And(Vector128<double> left, Vector128<double> right)
Vector128<short> And(Vector128<short> left, Vector128<short> right)
Vector128<int> And(Vector128<int> left, Vector128<int> right)
Vector128<long> And(Vector128<long> left, Vector128<long> right)
Vector128<sbyte> And(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<float> And(Vector128<float> left, Vector128<float> right)
Vector128<ushort> And(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> And(Vector128<uint> left, Vector128<uint> right)
Vector128<ulong> And(Vector128<ulong> left, Vector128<ulong> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.and?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:AndTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M59707_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M59707_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            and     v16.8b, v16.8b, v17.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.00
G_M59707_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 14.50, (MethodHash=01b516c4) for method AdvSimdMethods:AndTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 30. BitwiseClear

`Vector64<byte> BitwiseClear(Vector64<byte> value, Vector64<byte> mask)`

Performs 'BitwiseClear' operation.

```csharp
private Vector64<byte> BitwiseClearTest(Vector64<byte> value, Vector64<byte> mask)
{
  return AdvSimd.BitwiseClear(value, mask);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// mask = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <10, 8, 8, 6, 6, 0, 0, 2>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<double> BitwiseClear(Vector64<double> value, Vector64<double> mask)
Vector64<short> BitwiseClear(Vector64<short> value, Vector64<short> mask)
Vector64<int> BitwiseClear(Vector64<int> value, Vector64<int> mask)
Vector64<long> BitwiseClear(Vector64<long> value, Vector64<long> mask)
Vector64<sbyte> BitwiseClear(Vector64<sbyte> value, Vector64<sbyte> mask)
Vector64<float> BitwiseClear(Vector64<float> value, Vector64<float> mask)
Vector64<ushort> BitwiseClear(Vector64<ushort> value, Vector64<ushort> mask)
Vector64<uint> BitwiseClear(Vector64<uint> value, Vector64<uint> mask)
Vector64<ulong> BitwiseClear(Vector64<ulong> value, Vector64<ulong> mask)
Vector128<byte> BitwiseClear(Vector128<byte> value, Vector128<byte> mask)
Vector128<double> BitwiseClear(Vector128<double> value, Vector128<double> mask)
Vector128<short> BitwiseClear(Vector128<short> value, Vector128<short> mask)
Vector128<int> BitwiseClear(Vector128<int> value, Vector128<int> mask)
Vector128<long> BitwiseClear(Vector128<long> value, Vector128<long> mask)
Vector128<sbyte> BitwiseClear(Vector128<sbyte> value, Vector128<sbyte> mask)
Vector128<float> BitwiseClear(Vector128<float> value, Vector128<float> mask)
Vector128<ushort> BitwiseClear(Vector128<ushort> value, Vector128<ushort> mask)
Vector128<uint> BitwiseClear(Vector128<uint> value, Vector128<uint> mask)
Vector128<ulong> BitwiseClear(Vector128<ulong> value, Vector128<ulong> mask)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.bitwiseclear?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:BitwiseClearTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M46334_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M46334_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            bic     v16.8b, v16.8b, v17.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.00
G_M46334_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 14.50, (MethodHash=29884b01) for method AdvSimdMethods:BitwiseClearTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 31. BitwiseSelect

`Vector64<byte> BitwiseSelect(Vector64<byte> select, Vector64<byte> left, Vector64<byte> right)`

Performs 'BitwiseSelect' operation.

```csharp
private Vector64<byte> BitwiseSelectTest(Vector64<byte> select, Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.BitwiseSelect(select, left, right);
}
// select = <11, 12, 13, 14, 15, 16, 17, 18>
// left = <21, 22, 23, 24, 25, 26, 27, 28>
// right = <31, 32, 33, 34, 35, 36, 37, 38>
// Result = <21, 36, 37, 40, 41, 52, 53, 52>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<double> BitwiseSelect(Vector64<double> select, Vector64<double> left, Vector64<double> right)
Vector64<short> BitwiseSelect(Vector64<short> select, Vector64<short> left, Vector64<short> right)
Vector64<int> BitwiseSelect(Vector64<int> select, Vector64<int> left, Vector64<int> right)
Vector64<long> BitwiseSelect(Vector64<long> select, Vector64<long> left, Vector64<long> right)
Vector64<sbyte> BitwiseSelect(Vector64<sbyte> select, Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<float> BitwiseSelect(Vector64<float> select, Vector64<float> left, Vector64<float> right)
Vector64<ushort> BitwiseSelect(Vector64<ushort> select, Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> BitwiseSelect(Vector64<uint> select, Vector64<uint> left, Vector64<uint> right)
Vector64<ulong> BitwiseSelect(Vector64<ulong> select, Vector64<ulong> left, Vector64<ulong> right)
Vector128<byte> BitwiseSelect(Vector128<byte> select, Vector128<byte> left, Vector128<byte> right)
Vector128<double> BitwiseSelect(Vector128<double> select, Vector128<double> left, Vector128<double> right)
Vector128<short> BitwiseSelect(Vector128<short> select, Vector128<short> left, Vector128<short> right)
Vector128<int> BitwiseSelect(Vector128<int> select, Vector128<int> left, Vector128<int> right)
Vector128<long> BitwiseSelect(Vector128<long> select, Vector128<long> left, Vector128<long> right)
Vector128<sbyte> BitwiseSelect(Vector128<sbyte> select, Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<float> BitwiseSelect(Vector128<float> select, Vector128<float> left, Vector128<float> right)
Vector128<ushort> BitwiseSelect(Vector128<ushort> select, Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> BitwiseSelect(Vector128<uint> select, Vector128<uint> left, Vector128<uint> right)
Vector128<ulong> BitwiseSelect(Vector128<ulong> select, Vector128<ulong> left, Vector128<ulong> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.bitwiseselect?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:BitwiseSelectTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x20]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M12542_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     d1, [fp,#32]
            str     d2, [fp,#24]
						;; bbWeight=1    PerfScore 4.50
G_M12542_IG02:
            ldr     d16, [fp,#40]
            ldr     d17, [fp,#32]
            ldr     d18, [fp,#24]
            bsl     v16.8b, v17.8b, v18.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.00
G_M12542_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 18.30, (MethodHash=e023cf01) for method AdvSimdMethods:BitwiseSelectTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 32. Ceiling

`Vector64<float> Ceiling(Vector64<float> value)`

Performs 'Ceiling' operation.

```csharp
private Vector64<float> CeilingTest(Vector64<float> value)
{
  return AdvSimd.Ceiling(value);
}
// value = <11.5, 12.5>
// Result = <12, 13>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<float> Ceiling(Vector128<float> value)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> Ceiling(Vector128<double> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.ceiling?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.ceiling?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:CeilingTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M42466_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M42466_IG02:
            ldr     d16, [fp,#24]
            frintp  v16.2s, v16.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M42466_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=3f635a1d) for method AdvSimdMethods:CeilingTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 33. CeilingScalar

`Vector64<double> CeilingScalar(Vector64<double> value)`

Performs 'CeilingScalar' operation.

```csharp
private Vector64<double> CeilingScalarTest(Vector64<double> value)
{
  return AdvSimd.CeilingScalar(value);
}
// value = <11.5>
// Result = <12>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<float> CeilingScalar(Vector64<float> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.ceilingscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:CeilingScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M42092_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M42092_IG02:
            ldr     d16, [fp,#24]
            frintp  d16, d16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 4.50
G_M42092_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 12.20, (MethodHash=fa585b93) for method AdvSimdMethods:CeilingScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 34. CompareEqual

`Vector64<byte> CompareEqual(Vector64<byte> left, Vector64<byte> right)`

Performs 'CompareEqual' operation.

```csharp
private Vector64<byte> CompareEqualTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.CompareEqual(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <0, 0, 0, 0, 0, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> CompareEqual(Vector64<short> left, Vector64<short> right)
Vector64<int> CompareEqual(Vector64<int> left, Vector64<int> right)
Vector64<sbyte> CompareEqual(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<float> CompareEqual(Vector64<float> left, Vector64<float> right)
Vector64<ushort> CompareEqual(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> CompareEqual(Vector64<uint> left, Vector64<uint> right)
Vector128<byte> CompareEqual(Vector128<byte> left, Vector128<byte> right)
Vector128<short> CompareEqual(Vector128<short> left, Vector128<short> right)
Vector128<int> CompareEqual(Vector128<int> left, Vector128<int> right)
Vector128<sbyte> CompareEqual(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<float> CompareEqual(Vector128<float> left, Vector128<float> right)
Vector128<ushort> CompareEqual(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> CompareEqual(Vector128<uint> left, Vector128<uint> right)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> CompareEqual(Vector128<double> left, Vector128<double> right)
Vector128<long> CompareEqual(Vector128<long> left, Vector128<long> right)
Vector128<ulong> CompareEqual(Vector128<ulong> left, Vector128<ulong> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.compareequal?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.compareequal?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:CompareEqualTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M34203_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M34203_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            cmeq    v16.8b, v16.8b, v17.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M34203_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=2b4a7a64) for method AdvSimdMethods:CompareEqualTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 35. CompareGreaterThan

`Vector64<byte> CompareGreaterThan(Vector64<byte> left, Vector64<byte> right)`

Performs 'CompareGreaterThan' operation.

```csharp
private Vector64<byte> CompareGreaterThanTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.CompareGreaterThan(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <0, 0, 0, 0, 0, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> CompareGreaterThan(Vector64<short> left, Vector64<short> right)
Vector64<int> CompareGreaterThan(Vector64<int> left, Vector64<int> right)
Vector64<sbyte> CompareGreaterThan(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<float> CompareGreaterThan(Vector64<float> left, Vector64<float> right)
Vector64<ushort> CompareGreaterThan(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> CompareGreaterThan(Vector64<uint> left, Vector64<uint> right)
Vector128<byte> CompareGreaterThan(Vector128<byte> left, Vector128<byte> right)
Vector128<short> CompareGreaterThan(Vector128<short> left, Vector128<short> right)
Vector128<int> CompareGreaterThan(Vector128<int> left, Vector128<int> right)
Vector128<sbyte> CompareGreaterThan(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<float> CompareGreaterThan(Vector128<float> left, Vector128<float> right)
Vector128<ushort> CompareGreaterThan(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> CompareGreaterThan(Vector128<uint> left, Vector128<uint> right)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> CompareGreaterThan(Vector128<double> left, Vector128<double> right)
Vector128<long> CompareGreaterThan(Vector128<long> left, Vector128<long> right)
Vector128<ulong> CompareGreaterThan(Vector128<ulong> left, Vector128<ulong> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.comparegreaterthan?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.comparegreaterthan?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:CompareGreaterThanTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M1302_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M1302_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            cmhi    v16.8b, v16.8b, v17.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M1302_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=eab9fae9) for method AdvSimdMethods:CompareGreaterThanTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 36. CompareGreaterThanOrEqual

`Vector64<byte> CompareGreaterThanOrEqual(Vector64<byte> left, Vector64<byte> right)`

Performs 'CompareGreaterThanOrEqual' operation.

```csharp
private Vector64<byte> CompareGreaterThanOrEqualTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.CompareGreaterThanOrEqual(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <0, 0, 0, 0, 0, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> CompareGreaterThanOrEqual(Vector64<short> left, Vector64<short> right)
Vector64<int> CompareGreaterThanOrEqual(Vector64<int> left, Vector64<int> right)
Vector64<sbyte> CompareGreaterThanOrEqual(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<float> CompareGreaterThanOrEqual(Vector64<float> left, Vector64<float> right)
Vector64<ushort> CompareGreaterThanOrEqual(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> CompareGreaterThanOrEqual(Vector64<uint> left, Vector64<uint> right)
Vector128<byte> CompareGreaterThanOrEqual(Vector128<byte> left, Vector128<byte> right)
Vector128<short> CompareGreaterThanOrEqual(Vector128<short> left, Vector128<short> right)
Vector128<int> CompareGreaterThanOrEqual(Vector128<int> left, Vector128<int> right)
Vector128<sbyte> CompareGreaterThanOrEqual(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<float> CompareGreaterThanOrEqual(Vector128<float> left, Vector128<float> right)
Vector128<ushort> CompareGreaterThanOrEqual(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> CompareGreaterThanOrEqual(Vector128<uint> left, Vector128<uint> right)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> CompareGreaterThanOrEqual(Vector128<double> left, Vector128<double> right)
Vector128<long> CompareGreaterThanOrEqual(Vector128<long> left, Vector128<long> right)
Vector128<ulong> CompareGreaterThanOrEqual(Vector128<ulong> left, Vector128<ulong> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.comparegreaterthanorequal?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.comparegreaterthanorequal?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:CompareGreaterThanOrEqualTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M12615_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M12615_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            cmhs    v16.8b, v16.8b, v17.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M12615_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=b629ceb8) for method AdvSimdMethods:CompareGreaterThanOrEqualTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 37. CompareLessThan

`Vector64<byte> CompareLessThan(Vector64<byte> left, Vector64<byte> right)`

Performs 'CompareLessThan' operation.

```csharp
private Vector64<byte> CompareLessThanTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.CompareLessThan(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <255, 255, 255, 255, 255, 255, 255, 255>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> CompareLessThan(Vector64<short> left, Vector64<short> right)
Vector64<int> CompareLessThan(Vector64<int> left, Vector64<int> right)
Vector64<sbyte> CompareLessThan(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<float> CompareLessThan(Vector64<float> left, Vector64<float> right)
Vector64<ushort> CompareLessThan(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> CompareLessThan(Vector64<uint> left, Vector64<uint> right)
Vector128<byte> CompareLessThan(Vector128<byte> left, Vector128<byte> right)
Vector128<short> CompareLessThan(Vector128<short> left, Vector128<short> right)
Vector128<int> CompareLessThan(Vector128<int> left, Vector128<int> right)
Vector128<sbyte> CompareLessThan(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<float> CompareLessThan(Vector128<float> left, Vector128<float> right)
Vector128<ushort> CompareLessThan(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> CompareLessThan(Vector128<uint> left, Vector128<uint> right)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> CompareLessThan(Vector128<double> left, Vector128<double> right)
Vector128<long> CompareLessThan(Vector128<long> left, Vector128<long> right)
Vector128<ulong> CompareLessThan(Vector128<ulong> left, Vector128<ulong> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.comparelessthan?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.comparelessthan?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:CompareLessThanTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M55053_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M55053_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            cmhi    v16.8b, v17.8b, v16.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M55053_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=0e2f28f2) for method AdvSimdMethods:CompareLessThanTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 38. CompareLessThanOrEqual

`Vector64<byte> CompareLessThanOrEqual(Vector64<byte> left, Vector64<byte> right)`

Performs 'CompareLessThanOrEqual' operation.

```csharp
private Vector64<byte> CompareLessThanOrEqualTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.CompareLessThanOrEqual(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <255, 255, 255, 255, 255, 255, 255, 255>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> CompareLessThanOrEqual(Vector64<short> left, Vector64<short> right)
Vector64<int> CompareLessThanOrEqual(Vector64<int> left, Vector64<int> right)
Vector64<sbyte> CompareLessThanOrEqual(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<float> CompareLessThanOrEqual(Vector64<float> left, Vector64<float> right)
Vector64<ushort> CompareLessThanOrEqual(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> CompareLessThanOrEqual(Vector64<uint> left, Vector64<uint> right)
Vector128<byte> CompareLessThanOrEqual(Vector128<byte> left, Vector128<byte> right)
Vector128<short> CompareLessThanOrEqual(Vector128<short> left, Vector128<short> right)
Vector128<int> CompareLessThanOrEqual(Vector128<int> left, Vector128<int> right)
Vector128<sbyte> CompareLessThanOrEqual(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<float> CompareLessThanOrEqual(Vector128<float> left, Vector128<float> right)
Vector128<ushort> CompareLessThanOrEqual(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> CompareLessThanOrEqual(Vector128<uint> left, Vector128<uint> right)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> CompareLessThanOrEqual(Vector128<double> left, Vector128<double> right)
Vector128<long> CompareLessThanOrEqual(Vector128<long> left, Vector128<long> right)
Vector128<ulong> CompareLessThanOrEqual(Vector128<ulong> left, Vector128<ulong> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.comparelessthanorequal?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.comparelessthanorequal?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:CompareLessThanOrEqualTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M37756_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M37756_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            cmhs    v16.8b, v17.8b, v16.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M37756_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=d1a96c83) for method AdvSimdMethods:CompareLessThanOrEqualTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 39. CompareTest

`Vector64<byte> CompareTest(Vector64<byte> left, Vector64<byte> right)`

Performs 'CompareTest' operation.

```csharp
private Vector64<byte> CompareTestTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.CompareTest(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <255, 255, 255, 255, 255, 255, 255, 255>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> CompareTest(Vector64<short> left, Vector64<short> right)
Vector64<int> CompareTest(Vector64<int> left, Vector64<int> right)
Vector64<sbyte> CompareTest(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<float> CompareTest(Vector64<float> left, Vector64<float> right)
Vector64<ushort> CompareTest(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> CompareTest(Vector64<uint> left, Vector64<uint> right)
Vector128<byte> CompareTest(Vector128<byte> left, Vector128<byte> right)
Vector128<short> CompareTest(Vector128<short> left, Vector128<short> right)
Vector128<int> CompareTest(Vector128<int> left, Vector128<int> right)
Vector128<sbyte> CompareTest(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<float> CompareTest(Vector128<float> left, Vector128<float> right)
Vector128<ushort> CompareTest(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> CompareTest(Vector128<uint> left, Vector128<uint> right)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> CompareTest(Vector128<double> left, Vector128<double> right)
Vector128<long> CompareTest(Vector128<long> left, Vector128<long> right)
Vector128<ulong> CompareTest(Vector128<ulong> left, Vector128<ulong> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.comparetest?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.comparetest?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:CompareTestTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M30849_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M30849_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            cmtst   v16.8b, v16.8b, v17.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 6.50
G_M30849_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 16.00, (MethodHash=3449877e) for method AdvSimdMethods:CompareTestTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 40. ConvertToInt32RoundAwayFromZero

`Vector64<int> ConvertToInt32RoundAwayFromZero(Vector64<float> value)`

Performs 'ConvertToInt32RoundAwayFromZero' operation.

```csharp
private Vector64<int> ConvertToInt32RoundAwayFromZeroTest(Vector64<float> value)
{
  return AdvSimd.ConvertToInt32RoundAwayFromZero(value);
}
// value = <11.5, 12.5>
// Result = <12, 13>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<int> ConvertToInt32RoundAwayFromZero(Vector128<float> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.converttoint32roundawayfromzero?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ConvertToInt32RoundAwayFromZeroTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M48559_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M48559_IG02:
            ldr     d16, [fp,#24]
            fcvtas  v16.2s, v16.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M48559_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=2df04250) for method AdvSimdMethods:ConvertToInt32RoundAwayFromZeroTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Int32]
; ============================================================


```
------------------------------------------------

### 41. ConvertToInt32RoundAwayFromZeroScalar

`Vector64<int> ConvertToInt32RoundAwayFromZeroScalar(Vector64<float> value)`

Performs 'ConvertToInt32RoundAwayFromZeroScalar' operation.

```csharp
private Vector64<int> ConvertToInt32RoundAwayFromZeroScalarTest(Vector64<float> value)
{
  return AdvSimd.ConvertToInt32RoundAwayFromZeroScalar(value);
}
// value = <11.5, 12.5>
// Result = <12, 0>

```



See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.converttoint32roundawayfromzeroscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ConvertToInt32RoundAwayFromZeroScalarTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M34209_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M34209_IG02:
            ldr     d16, [fp,#24]
            fcvtas  s16, s16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 4.50
G_M34209_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 12.20, (MethodHash=ee937a5e) for method AdvSimdMethods:ConvertToInt32RoundAwayFromZeroScalarTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Int32]
; ============================================================


```
------------------------------------------------

### 42. ConvertToInt32RoundToEven

`Vector64<int> ConvertToInt32RoundToEven(Vector64<float> value)`

Performs 'ConvertToInt32RoundToEven' operation.

```csharp
private Vector64<int> ConvertToInt32RoundToEvenTest(Vector64<float> value)
{
  return AdvSimd.ConvertToInt32RoundToEven(value);
}
// value = <11.5, 12.5>
// Result = <12, 12>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<int> ConvertToInt32RoundToEven(Vector128<float> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.converttoint32roundtoeven?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ConvertToInt32RoundToEvenTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M45494_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M45494_IG02:
            ldr     d16, [fp,#24]
            fcvtns  v16.2s, v16.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M45494_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=140e4e49) for method AdvSimdMethods:ConvertToInt32RoundToEvenTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Int32]
; ============================================================


```
------------------------------------------------

### 43. ConvertToInt32RoundToEvenScalar

`Vector64<int> ConvertToInt32RoundToEvenScalar(Vector64<float> value)`

Performs 'ConvertToInt32RoundToEvenScalar' operation.

```csharp
private Vector64<int> ConvertToInt32RoundToEvenScalarTest(Vector64<float> value)
{
  return AdvSimd.ConvertToInt32RoundToEvenScalar(value);
}
// value = <11.5, 12.5>
// Result = <12, 0>

```



See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.converttoint32roundtoevenscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ConvertToInt32RoundToEvenScalarTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M20024_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M20024_IG02:
            ldr     d16, [fp,#24]
            fcvtns  s16, s16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 4.50
G_M20024_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 12.20, (MethodHash=fff2b1c7) for method AdvSimdMethods:ConvertToInt32RoundToEvenScalarTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Int32]
; ============================================================


```
------------------------------------------------

### 44. ConvertToInt32RoundToNegativeInfinity

`Vector64<int> ConvertToInt32RoundToNegativeInfinity(Vector64<float> value)`

Performs 'ConvertToInt32RoundToNegativeInfinity' operation.

```csharp
private Vector64<int> ConvertToInt32RoundToNegativeInfinityTest(Vector64<float> value)
{
  return AdvSimd.ConvertToInt32RoundToNegativeInfinity(value);
}
// value = <11.5, 12.5>
// Result = <11, 12>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<int> ConvertToInt32RoundToNegativeInfinity(Vector128<float> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.converttoint32roundtonegativeinfinity?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ConvertToInt32RoundToNegativeInfinityTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M64271_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M64271_IG02:
            ldr     d16, [fp,#24]
            fcvtms  v16.2s, v16.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M64271_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=9f4e04f0) for method AdvSimdMethods:ConvertToInt32RoundToNegativeInfinityTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Int32]
; ============================================================


```
------------------------------------------------

### 45. ConvertToInt32RoundToNegativeInfinityScalar

`Vector64<int> ConvertToInt32RoundToNegativeInfinityScalar(Vector64<float> value)`

Performs 'ConvertToInt32RoundToNegativeInfinityScalar' operation.

```csharp
private Vector64<int> ConvertToInt32RoundToNegativeInfinityScalarTest(Vector64<float> value)
{
  return AdvSimd.ConvertToInt32RoundToNegativeInfinityScalar(value);
}
// value = <11.5, 12.5>
// Result = <11, 0>

```



See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.converttoint32roundtonegativeinfinityscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ConvertToInt32RoundToNegativeInfinityScalarTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M11201_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M11201_IG02:
            ldr     d16, [fp,#24]
            fcvtms  s16, s16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 4.50
G_M11201_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 12.20, (MethodHash=f12fd43e) for method AdvSimdMethods:ConvertToInt32RoundToNegativeInfinityScalarTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Int32]
; ============================================================


```
------------------------------------------------

### 46. ConvertToInt32RoundToPositiveInfinity

`Vector64<int> ConvertToInt32RoundToPositiveInfinity(Vector64<float> value)`

Performs 'ConvertToInt32RoundToPositiveInfinity' operation.

```csharp
private Vector64<int> ConvertToInt32RoundToPositiveInfinityTest(Vector64<float> value)
{
  return AdvSimd.ConvertToInt32RoundToPositiveInfinity(value);
}
// value = <11.5, 12.5>
// Result = <12, 13>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<int> ConvertToInt32RoundToPositiveInfinity(Vector128<float> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.converttoint32roundtopositiveinfinity?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ConvertToInt32RoundToPositiveInfinityTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M56903_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M56903_IG02:
            ldr     d16, [fp,#24]
            fcvtps  v16.2s, v16.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M56903_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=b24921b8) for method AdvSimdMethods:ConvertToInt32RoundToPositiveInfinityTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Int32]
; ============================================================


```
------------------------------------------------

### 47. ConvertToInt32RoundToPositiveInfinityScalar

`Vector64<int> ConvertToInt32RoundToPositiveInfinityScalar(Vector64<float> value)`

Performs 'ConvertToInt32RoundToPositiveInfinityScalar' operation.

```csharp
private Vector64<int> ConvertToInt32RoundToPositiveInfinityScalarTest(Vector64<float> value)
{
  return AdvSimd.ConvertToInt32RoundToPositiveInfinityScalar(value);
}
// value = <11.5, 12.5>
// Result = <12, 0>

```



See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.converttoint32roundtopositiveinfinityscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ConvertToInt32RoundToPositiveInfinityScalarTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M46345_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M46345_IG02:
            ldr     d16, [fp,#24]
            fcvtps  s16, s16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 4.50
G_M46345_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 12.20, (MethodHash=d6034af6) for method AdvSimdMethods:ConvertToInt32RoundToPositiveInfinityScalarTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Int32]
; ============================================================


```
------------------------------------------------

### 48. ConvertToInt32RoundToZero

`Vector64<int> ConvertToInt32RoundToZero(Vector64<float> value)`

Performs 'ConvertToInt32RoundToZero' operation.

```csharp
private Vector64<int> ConvertToInt32RoundToZeroTest(Vector64<float> value)
{
  return AdvSimd.ConvertToInt32RoundToZero(value);
}
// value = <11.5, 12.5>
// Result = <11, 12>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<int> ConvertToInt32RoundToZero(Vector128<float> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.converttoint32roundtozero?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ConvertToInt32RoundToZeroTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M38060_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M38060_IG02:
            ldr     d16, [fp,#24]
            fcvtzs  v16.2s, v16.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M38060_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=4ac76b53) for method AdvSimdMethods:ConvertToInt32RoundToZeroTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Int32]
; ============================================================


```
------------------------------------------------

### 49. ConvertToInt32RoundToZeroScalar

`Vector64<int> ConvertToInt32RoundToZeroScalar(Vector64<float> value)`

Performs 'ConvertToInt32RoundToZeroScalar' operation.

```csharp
private Vector64<int> ConvertToInt32RoundToZeroScalarTest(Vector64<float> value)
{
  return AdvSimd.ConvertToInt32RoundToZeroScalar(value);
}
// value = <11.5, 12.5>
// Result = <11, 0>

```



See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.converttoint32roundtozeroscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ConvertToInt32RoundToZeroScalarTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M5538_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M5538_IG02:
            ldr     d16, [fp,#24]
            fcvtzs  s16, s16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 4.50
G_M5538_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 12.20, (MethodHash=b6a2ea5d) for method AdvSimdMethods:ConvertToInt32RoundToZeroScalarTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Int32]
; ============================================================


```
------------------------------------------------

### 50. ConvertToSingle

`Vector64<float> ConvertToSingle(Vector64<int> value)`

Performs 'ConvertToSingle' operation.

```csharp
private Vector64<float> ConvertToSingleTest(Vector64<int> value)
{
  return AdvSimd.ConvertToSingle(value);
}
// value = <11, 12>
// Result = <11, 12>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<float> ConvertToSingle(Vector64<uint> value)
Vector128<float> ConvertToSingle(Vector128<int> value)
Vector128<float> ConvertToSingle(Vector128<uint> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.converttosingle?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ConvertToSingleTest(System.Runtime.Intrinsics.Vector64`1[Int32]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M61503_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M61503_IG02:
            ldr     d16, [fp,#24]
            scvtf   v16.2s, v16.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M61503_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=19560fc0) for method AdvSimdMethods:ConvertToSingleTest(System.Runtime.Intrinsics.Vector64`1[Int32]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 51. ConvertToSingleScalar

`Vector64<float> ConvertToSingleScalar(Vector64<int> value)`

Performs 'ConvertToSingleScalar' operation.

```csharp
private Vector64<float> ConvertToSingleScalarTest(Vector64<int> value)
{
  return AdvSimd.ConvertToSingleScalar(value);
}
// value = <11, 12>
// Result = <11, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<float> ConvertToSingleScalar(Vector64<uint> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.converttosinglescalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ConvertToSingleScalarTest(System.Runtime.Intrinsics.Vector64`1[Int32]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M22193_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M22193_IG02:
            ldr     d16, [fp,#24]
            scvtf   s16, s16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 4.50
G_M22193_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 12.20, (MethodHash=1d25a94e) for method AdvSimdMethods:ConvertToSingleScalarTest(System.Runtime.Intrinsics.Vector64`1[Int32]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 52. ConvertToUInt32RoundAwayFromZero

`Vector64<uint> ConvertToUInt32RoundAwayFromZero(Vector64<float> value)`

Performs 'ConvertToUInt32RoundAwayFromZero' operation.

```csharp
private Vector64<uint> ConvertToUInt32RoundAwayFromZeroTest(Vector64<float> value)
{
  return AdvSimd.ConvertToUInt32RoundAwayFromZero(value);
}
// value = <11.5, 12.5>
// Result = <12, 13>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<uint> ConvertToUInt32RoundAwayFromZero(Vector128<float> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.converttouint32roundawayfromzero?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ConvertToUInt32RoundAwayFromZeroTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[UInt32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M14031_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M14031_IG02:
            ldr     d16, [fp,#24]
            fcvtau  v16.2s, v16.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M14031_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=ac56c930) for method AdvSimdMethods:ConvertToUInt32RoundAwayFromZeroTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[UInt32]
; ============================================================


```
------------------------------------------------

### 53. ConvertToUInt32RoundAwayFromZeroScalar

`Vector64<uint> ConvertToUInt32RoundAwayFromZeroScalar(Vector64<float> value)`

Performs 'ConvertToUInt32RoundAwayFromZeroScalar' operation.

```csharp
private Vector64<uint> ConvertToUInt32RoundAwayFromZeroScalarTest(Vector64<float> value)
{
  return AdvSimd.ConvertToUInt32RoundAwayFromZeroScalar(value);
}
// value = <11.5, 12.5>
// Result = <12, 0>

```



See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.converttouint32roundawayfromzeroscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ConvertToUInt32RoundAwayFromZeroScalarTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[UInt32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M49473_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M49473_IG02:
            ldr     d16, [fp,#24]
            fcvtau  s16, s16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 4.50
G_M49473_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 12.20, (MethodHash=05593ebe) for method AdvSimdMethods:ConvertToUInt32RoundAwayFromZeroScalarTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[UInt32]
; ============================================================


```
------------------------------------------------

### 54. ConvertToUInt32RoundToEven

`Vector64<uint> ConvertToUInt32RoundToEven(Vector64<float> value)`

Performs 'ConvertToUInt32RoundToEven' operation.

```csharp
private Vector64<uint> ConvertToUInt32RoundToEvenTest(Vector64<float> value)
{
  return AdvSimd.ConvertToUInt32RoundToEven(value);
}
// value = <11.5, 12.5>
// Result = <12, 12>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<uint> ConvertToUInt32RoundToEven(Vector128<float> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.converttouint32roundtoeven?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ConvertToUInt32RoundToEvenTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[UInt32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M246_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M246_IG02:
            ldr     d16, [fp,#24]
            fcvtnu  v16.2s, v16.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M246_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=50abff09) for method AdvSimdMethods:ConvertToUInt32RoundToEvenTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[UInt32]
; ============================================================


```
------------------------------------------------

### 55. ConvertToUInt32RoundToEvenScalar

`Vector64<uint> ConvertToUInt32RoundToEvenScalar(Vector64<float> value)`

Performs 'ConvertToUInt32RoundToEvenScalar' operation.

```csharp
private Vector64<uint> ConvertToUInt32RoundToEvenScalarTest(Vector64<float> value)
{
  return AdvSimd.ConvertToUInt32RoundToEvenScalar(value);
}
// value = <11.5, 12.5>
// Result = <12, 0>

```



See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.converttouint32roundtoevenscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ConvertToUInt32RoundToEvenScalarTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[UInt32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M27512_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M27512_IG02:
            ldr     d16, [fp,#24]
            fcvtnu  s16, s16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 4.50
G_M27512_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 12.20, (MethodHash=89529487) for method AdvSimdMethods:ConvertToUInt32RoundToEvenScalarTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[UInt32]
; ============================================================


```
------------------------------------------------

### 56. ConvertToUInt32RoundToNegativeInfinity

`Vector64<uint> ConvertToUInt32RoundToNegativeInfinity(Vector64<float> value)`

Performs 'ConvertToUInt32RoundToNegativeInfinity' operation.

```csharp
private Vector64<uint> ConvertToUInt32RoundToNegativeInfinityTest(Vector64<float> value)
{
  return AdvSimd.ConvertToUInt32RoundToNegativeInfinity(value);
}
// value = <11.5, 12.5>
// Result = <11, 12>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<uint> ConvertToUInt32RoundToNegativeInfinity(Vector128<float> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.converttouint32roundtonegativeinfinity?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ConvertToUInt32RoundToNegativeInfinityTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[UInt32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M11375_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M11375_IG02:
            ldr     d16, [fp,#24]
            fcvtmu  v16.2s, v16.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M11375_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=cfe7d390) for method AdvSimdMethods:ConvertToUInt32RoundToNegativeInfinityTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[UInt32]
; ============================================================


```
------------------------------------------------

### 57. ConvertToUInt32RoundToNegativeInfinityScalar

`Vector64<uint> ConvertToUInt32RoundToNegativeInfinityScalar(Vector64<float> value)`

Performs 'ConvertToUInt32RoundToNegativeInfinityScalar' operation.

```csharp
private Vector64<uint> ConvertToUInt32RoundToNegativeInfinityScalarTest(Vector64<float> value)
{
  return AdvSimd.ConvertToUInt32RoundToNegativeInfinityScalar(value);
}
// value = <11.5, 12.5>
// Result = <11, 0>

```



See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.converttouint32roundtonegativeinfinityscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ConvertToUInt32RoundToNegativeInfinityScalarTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[UInt32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M36897_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M36897_IG02:
            ldr     d16, [fp,#24]
            fcvtmu  s16, s16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 4.50
G_M36897_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 12.20, (MethodHash=55e06fde) for method AdvSimdMethods:ConvertToUInt32RoundToNegativeInfinityScalarTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[UInt32]
; ============================================================


```
------------------------------------------------

### 58. ConvertToUInt32RoundToPositiveInfinity

`Vector64<uint> ConvertToUInt32RoundToPositiveInfinity(Vector64<float> value)`

Performs 'ConvertToUInt32RoundToPositiveInfinity' operation.

```csharp
private Vector64<uint> ConvertToUInt32RoundToPositiveInfinityTest(Vector64<float> value)
{
  return AdvSimd.ConvertToUInt32RoundToPositiveInfinity(value);
}
// value = <11.5, 12.5>
// Result = <12, 13>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<uint> ConvertToUInt32RoundToPositiveInfinity(Vector128<float> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.converttouint32roundtopositiveinfinity?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ConvertToUInt32RoundToPositiveInfinityTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[UInt32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M20519_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M20519_IG02:
            ldr     d16, [fp,#24]
            fcvtpu  v16.2s, v16.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M20519_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=239eafd8) for method AdvSimdMethods:ConvertToUInt32RoundToPositiveInfinityTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[UInt32]
; ============================================================


```
------------------------------------------------

### 59. ConvertToUInt32RoundToPositiveInfinityScalar

`Vector64<uint> ConvertToUInt32RoundToPositiveInfinityScalar(Vector64<float> value)`

Performs 'ConvertToUInt32RoundToPositiveInfinityScalar' operation.

```csharp
private Vector64<uint> ConvertToUInt32RoundToPositiveInfinityScalarTest(Vector64<float> value)
{
  return AdvSimd.ConvertToUInt32RoundToPositiveInfinityScalar(value);
}
// value = <11.5, 12.5>
// Result = <12, 0>

```



See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.converttouint32roundtopositiveinfinityscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ConvertToUInt32RoundToPositiveInfinityScalarTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[UInt32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M64745_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M64745_IG02:
            ldr     d16, [fp,#24]
            fcvtpu  s16, s16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 4.50
G_M64745_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 12.20, (MethodHash=1a790316) for method AdvSimdMethods:ConvertToUInt32RoundToPositiveInfinityScalarTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[UInt32]
; ============================================================


```
------------------------------------------------

### 60. ConvertToUInt32RoundToZero

`Vector64<uint> ConvertToUInt32RoundToZero(Vector64<float> value)`

Performs 'ConvertToUInt32RoundToZero' operation.

```csharp
private Vector64<uint> ConvertToUInt32RoundToZeroTest(Vector64<float> value)
{
  return AdvSimd.ConvertToUInt32RoundToZero(value);
}
// value = <11.5, 12.5>
// Result = <11, 12>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<uint> ConvertToUInt32RoundToZero(Vector128<float> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.converttouint32roundtozero?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ConvertToUInt32RoundToZeroTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[UInt32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M6828_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M6828_IG02:
            ldr     d16, [fp,#24]
            fcvtzu  v16.2s, v16.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M6828_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=abfce553) for method AdvSimdMethods:ConvertToUInt32RoundToZeroTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[UInt32]
; ============================================================

```

---
STARTlayout:post
title: Hardware Intrinsics APIs for ARM64 - Part 2
subtitle: With examples
tags: [work, arm64, intrinsics]
---

### Introduction

In my [last post](../2019-01-01-Vectorization-APIs), I describe SIMD datatypes `Vector64<T>` and `Vector128<T>` that operates on 'hardware intrisic' APIs. In this post I will describe the intrinsic APIs for ARM64 and how you can use them to optimize your code if you are writing a .NET API targetting ARM64. This is 3 post series TODO.


### API list

[ConvertToUInt32RoundToZeroScalar](#1-converttouint32roundtozeroscalar), [DivideScalar](#2-dividescalar), [DuplicateSelectedScalarToVector64](#3-duplicateselectedscalartovector64), [DuplicateSelectedScalarToVector128](#4-duplicateselectedscalartovector128), [DuplicateToVector64](#5-duplicatetovector64), [DuplicateToVector128](#6-duplicatetovector128), [Extract](#7-extract), [ExtractNarrowingLower](#8-extractnarrowinglower), [ExtractNarrowingSaturateLower](#9-extractnarrowingsaturatelower), [ExtractNarrowingSaturateUnsignedLower](#10-extractnarrowingsaturateunsignedlower), [ExtractNarrowingSaturateUnsignedUpper](#11-extractnarrowingsaturateunsignedupper), [ExtractNarrowingSaturateUpper](#12-extractnarrowingsaturateupper), [ExtractNarrowingUpper](#13-extractnarrowingupper), [ExtractVector64](#14-extractvector64), [ExtractVector128](#15-extractvector128), [Floor](#16-floor), [FloorScalar](#17-floorscalar), [FusedAddHalving](#18-fusedaddhalving), [FusedAddRoundedHalving](#19-fusedaddroundedhalving), [FusedMultiplyAdd](#20-fusedmultiplyadd), [FusedMultiplyAddNegatedScalar](#21-fusedmultiplyaddnegatedscalar), [FusedMultiplyAddScalar](#22-fusedmultiplyaddscalar), [FusedMultiplySubtract](#23-fusedmultiplysubtract), [FusedMultiplySubtractNegatedScalar](#24-fusedmultiplysubtractnegatedscalar), [FusedMultiplySubtractScalar](#25-fusedmultiplysubtractscalar), [FusedSubtractHalving](#26-fusedsubtracthalving), [Insert](#27-insert), [InsertScalar](#28-insertscalar), [LeadingSignCount](#29-leadingsigncount), [LeadingZeroCount](#30-leadingzerocount), [LoadAndInsertScalar](#31-loadandinsertscalar), [LoadAndReplicateToVector64](#32-loadandreplicatetovector64), [LoadAndReplicateToVector128](#33-loadandreplicatetovector128), [LoadVector64](#34-loadvector64), [LoadVector128](#35-loadvector128), [Max](#36-max), [MaxNumber](#37-maxnumber), [MaxNumberScalar](#38-maxnumberscalar), [MaxPairwise](#39-maxpairwise), [Min](#40-min), [MinNumber](#41-minnumber), [MinNumberScalar](#42-minnumberscalar), [MinPairwise](#43-minpairwise), [Multiply](#44-multiply), [MultiplyAdd](#45-multiplyadd), [MultiplyAddByScalar](#46-multiplyaddbyscalar), [MultiplyAddBySelectedScalar](#47-multiplyaddbyselectedscalar), [MultiplyByScalar](#48-multiplybyscalar), [MultiplyBySelectedScalar](#49-multiplybyselectedscalar), [MultiplyBySelectedScalarWideningLower](#50-multiplybyselectedscalarwideninglower), [MultiplyBySelectedScalarWideningLowerAndAdd](#51-multiplybyselectedscalarwideninglowerandadd), [MultiplyBySelectedScalarWideningLowerAndSubtract](#52-multiplybyselectedscalarwideninglowerandsubtract), [MultiplyBySelectedScalarWideningUpper](#53-multiplybyselectedscalarwideningupper), [MultiplyBySelectedScalarWideningUpperAndAdd](#54-multiplybyselectedscalarwideningupperandadd), [MultiplyBySelectedScalarWideningUpperAndSubtract](#55-multiplybyselectedscalarwideningupperandsubtract), [MultiplyDoublingByScalarSaturateHigh](#56-multiplydoublingbyscalarsaturatehigh), [MultiplyDoublingBySelectedScalarSaturateHigh](#57-multiplydoublingbyselectedscalarsaturatehigh), [MultiplyDoublingSaturateHigh](#58-multiplydoublingsaturatehigh), [MultiplyDoublingWideningLowerAndAddSaturate](#59-multiplydoublingwideninglowerandaddsaturate), [MultiplyDoublingWideningLowerAndSubtractSaturate](#60-multiplydoublingwideninglowerandsubtractsaturate),[...](Part2.md)






### 1. ConvertToUInt32RoundToZeroScalar

`Vector64<uint> ConvertToUInt32RoundToZeroScalar(Vector64<float> value)`

Performs 'ConvertToUInt32RoundToZeroScalar' operation.

```csharp
private Vector64<uint> ConvertToUInt32RoundToZeroScalarTest(Vector64<float> value)
{
  return AdvSimd.ConvertToUInt32RoundToZeroScalar(value);
}
// value = <11.5, 12.5>
// Result = <11, 0>

```



See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.converttouint32roundtozeroscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ConvertToUInt32RoundToZeroScalarTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[UInt32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M37154_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M37154_IG02:
            ldr     d16, [fp,#24]
            fcvtzu  s16, s16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 4.50
G_M37154_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 12.20, (MethodHash=e6616edd) for method AdvSimdMethods:ConvertToUInt32RoundToZeroScalarTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[UInt32]
; ============================================================


```
------------------------------------------------

### 2. DivideScalar

`Vector64<double> DivideScalar(Vector64<double> left, Vector64<double> right)`

Performs 'DivideScalar' operation.

```csharp
private Vector64<double> DivideScalarTest(Vector64<double> left, Vector64<double> right)
{
  return AdvSimd.DivideScalar(left, right);
}
// left = <11.5>
// right = <11.5>
// Result = <1>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<float> DivideScalar(Vector64<float> left, Vector64<float> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.dividescalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:DivideScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M11794_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M11794_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            fdiv    d16, d16, d17
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 18.50
G_M11794_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 28.00, (MethodHash=8a8cd1ed) for method AdvSimdMethods:DivideScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 3. DuplicateSelectedScalarToVector64

`Vector64<byte> DuplicateSelectedScalarToVector64(Vector64<byte> value, byte index)`

Performs 'DuplicateSelectedScalarToVector64' operation.

```csharp
private Vector64<byte> DuplicateSelectedScalarToVector64Test(Vector64<byte> value, byte index)
{
  return AdvSimd.DuplicateSelectedScalarToVector64(value, index);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// index = 0
// Result = <11, 11, 11, 11, 11, 11, 11, 11>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> DuplicateSelectedScalarToVector64(Vector64<short> value, byte index)
Vector64<int> DuplicateSelectedScalarToVector64(Vector64<int> value, byte index)
Vector64<float> DuplicateSelectedScalarToVector64(Vector64<float> value, byte index)
Vector64<sbyte> DuplicateSelectedScalarToVector64(Vector64<sbyte> value, byte index)
Vector64<ushort> DuplicateSelectedScalarToVector64(Vector64<ushort> value, byte index)
Vector64<uint> DuplicateSelectedScalarToVector64(Vector64<uint> value, byte index)
Vector64<byte> DuplicateSelectedScalarToVector64(Vector128<byte> value, byte index)
Vector64<short> DuplicateSelectedScalarToVector64(Vector128<short> value, byte index)
Vector64<int> DuplicateSelectedScalarToVector64(Vector128<int> value, byte index)
Vector64<float> DuplicateSelectedScalarToVector64(Vector128<float> value, byte index)
Vector64<sbyte> DuplicateSelectedScalarToVector64(Vector128<sbyte> value, byte index)
Vector64<ushort> DuplicateSelectedScalarToVector64(Vector128<ushort> value, byte index)
Vector64<uint> DuplicateSelectedScalarToVector64(Vector128<uint> value, byte index)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.duplicateselectedscalartovector64?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:DuplicateSelectedScalarToVector64Test(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M29602_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M29602_IG02:
            ldr     d0, [fp,#24]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:DuplicateSelectedScalarToVector64(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
						;; bbWeight=1    PerfScore 3.50
G_M29602_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=9c238c5d) for method AdvSimdMethods:DuplicateSelectedScalarToVector64Test(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 4. DuplicateSelectedScalarToVector128

`Vector128<byte> DuplicateSelectedScalarToVector128(Vector64<byte> value, byte index)`

Performs 'DuplicateSelectedScalarToVector128' operation.

```csharp
private Vector128<byte> DuplicateSelectedScalarToVector128Test(Vector64<byte> value, byte index)
{
  return AdvSimd.DuplicateSelectedScalarToVector128(value, index);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// index = 0
// Result = <11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<short> DuplicateSelectedScalarToVector128(Vector64<short> value, byte index)
Vector128<int> DuplicateSelectedScalarToVector128(Vector64<int> value, byte index)
Vector128<float> DuplicateSelectedScalarToVector128(Vector64<float> value, byte index)
Vector128<sbyte> DuplicateSelectedScalarToVector128(Vector64<sbyte> value, byte index)
Vector128<ushort> DuplicateSelectedScalarToVector128(Vector64<ushort> value, byte index)
Vector128<uint> DuplicateSelectedScalarToVector128(Vector64<uint> value, byte index)
Vector128<byte> DuplicateSelectedScalarToVector128(Vector128<byte> value, byte index)
Vector128<short> DuplicateSelectedScalarToVector128(Vector128<short> value, byte index)
Vector128<int> DuplicateSelectedScalarToVector128(Vector128<int> value, byte index)
Vector128<float> DuplicateSelectedScalarToVector128(Vector128<float> value, byte index)
Vector128<sbyte> DuplicateSelectedScalarToVector128(Vector128<sbyte> value, byte index)
Vector128<ushort> DuplicateSelectedScalarToVector128(Vector128<ushort> value, byte index)
Vector128<uint> DuplicateSelectedScalarToVector128(Vector128<uint> value, byte index)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> DuplicateSelectedScalarToVector128(Vector128<double> value, byte index)
Vector128<long> DuplicateSelectedScalarToVector128(Vector128<long> value, byte index)
Vector128<ulong> DuplicateSelectedScalarToVector128(Vector128<ulong> value, byte index)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.duplicateselectedscalartovector128?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.duplicateselectedscalartovector128?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:DuplicateSelectedScalarToVector128Test(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector128`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M33154_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M33154_IG02:
            ldr     d0, [fp,#24]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:DuplicateSelectedScalarToVector128(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector128`1[Byte]
						;; bbWeight=1    PerfScore 3.50
G_M33154_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=c5e67e7d) for method AdvSimdMethods:DuplicateSelectedScalarToVector128Test(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector128`1[Byte]
; ============================================================


```
------------------------------------------------

### 5. DuplicateToVector64

`Vector64<byte> DuplicateToVector64(byte value)`

Performs 'DuplicateToVector64' operation.

```csharp
private Vector64<byte> DuplicateToVector64Test(byte value)
{
  return AdvSimd.DuplicateToVector64(value);
}
// value = 0
// Result = <0, 0, 0, 0, 0, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> DuplicateToVector64(short value)
Vector64<int> DuplicateToVector64(int value)
Vector64<sbyte> DuplicateToVector64(sbyte value)
Vector64<float> DuplicateToVector64(float value)
Vector64<ushort> DuplicateToVector64(ushort value)
Vector64<uint> DuplicateToVector64(uint value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.duplicatetovector64?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:DuplicateToVector64Test(ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00,T00] (  3,  3   )   ubyte  ->   x0        
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 0

G_M1236_IG01:
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M1236_IG02:
            uxtb    w0, w0
            dup     v16.8b, w0
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 3.00
G_M1236_IG03:
            ldp     fp, lr, [sp],#16
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 28, prolog size 8, PerfScore 9.30, (MethodHash=37f0fb2b) for method AdvSimdMethods:DuplicateToVector64Test(ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 6. DuplicateToVector128

`Vector128<byte> DuplicateToVector128(byte value)`

Performs 'DuplicateToVector128' operation.

```csharp
private Vector128<byte> DuplicateToVector128Test(byte value)
{
  return AdvSimd.DuplicateToVector128(value);
}
// value = 0
// Result = <0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<short> DuplicateToVector128(short value)
Vector128<int> DuplicateToVector128(int value)
Vector128<sbyte> DuplicateToVector128(sbyte value)
Vector128<float> DuplicateToVector128(float value)
Vector128<ushort> DuplicateToVector128(ushort value)
Vector128<uint> DuplicateToVector128(uint value)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> DuplicateToVector128(double value)
Vector128<long> DuplicateToVector128(long value)
Vector128<ulong> DuplicateToVector128(ulong value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.duplicatetovector128?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.duplicatetovector128?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:DuplicateToVector128Test(ubyte):System.Runtime.Intrinsics.Vector128`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00,T00] (  3,  3   )   ubyte  ->   x0        
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 0

G_M20148_IG01:
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M20148_IG02:
            uxtb    w0, w0
            dup     v16.16b, w0
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 3.00
G_M20148_IG03:
            ldp     fp, lr, [sp],#16
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 28, prolog size 8, PerfScore 9.30, (MethodHash=c39ab14b) for method AdvSimdMethods:DuplicateToVector128Test(ubyte):System.Runtime.Intrinsics.Vector128`1[Byte]
; ============================================================


```
------------------------------------------------

### 7. Extract

`byte Extract(Vector64<byte> vector, byte index)`

Performs 'Extract' operation.

```csharp
private byte ExtractTest(Vector64<byte> vector, byte index)
{
  return AdvSimd.Extract(vector, index);
}
// vector = <11, 12, 13, 14, 15, 16, 17, 18>
// index = 0
// Result = 11

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
short Extract(Vector64<short> vector, byte index)
int Extract(Vector64<int> vector, byte index)
sbyte Extract(Vector64<sbyte> vector, byte index)
float Extract(Vector64<float> vector, byte index)
ushort Extract(Vector64<ushort> vector, byte index)
uint Extract(Vector64<uint> vector, byte index)
byte Extract(Vector128<byte> vector, byte index)
double Extract(Vector128<double> vector, byte index)
short Extract(Vector128<short> vector, byte index)
int Extract(Vector128<int> vector, byte index)
long Extract(Vector128<long> vector, byte index)
sbyte Extract(Vector128<sbyte> vector, byte index)
float Extract(Vector128<float> vector, byte index)
ushort Extract(Vector128<ushort> vector, byte index)
uint Extract(Vector128<uint> vector, byte index)
ulong Extract(Vector128<ulong> vector, byte index)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.extract?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ExtractTest(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):ubyte
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M47581_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M47581_IG02:
            ldr     d0, [fp,#24]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:Extract(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):ubyte
            uxtb    w0, w0
						;; bbWeight=1    PerfScore 4.00
G_M47581_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 36, prolog size 8, PerfScore 12.10, (MethodHash=7c894622) for method AdvSimdMethods:ExtractTest(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):ubyte
; ============================================================


```
------------------------------------------------

### 8. ExtractNarrowingLower

`Vector64<byte> ExtractNarrowingLower(Vector128<ushort> value)`

Performs 'ExtractNarrowingLower' operation.

```csharp
private Vector64<byte> ExtractNarrowingLowerTest(Vector128<ushort> value)
{
  return AdvSimd.ExtractNarrowingLower(value);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// Result = <11, 12, 13, 14, 15, 16, 17, 18>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> ExtractNarrowingLower(Vector128<int> value)
Vector64<int> ExtractNarrowingLower(Vector128<long> value)
Vector64<sbyte> ExtractNarrowingLower(Vector128<short> value)
Vector64<ushort> ExtractNarrowingLower(Vector128<uint> value)
Vector64<uint> ExtractNarrowingLower(Vector128<ulong> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.extractnarrowinglower?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ExtractNarrowingLowerTest(System.Runtime.Intrinsics.Vector128`1[UInt16]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M51242_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     q0, [fp,#16]
						;; bbWeight=1    PerfScore 2.50
G_M51242_IG02:
            ldr     q16, [fp,#16]
            xtn     v16.8b, v16.8h
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 3.50
G_M51242_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=9eb937d5) for method AdvSimdMethods:ExtractNarrowingLowerTest(System.Runtime.Intrinsics.Vector128`1[UInt16]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 9. ExtractNarrowingSaturateLower

`Vector64<byte> ExtractNarrowingSaturateLower(Vector128<ushort> value)`

Performs 'ExtractNarrowingSaturateLower' operation.

```csharp
private Vector64<byte> ExtractNarrowingSaturateLowerTest(Vector128<ushort> value)
{
  return AdvSimd.ExtractNarrowingSaturateLower(value);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// Result = <11, 12, 13, 14, 15, 16, 17, 18>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> ExtractNarrowingSaturateLower(Vector128<int> value)
Vector64<int> ExtractNarrowingSaturateLower(Vector128<long> value)
Vector64<sbyte> ExtractNarrowingSaturateLower(Vector128<short> value)
Vector64<ushort> ExtractNarrowingSaturateLower(Vector128<uint> value)
Vector64<uint> ExtractNarrowingSaturateLower(Vector128<ulong> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.extractnarrowingsaturatelower?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ExtractNarrowingSaturateLowerTest(System.Runtime.Intrinsics.Vector128`1[UInt16]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M37147_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     q0, [fp,#16]
						;; bbWeight=1    PerfScore 2.50
G_M37147_IG02:
            ldr     q16, [fp,#16]
            uqxtn   v16.8b, v16.8h
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M37147_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=3ad86ee4) for method AdvSimdMethods:ExtractNarrowingSaturateLowerTest(System.Runtime.Intrinsics.Vector128`1[UInt16]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 10. ExtractNarrowingSaturateUnsignedLower

`Vector64<byte> ExtractNarrowingSaturateUnsignedLower(Vector128<short> value)`

Performs 'ExtractNarrowingSaturateUnsignedLower' operation.

```csharp
private Vector64<byte> ExtractNarrowingSaturateUnsignedLowerTest(Vector128<short> value)
{
  return AdvSimd.ExtractNarrowingSaturateUnsignedLower(value);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// Result = <11, 12, 13, 14, 15, 16, 17, 18>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<ushort> ExtractNarrowingSaturateUnsignedLower(Vector128<int> value)
Vector64<uint> ExtractNarrowingSaturateUnsignedLower(Vector128<long> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.extractnarrowingsaturateunsignedlower?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ExtractNarrowingSaturateUnsignedLowerTest(System.Runtime.Intrinsics.Vector128`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M43367_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     q0, [fp,#16]
						;; bbWeight=1    PerfScore 2.50
G_M43367_IG02:
            ldr     q16, [fp,#16]
            sqxtun  v16.8b, v16.8h
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M43367_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=cfe95698) for method AdvSimdMethods:ExtractNarrowingSaturateUnsignedLowerTest(System.Runtime.Intrinsics.Vector128`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 11. ExtractNarrowingSaturateUnsignedUpper

`Vector128<byte> ExtractNarrowingSaturateUnsignedUpper(Vector64<byte> lower, Vector128<short> value)`

Performs 'ExtractNarrowingSaturateUnsignedUpper' operation.

```csharp
private Vector128<byte> ExtractNarrowingSaturateUnsignedUpperTest(Vector64<byte> lower, Vector128<short> value)
{
  return AdvSimd.ExtractNarrowingSaturateUnsignedUpper(lower, value);
}
// lower = <11, 12, 13, 14, 15, 16, 17, 18>
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// Result = <11, 12, 13, 14, 15, 16, 17, 18, 11, 12, 13, 14, 15, 16, 17, 18>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<ushort> ExtractNarrowingSaturateUnsignedUpper(Vector64<ushort> lower, Vector128<int> value)
Vector128<uint> ExtractNarrowingSaturateUnsignedUpper(Vector64<uint> lower, Vector128<long> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.extractnarrowingsaturateunsignedupper?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ExtractNarrowingSaturateUnsignedUpperTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[Int16]):System.Runtime.Intrinsics.Vector128`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M10990_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     q1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M10990_IG02:
            ldr     d16, [fp,#40]
            ldr     q17, [fp,#16]
            sqxtun2 v16.16b, v17.8h
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 7.50
G_M10990_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=eacbd511) for method AdvSimdMethods:ExtractNarrowingSaturateUnsignedUpperTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[Int16]):System.Runtime.Intrinsics.Vector128`1[Byte]
; ============================================================


```
------------------------------------------------

### 12. ExtractNarrowingSaturateUpper

`Vector128<byte> ExtractNarrowingSaturateUpper(Vector64<byte> lower, Vector128<ushort> value)`

Performs 'ExtractNarrowingSaturateUpper' operation.

```csharp
private Vector128<byte> ExtractNarrowingSaturateUpperTest(Vector64<byte> lower, Vector128<ushort> value)
{
  return AdvSimd.ExtractNarrowingSaturateUpper(lower, value);
}
// lower = <11, 12, 13, 14, 15, 16, 17, 18>
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// Result = <11, 12, 13, 14, 15, 16, 17, 18, 11, 12, 13, 14, 15, 16, 17, 18>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<short> ExtractNarrowingSaturateUpper(Vector64<short> lower, Vector128<int> value)
Vector128<int> ExtractNarrowingSaturateUpper(Vector64<int> lower, Vector128<long> value)
Vector128<sbyte> ExtractNarrowingSaturateUpper(Vector64<sbyte> lower, Vector128<short> value)
Vector128<ushort> ExtractNarrowingSaturateUpper(Vector64<ushort> lower, Vector128<uint> value)
Vector128<uint> ExtractNarrowingSaturateUpper(Vector64<uint> lower, Vector128<ulong> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.extractnarrowingsaturateupper?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ExtractNarrowingSaturateUpperTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[UInt16]):System.Runtime.Intrinsics.Vector128`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M36722_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     q1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M36722_IG02:
            ldr     d16, [fp,#40]
            ldr     q17, [fp,#16]
            uqxtn2  v16.16b, v17.8h
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 7.50
G_M36722_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=9b6c708d) for method AdvSimdMethods:ExtractNarrowingSaturateUpperTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[UInt16]):System.Runtime.Intrinsics.Vector128`1[Byte]
; ============================================================


```
------------------------------------------------

### 13. ExtractNarrowingUpper

`Vector128<byte> ExtractNarrowingUpper(Vector64<byte> lower, Vector128<ushort> value)`

Performs 'ExtractNarrowingUpper' operation.

```csharp
private Vector128<byte> ExtractNarrowingUpperTest(Vector64<byte> lower, Vector128<ushort> value)
{
  return AdvSimd.ExtractNarrowingUpper(lower, value);
}
// lower = <11, 12, 13, 14, 15, 16, 17, 18>
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// Result = <11, 12, 13, 14, 15, 16, 17, 18, 11, 12, 13, 14, 15, 16, 17, 18>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<short> ExtractNarrowingUpper(Vector64<short> lower, Vector128<int> value)
Vector128<int> ExtractNarrowingUpper(Vector64<int> lower, Vector128<long> value)
Vector128<sbyte> ExtractNarrowingUpper(Vector64<sbyte> lower, Vector128<short> value)
Vector128<ushort> ExtractNarrowingUpper(Vector64<ushort> lower, Vector128<uint> value)
Vector128<uint> ExtractNarrowingUpper(Vector64<uint> lower, Vector128<ulong> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.extractnarrowingupper?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ExtractNarrowingUpperTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[UInt16]):System.Runtime.Intrinsics.Vector128`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M41795_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     q1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M41795_IG02:
            ldr     d16, [fp,#40]
            ldr     q17, [fp,#16]
            xtn2    v16.16b, v17.8h
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 5.50
G_M41795_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=03b25cbc) for method AdvSimdMethods:ExtractNarrowingUpperTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[UInt16]):System.Runtime.Intrinsics.Vector128`1[Byte]
; ============================================================


```
------------------------------------------------

### 14. ExtractVector64

`Vector64<byte> ExtractVector64(Vector64<byte> upper, Vector64<byte> lower, byte index)`

Performs 'ExtractVector64' operation.

```csharp
private Vector64<byte> ExtractVector64Test(Vector64<byte> upper, Vector64<byte> lower, byte index)
{
  return AdvSimd.ExtractVector64(upper, lower, index);
}
// upper = <11, 12, 13, 14, 15, 16, 17, 18>
// lower = <21, 22, 23, 24, 25, 26, 27, 28>
// index = 0
// Result = <11, 12, 13, 14, 15, 16, 17, 18>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> ExtractVector64(Vector64<short> upper, Vector64<short> lower, byte index)
Vector64<int> ExtractVector64(Vector64<int> upper, Vector64<int> lower, byte index)
Vector64<sbyte> ExtractVector64(Vector64<sbyte> upper, Vector64<sbyte> lower, byte index)
Vector64<float> ExtractVector64(Vector64<float> upper, Vector64<float> lower, byte index)
Vector64<ushort> ExtractVector64(Vector64<ushort> upper, Vector64<ushort> lower, byte index)
Vector64<uint> ExtractVector64(Vector64<uint> upper, Vector64<uint> lower, byte index)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.extractvector64?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ExtractVector64Test(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M32949_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M32949_IG02:
            ldr     d0, [fp,#24]
            ldr     d1, [fp,#16]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:ExtractVector64(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
						;; bbWeight=1    PerfScore 5.50
G_M32949_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=bab07f4a) for method AdvSimdMethods:ExtractVector64Test(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 15. ExtractVector128

`Vector128<byte> ExtractVector128(Vector128<byte> upper, Vector128<byte> lower, byte index)`

Performs 'ExtractVector128' operation.

```csharp
private Vector128<byte> ExtractVector128Test(Vector128<byte> upper, Vector128<byte> lower, byte index)
{
  return AdvSimd.ExtractVector128(upper, lower, index);
}
// upper = <11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26>
// lower = <21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36>
// index = 0
// Result = <11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<double> ExtractVector128(Vector128<double> upper, Vector128<double> lower, byte index)
Vector128<short> ExtractVector128(Vector128<short> upper, Vector128<short> lower, byte index)
Vector128<int> ExtractVector128(Vector128<int> upper, Vector128<int> lower, byte index)
Vector128<long> ExtractVector128(Vector128<long> upper, Vector128<long> lower, byte index)
Vector128<sbyte> ExtractVector128(Vector128<sbyte> upper, Vector128<sbyte> lower, byte index)
Vector128<float> ExtractVector128(Vector128<float> upper, Vector128<float> lower, byte index)
Vector128<ushort> ExtractVector128(Vector128<ushort> upper, Vector128<ushort> lower, byte index)
Vector128<uint> ExtractVector128(Vector128<uint> upper, Vector128<uint> lower, byte index)
Vector128<ulong> ExtractVector128(Vector128<ulong> upper, Vector128<ulong> lower, byte index)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.extractvector128?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ExtractVector128Test(System.Runtime.Intrinsics.Vector128`1[Byte],System.Runtime.Intrinsics.Vector128`1[Byte],ubyte):System.Runtime.Intrinsics.Vector128`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T01] (  2,  4   )  simd16  ->   d0         HFA(simd16)  "Inlining Arg"
;  V05 tmp2         [V05,T02] (  2,  4   )  simd16  ->   d1         HFA(simd16)  "Inlining Arg"
;
; Lcl frame size = 32

G_M41909_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     q0, [fp,#32]
            str     q1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M41909_IG02:
            ldr     q0, [fp,#32]
            ldr     q1, [fp,#16]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:ExtractVector128(System.Runtime.Intrinsics.Vector128`1[Byte],System.Runtime.Intrinsics.Vector128`1[Byte],ubyte):System.Runtime.Intrinsics.Vector128`1[Byte]
						;; bbWeight=1    PerfScore 5.50
G_M41909_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=5d495c4a) for method AdvSimdMethods:ExtractVector128Test(System.Runtime.Intrinsics.Vector128`1[Byte],System.Runtime.Intrinsics.Vector128`1[Byte],ubyte):System.Runtime.Intrinsics.Vector128`1[Byte]
; ============================================================


```
------------------------------------------------

### 16. Floor

`Vector64<float> Floor(Vector64<float> value)`

Performs 'Floor' operation.

```csharp
private Vector64<float> FloorTest(Vector64<float> value)
{
  return AdvSimd.Floor(value);
}
// value = <11.5, 12.5>
// Result = <11, 12>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<float> Floor(Vector128<float> value)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> Floor(Vector128<double> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.floor?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.floor?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:FloorTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M8345_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M8345_IG02:
            ldr     d16, [fp,#24]
            frintm  v16.2s, v16.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M8345_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=4a61df66) for method AdvSimdMethods:FloorTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 17. FloorScalar

`Vector64<double> FloorScalar(Vector64<double> value)`

Performs 'FloorScalar' operation.

```csharp
private Vector64<double> FloorScalarTest(Vector64<double> value)
{
  return AdvSimd.FloorScalar(value);
}
// value = <11.5>
// Result = <11>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<float> FloorScalar(Vector64<float> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.floorscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:FloorScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M28439_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M28439_IG02:
            ldr     d16, [fp,#24]
            frintm  d16, d16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 4.50
G_M28439_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 12.20, (MethodHash=c0b490e8) for method AdvSimdMethods:FloorScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 18. FusedAddHalving

`Vector64<byte> FusedAddHalving(Vector64<byte> left, Vector64<byte> right)`

Performs 'FusedAddHalving' operation.

```csharp
private Vector64<byte> FusedAddHalvingTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.FusedAddHalving(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <16, 17, 18, 19, 20, 21, 22, 23>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> FusedAddHalving(Vector64<short> left, Vector64<short> right)
Vector64<int> FusedAddHalving(Vector64<int> left, Vector64<int> right)
Vector64<sbyte> FusedAddHalving(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<ushort> FusedAddHalving(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> FusedAddHalving(Vector64<uint> left, Vector64<uint> right)
Vector128<byte> FusedAddHalving(Vector128<byte> left, Vector128<byte> right)
Vector128<short> FusedAddHalving(Vector128<short> left, Vector128<short> right)
Vector128<int> FusedAddHalving(Vector128<int> left, Vector128<int> right)
Vector128<sbyte> FusedAddHalving(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<ushort> FusedAddHalving(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> FusedAddHalving(Vector128<uint> left, Vector128<uint> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.fusedaddhalving?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:FusedAddHalvingTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M25187_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M25187_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            uhadd   v16.8b, v16.8b, v17.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M25187_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=d1569d9c) for method AdvSimdMethods:FusedAddHalvingTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 19. FusedAddRoundedHalving

`Vector64<byte> FusedAddRoundedHalving(Vector64<byte> left, Vector64<byte> right)`

Performs 'FusedAddRoundedHalving' operation.

```csharp
private Vector64<byte> FusedAddRoundedHalvingTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.FusedAddRoundedHalving(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <16, 17, 18, 19, 20, 21, 22, 23>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> FusedAddRoundedHalving(Vector64<short> left, Vector64<short> right)
Vector64<int> FusedAddRoundedHalving(Vector64<int> left, Vector64<int> right)
Vector64<sbyte> FusedAddRoundedHalving(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<ushort> FusedAddRoundedHalving(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> FusedAddRoundedHalving(Vector64<uint> left, Vector64<uint> right)
Vector128<byte> FusedAddRoundedHalving(Vector128<byte> left, Vector128<byte> right)
Vector128<short> FusedAddRoundedHalving(Vector128<short> left, Vector128<short> right)
Vector128<int> FusedAddRoundedHalving(Vector128<int> left, Vector128<int> right)
Vector128<sbyte> FusedAddRoundedHalving(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<ushort> FusedAddRoundedHalving(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> FusedAddRoundedHalving(Vector128<uint> left, Vector128<uint> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.fusedaddroundedhalving?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:FusedAddRoundedHalvingTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M54048_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M54048_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            urhadd  v16.8b, v16.8b, v17.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M54048_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=e9b12cdf) for method AdvSimdMethods:FusedAddRoundedHalvingTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 20. FusedMultiplyAdd

`Vector64<float> FusedMultiplyAdd(Vector64<float> addend, Vector64<float> left, Vector64<float> right)`

Performs 'FusedMultiplyAdd' operation.

```csharp
private Vector64<float> FusedMultiplyAddTest(Vector64<float> addend, Vector64<float> left, Vector64<float> right)
{
  return AdvSimd.FusedMultiplyAdd(addend, left, right);
}
// addend = <11.5, 12.5>
// left = <21.5, 22.5>
// right = <11.5, 12.5>
// Result = <258.75, 293.75>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<float> FusedMultiplyAdd(Vector128<float> addend, Vector128<float> left, Vector128<float> right)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> FusedMultiplyAdd(Vector128<double> addend, Vector128<double> left, Vector128<double> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.fusedmultiplyadd?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.fusedmultiplyadd?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:FusedMultiplyAddTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x20]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M52653_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     d1, [fp,#32]
            str     d2, [fp,#24]
						;; bbWeight=1    PerfScore 4.50
G_M52653_IG02:
            ldr     d16, [fp,#40]
            ldr     d17, [fp,#32]
            ldr     d18, [fp,#24]
            fmla    v16.2s, v17.2s, v18.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 9.50
G_M52653_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 20.80, (MethodHash=51473252) for method AdvSimdMethods:FusedMultiplyAddTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 21. FusedMultiplyAddNegatedScalar

`Vector64<double> FusedMultiplyAddNegatedScalar(Vector64<double> addend, Vector64<double> left, Vector64<double> right)`

Performs 'FusedMultiplyAddNegatedScalar' operation.

```csharp
private Vector64<double> FusedMultiplyAddNegatedScalarTest(Vector64<double> addend, Vector64<double> left, Vector64<double> right)
{
  return AdvSimd.FusedMultiplyAddNegatedScalar(addend, left, right);
}
// addend = <11.5>
// left = <11.5>
// right = <11>
// Result = <-138>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<float> FusedMultiplyAddNegatedScalar(Vector64<float> addend, Vector64<float> left, Vector64<float> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.fusedmultiplyaddnegatedscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:FusedMultiplyAddNegatedScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x20]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M22555_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     d1, [fp,#32]
            str     d2, [fp,#24]
						;; bbWeight=1    PerfScore 4.50
G_M22555_IG02:
            ldr     d16, [fp,#40]
            ldr     d17, [fp,#32]
            ldr     d18, [fp,#24]
            fnmadd  d16, d17, d18, d16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 9.50
G_M22555_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 20.80, (MethodHash=ed4ba7e4) for method AdvSimdMethods:FusedMultiplyAddNegatedScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 22. FusedMultiplyAddScalar

`Vector64<double> FusedMultiplyAddScalar(Vector64<double> addend, Vector64<double> left, Vector64<double> right)`

Performs 'FusedMultiplyAddScalar' operation.

```csharp
private Vector64<double> FusedMultiplyAddScalarTest(Vector64<double> addend, Vector64<double> left, Vector64<double> right)
{
  return AdvSimd.FusedMultiplyAddScalar(addend, left, right);
}
// addend = <11.5>
// left = <11.5>
// right = <11>
// Result = <138>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<float> FusedMultiplyAddScalar(Vector64<float> addend, Vector64<float> left, Vector64<float> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.fusedmultiplyaddscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:FusedMultiplyAddScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x20]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M58563_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     d1, [fp,#32]
            str     d2, [fp,#24]
						;; bbWeight=1    PerfScore 4.50
G_M58563_IG02:
            ldr     d16, [fp,#40]
            ldr     d17, [fp,#32]
            ldr     d18, [fp,#24]
            fmadd   d16, d17, d18, d16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 9.50
G_M58563_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 20.80, (MethodHash=6a061b3c) for method AdvSimdMethods:FusedMultiplyAddScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 23. FusedMultiplySubtract

`Vector64<float> FusedMultiplySubtract(Vector64<float> minuend, Vector64<float> left, Vector64<float> right)`

Performs 'FusedMultiplySubtract' operation.

```csharp
private Vector64<float> FusedMultiplySubtractTest(Vector64<float> minuend, Vector64<float> left, Vector64<float> right)
{
  return AdvSimd.FusedMultiplySubtract(minuend, left, right);
}
// minuend = <11.5, 12.5>
// left = <21.5, 22.5>
// right = <11.5, 12.5>
// Result = <-235.75, -268.75>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<float> FusedMultiplySubtract(Vector128<float> minuend, Vector128<float> left, Vector128<float> right)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> FusedMultiplySubtract(Vector128<double> minuend, Vector128<double> left, Vector128<double> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.fusedmultiplysubtract?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.fusedmultiplysubtract?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:FusedMultiplySubtractTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x20]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M28216_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     d1, [fp,#32]
            str     d2, [fp,#24]
						;; bbWeight=1    PerfScore 4.50
G_M28216_IG02:
            ldr     d16, [fp,#40]
            ldr     d17, [fp,#32]
            ldr     d18, [fp,#24]
            fmls    v16.2s, v17.2s, v18.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 9.50
G_M28216_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 20.80, (MethodHash=c63191c7) for method AdvSimdMethods:FusedMultiplySubtractTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 24. FusedMultiplySubtractNegatedScalar

`Vector64<double> FusedMultiplySubtractNegatedScalar(Vector64<double> minuend, Vector64<double> left, Vector64<double> right)`

Performs 'FusedMultiplySubtractNegatedScalar' operation.

```csharp
private Vector64<double> FusedMultiplySubtractNegatedScalarTest(Vector64<double> minuend, Vector64<double> left, Vector64<double> right)
{
  return AdvSimd.FusedMultiplySubtractNegatedScalar(minuend, left, right);
}
// minuend = <11.5>
// left = <11.5>
// right = <11>
// Result = <115>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<float> FusedMultiplySubtractNegatedScalar(Vector64<float> minuend, Vector64<float> left, Vector64<float> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.fusedmultiplysubtractnegatedscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:FusedMultiplySubtractNegatedScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x20]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M57774_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     d1, [fp,#32]
            str     d2, [fp,#24]
						;; bbWeight=1    PerfScore 4.50
G_M57774_IG02:
            ldr     d16, [fp,#40]
            ldr     d17, [fp,#32]
            ldr     d18, [fp,#24]
            fnmsub  d16, d17, d18, d16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 9.50
G_M57774_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 20.80, (MethodHash=19331e51) for method AdvSimdMethods:FusedMultiplySubtractNegatedScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 25. FusedMultiplySubtractScalar

`Vector64<double> FusedMultiplySubtractScalar(Vector64<double> minuend, Vector64<double> left, Vector64<double> right)`

Performs 'FusedMultiplySubtractScalar' operation.

```csharp
private Vector64<double> FusedMultiplySubtractScalarTest(Vector64<double> minuend, Vector64<double> left, Vector64<double> right)
{
  return AdvSimd.FusedMultiplySubtractScalar(minuend, left, right);
}
// minuend = <11.5>
// left = <11.5>
// right = <11>
// Result = <-115>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<float> FusedMultiplySubtractScalar(Vector64<float> minuend, Vector64<float> left, Vector64<float> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.fusedmultiplysubtractscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:FusedMultiplySubtractScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x20]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M12118_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     d1, [fp,#32]
            str     d2, [fp,#24]
						;; bbWeight=1    PerfScore 4.50
G_M12118_IG02:
            ldr     d16, [fp,#40]
            ldr     d17, [fp,#32]
            ldr     d18, [fp,#24]
            fmsub   d16, d17, d18, d16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 9.50
G_M12118_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 20.80, (MethodHash=f4a5d0a9) for method AdvSimdMethods:FusedMultiplySubtractScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 26. FusedSubtractHalving

`Vector64<byte> FusedSubtractHalving(Vector64<byte> left, Vector64<byte> right)`

Performs 'FusedSubtractHalving' operation.

```csharp
private Vector64<byte> FusedSubtractHalvingTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.FusedSubtractHalving(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <251, 251, 251, 251, 251, 251, 251, 251>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> FusedSubtractHalving(Vector64<short> left, Vector64<short> right)
Vector64<int> FusedSubtractHalving(Vector64<int> left, Vector64<int> right)
Vector64<sbyte> FusedSubtractHalving(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<ushort> FusedSubtractHalving(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> FusedSubtractHalving(Vector64<uint> left, Vector64<uint> right)
Vector128<byte> FusedSubtractHalving(Vector128<byte> left, Vector128<byte> right)
Vector128<short> FusedSubtractHalving(Vector128<short> left, Vector128<short> right)
Vector128<int> FusedSubtractHalving(Vector128<int> left, Vector128<int> right)
Vector128<sbyte> FusedSubtractHalving(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<ushort> FusedSubtractHalving(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> FusedSubtractHalving(Vector128<uint> left, Vector128<uint> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.fusedsubtracthalving?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:FusedSubtractHalvingTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M34166_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M34166_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            uhsub   v16.8b, v16.8b, v17.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M34166_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=c42c7a89) for method AdvSimdMethods:FusedSubtractHalvingTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 27. Insert

`Vector64<byte> Insert(Vector64<byte> vector, byte index, byte data)`

Performs 'Insert' operation.

```csharp
private Vector64<byte> InsertTest(Vector64<byte> vector, byte index, byte data)
{
  return AdvSimd.Insert(vector, index, data);
}
// vector = <11, 12, 13, 14, 15, 16, 17, 18>
// index = 0
// data = 1
// Result = <1, 12, 13, 14, 15, 16, 17, 18>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> Insert(Vector64<short> vector, byte index, short data)
Vector64<int> Insert(Vector64<int> vector, byte index, int data)
Vector64<sbyte> Insert(Vector64<sbyte> vector, byte index, sbyte data)
Vector64<float> Insert(Vector64<float> vector, byte index, float data)
Vector64<ushort> Insert(Vector64<ushort> vector, byte index, ushort data)
Vector64<uint> Insert(Vector64<uint> vector, byte index, uint data)
Vector128<byte> Insert(Vector128<byte> vector, byte index, byte data)
Vector128<double> Insert(Vector128<double> vector, byte index, double data)
Vector128<short> Insert(Vector128<short> vector, byte index, short data)
Vector128<int> Insert(Vector128<int> vector, byte index, int data)
Vector128<long> Insert(Vector128<long> vector, byte index, long data)
Vector128<sbyte> Insert(Vector128<sbyte> vector, byte index, sbyte data)
Vector128<float> Insert(Vector128<float> vector, byte index, float data)
Vector128<ushort> Insert(Vector128<ushort> vector, byte index, ushort data)
Vector128<uint> Insert(Vector128<uint> vector, byte index, uint data)
Vector128<ulong> Insert(Vector128<ulong> vector, byte index, ulong data)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.insert?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:InsertTest(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte,ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;  V02 arg2         [V02,T01] (  3,  3   )   ubyte  ->   x1        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T02] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M53206_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M53206_IG02:
            ldr     d0, [fp,#24]
            uxtb    w1, w1
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:Insert(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte,ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
						;; bbWeight=1    PerfScore 4.00
G_M53206_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 36, prolog size 8, PerfScore 12.10, (MethodHash=d2fd3029) for method AdvSimdMethods:InsertTest(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte,ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 28. InsertScalar

`Vector128<double> InsertScalar(Vector128<double> result, byte resultIndex, Vector64<double> value)`

Performs 'InsertScalar' operation.

```csharp
private Vector128<double> InsertScalarTest(Vector128<double> result, byte resultIndex, Vector64<double> value)
{
  return AdvSimd.InsertScalar(result, resultIndex, value);
}
// result = <11.5, 12.5>
// resultIndex = 0
// value = <11.5>
// Result = <11.5, 12.5>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<long> InsertScalar(Vector128<long> result, byte resultIndex, Vector64<long> value)
Vector128<ulong> InsertScalar(Vector128<ulong> result, byte resultIndex, Vector64<ulong> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.insertscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:InsertScalarTest(System.Runtime.Intrinsics.Vector128`1[Double],ubyte,System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector128`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T01] (  2,  4   )  simd16  ->   d0         HFA(simd16)  "Inlining Arg"
;  V05 tmp2         [V05,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 32

G_M45221_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     q0, [fp,#32]
            str     d1, [fp,#24]
						;; bbWeight=1    PerfScore 3.50
G_M45221_IG02:
            ldr     q0, [fp,#32]
            ldr     d1, [fp,#24]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:InsertScalar(System.Runtime.Intrinsics.Vector128`1[Double],ubyte,System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector128`1[Double]
						;; bbWeight=1    PerfScore 5.50
G_M45221_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=5a654f5a) for method AdvSimdMethods:InsertScalarTest(System.Runtime.Intrinsics.Vector128`1[Double],ubyte,System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector128`1[Double]
; ============================================================


```
------------------------------------------------

### 29. LeadingSignCount

`Vector64<short> LeadingSignCount(Vector64<short> value)`

Performs 'LeadingSignCount' operation.

```csharp
private Vector64<short> LeadingSignCountTest(Vector64<short> value)
{
  return AdvSimd.LeadingSignCount(value);
}
// value = <11, 12, 13, 14>
// Result = <11, 11, 11, 11>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<int> LeadingSignCount(Vector64<int> value)
Vector64<sbyte> LeadingSignCount(Vector64<sbyte> value)
Vector128<short> LeadingSignCount(Vector128<short> value)
Vector128<int> LeadingSignCount(Vector128<int> value)
Vector128<sbyte> LeadingSignCount(Vector128<sbyte> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.leadingsigncount?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:LeadingSignCountTest(System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M58653_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M58653_IG02:
            ldr     d16, [fp,#24]
            cls     v16.4h, v16.4h
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 4.50
G_M58653_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 12.20, (MethodHash=a26c1ae2) for method AdvSimdMethods:LeadingSignCountTest(System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 30. LeadingZeroCount

`Vector64<byte> LeadingZeroCount(Vector64<byte> value)`

Performs 'LeadingZeroCount' operation.

```csharp
private Vector64<byte> LeadingZeroCountTest(Vector64<byte> value)
{
  return AdvSimd.LeadingZeroCount(value);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// Result = <4, 4, 4, 4, 4, 3, 3, 3>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> LeadingZeroCount(Vector64<short> value)
Vector64<int> LeadingZeroCount(Vector64<int> value)
Vector64<sbyte> LeadingZeroCount(Vector64<sbyte> value)
Vector64<ushort> LeadingZeroCount(Vector64<ushort> value)
Vector64<uint> LeadingZeroCount(Vector64<uint> value)
Vector128<byte> LeadingZeroCount(Vector128<byte> value)
Vector128<short> LeadingZeroCount(Vector128<short> value)
Vector128<int> LeadingZeroCount(Vector128<int> value)
Vector128<sbyte> LeadingZeroCount(Vector128<sbyte> value)
Vector128<ushort> LeadingZeroCount(Vector128<ushort> value)
Vector128<uint> LeadingZeroCount(Vector128<uint> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.leadingzerocount?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:LeadingZeroCountTest(System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M41676_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M41676_IG02:
            ldr     d16, [fp,#24]
            clz     v16.8b, v16.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 3.50
G_M41676_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=2cdb5d33) for method AdvSimdMethods:LeadingZeroCountTest(System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 31. LoadAndInsertScalar

`Vector64<byte> LoadAndInsertScalar(Vector64<byte> value, byte index, byte* address)`

Performs 'LoadAndInsertScalar' operation.

```csharp
private Vector64<byte> LoadAndInsertScalarTest(Vector64<byte> value, byte index, byte* address)
{
  return AdvSimd.LoadAndInsertScalar(value, index, address);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// index = 0
// address = <address>
// Result = <11, 12, 13, 14, 15, 16, 17, 18>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> LoadAndInsertScalar(Vector64<short> value, byte index, short* address)
Vector64<int> LoadAndInsertScalar(Vector64<int> value, byte index, int* address)
Vector64<sbyte> LoadAndInsertScalar(Vector64<sbyte> value, byte index, sbyte* address)
Vector64<float> LoadAndInsertScalar(Vector64<float> value, byte index, float* address)
Vector64<ushort> LoadAndInsertScalar(Vector64<ushort> value, byte index, ushort* address)
Vector64<uint> LoadAndInsertScalar(Vector64<uint> value, byte index, uint* address)
Vector128<byte> LoadAndInsertScalar(Vector128<byte> value, byte index, byte* address)
Vector128<double> LoadAndInsertScalar(Vector128<double> value, byte index, double* address)
Vector128<short> LoadAndInsertScalar(Vector128<short> value, byte index, short* address)
Vector128<int> LoadAndInsertScalar(Vector128<int> value, byte index, int* address)
Vector128<long> LoadAndInsertScalar(Vector128<long> value, byte index, long* address)
Vector128<sbyte> LoadAndInsertScalar(Vector128<sbyte> value, byte index, sbyte* address)
Vector128<float> LoadAndInsertScalar(Vector128<float> value, byte index, float* address)
Vector128<ushort> LoadAndInsertScalar(Vector128<ushort> value, byte index, ushort* address)
Vector128<uint> LoadAndInsertScalar(Vector128<uint> value, byte index, uint* address)
Vector128<ulong> LoadAndInsertScalar(Vector128<ulong> value, byte index, ulong* address)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.loadandinsertscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:LoadAndInsertScalarTest(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte,long):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;  V02 arg2         [V02,T01] (  3,  3   )    long  ->   x1        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T02] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M13568_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M13568_IG02:
            ldr     d0, [fp,#24]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:LoadAndInsertScalar(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte,long):System.Runtime.Intrinsics.Vector64`1[Byte]
						;; bbWeight=1    PerfScore 3.50
G_M13568_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=084fcaff) for method AdvSimdMethods:LoadAndInsertScalarTest(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte,long):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 32. LoadAndReplicateToVector64

`Vector64<byte> LoadAndReplicateToVector64(byte* address)`

Performs 'LoadAndReplicateToVector64' operation.

```csharp
private Vector64<byte> LoadAndReplicateToVector64Test(byte* address)
{
  return AdvSimd.LoadAndReplicateToVector64(address);
}
// address = <address>
// Result = <11, 11, 11, 11, 11, 11, 11, 11>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> LoadAndReplicateToVector64(short* address)
Vector64<int> LoadAndReplicateToVector64(int* address)
Vector64<sbyte> LoadAndReplicateToVector64(sbyte* address)
Vector64<float> LoadAndReplicateToVector64(float* address)
Vector64<ushort> LoadAndReplicateToVector64(ushort* address)
Vector64<uint> LoadAndReplicateToVector64(uint* address)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.loadandreplicatetovector64?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:LoadAndReplicateToVector64Test(long):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00,T00] (  3,  3   )    long  ->   x0        
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 0

G_M33418_IG01:
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M33418_IG02:
            ld1r    {v16.8b}, [x0]
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 2.50
G_M33418_IG03:
            ldp     fp, lr, [sp],#16
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 8.40, (MethodHash=c5ef7d75) for method AdvSimdMethods:LoadAndReplicateToVector64Test(long):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 33. LoadAndReplicateToVector128

`Vector128<byte> LoadAndReplicateToVector128(byte* address)`

Performs 'LoadAndReplicateToVector128' operation.

```csharp
private Vector128<byte> LoadAndReplicateToVector128Test(byte* address)
{
  return AdvSimd.LoadAndReplicateToVector128(address);
}
// address = <address>
// Result = <11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<short> LoadAndReplicateToVector128(short* address)
Vector128<int> LoadAndReplicateToVector128(int* address)
Vector128<sbyte> LoadAndReplicateToVector128(sbyte* address)
Vector128<float> LoadAndReplicateToVector128(float* address)
Vector128<ushort> LoadAndReplicateToVector128(ushort* address)
Vector128<uint> LoadAndReplicateToVector128(uint* address)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> LoadAndReplicateToVector128(double* address)
Vector128<long> LoadAndReplicateToVector128(long* address)
Vector128<ulong> LoadAndReplicateToVector128(ulong* address)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.loadandreplicatetovector128?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.loadandreplicatetovector128?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:LoadAndReplicateToVector128Test(long):System.Runtime.Intrinsics.Vector128`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00,T00] (  3,  3   )    long  ->   x0        
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 0

G_M4778_IG01:
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M4778_IG02:
            ld1r    {v16.16b}, [x0]
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 2.50
G_M4778_IG03:
            ldp     fp, lr, [sp],#16
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 8.40, (MethodHash=98e5ed55) for method AdvSimdMethods:LoadAndReplicateToVector128Test(long):System.Runtime.Intrinsics.Vector128`1[Byte]
; ============================================================


```
------------------------------------------------

### 34. LoadVector64

`Vector64<byte> LoadVector64(byte* address)`

Performs 'LoadVector64' operation.

```csharp
private Vector64<byte> LoadVector64Test(byte* address)
{
  return AdvSimd.LoadVector64(address);
}
// address = <address>
// Result = <11, 12, 13, 14, 15, 16, 17, 18>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<double> LoadVector64(double* address)
Vector64<short> LoadVector64(short* address)
Vector64<int> LoadVector64(int* address)
Vector64<long> LoadVector64(long* address)
Vector64<sbyte> LoadVector64(sbyte* address)
Vector64<float> LoadVector64(float* address)
Vector64<ushort> LoadVector64(ushort* address)
Vector64<uint> LoadVector64(uint* address)
Vector64<ulong> LoadVector64(ulong* address)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.loadvector64?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:LoadVector64Test(long):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00,T00] (  3,  3   )    long  ->   x0        
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 0

G_M60075_IG01:
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M60075_IG02:
            ld1     {v16.8b}, [x0]
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 2.50
G_M60075_IG03:
            ldp     fp, lr, [sp],#16
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 8.40, (MethodHash=e0841554) for method AdvSimdMethods:LoadVector64Test(long):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 35. LoadVector128

`Vector128<byte> LoadVector128(byte* address)`

Performs 'LoadVector128' operation.

```csharp
private Vector128<byte> LoadVector128Test(byte* address)
{
  return AdvSimd.LoadVector128(address);
}
// address = <address>
// Result = <11, 12, 13, 14, 15, 16, 17, 18, 0, 0, 0, 0, 0, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<double> LoadVector128(double* address)
Vector128<short> LoadVector128(short* address)
Vector128<int> LoadVector128(int* address)
Vector128<long> LoadVector128(long* address)
Vector128<sbyte> LoadVector128(sbyte* address)
Vector128<float> LoadVector128(float* address)
Vector128<ushort> LoadVector128(ushort* address)
Vector128<uint> LoadVector128(uint* address)
Vector128<ulong> LoadVector128(ulong* address)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.loadvector128?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:LoadVector128Test(long):System.Runtime.Intrinsics.Vector128`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00,T00] (  3,  3   )    long  ->   x0        
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 0

G_M62411_IG01:
            stp     fp, lr, [sp,#-16]!
            mov     fp, sp
						;; bbWeight=1    PerfScore 1.50
G_M62411_IG02:
            ld1     {v16.16b}, [x0]
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 3.50
G_M62411_IG03:
            ldp     fp, lr, [sp],#16
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 24, prolog size 8, PerfScore 9.40, (MethodHash=75110c34) for method AdvSimdMethods:LoadVector128Test(long):System.Runtime.Intrinsics.Vector128`1[Byte]
; ============================================================


```
------------------------------------------------

### 36. Max

`Vector64<byte> Max(Vector64<byte> left, Vector64<byte> right)`

Performs 'Max' operation.

```csharp
private Vector64<byte> MaxTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.Max(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <21, 22, 23, 24, 25, 26, 27, 28>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> Max(Vector64<short> left, Vector64<short> right)
Vector64<int> Max(Vector64<int> left, Vector64<int> right)
Vector64<sbyte> Max(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<float> Max(Vector64<float> left, Vector64<float> right)
Vector64<ushort> Max(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> Max(Vector64<uint> left, Vector64<uint> right)
Vector128<byte> Max(Vector128<byte> left, Vector128<byte> right)
Vector128<short> Max(Vector128<short> left, Vector128<short> right)
Vector128<int> Max(Vector128<int> left, Vector128<int> right)
Vector128<sbyte> Max(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<float> Max(Vector128<float> left, Vector128<float> right)
Vector128<ushort> Max(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> Max(Vector128<uint> left, Vector128<uint> right)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> Max(Vector128<double> left, Vector128<double> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.max?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.max?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MaxTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M53508_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M53508_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            umax    v16.8b, v16.8b, v17.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M53508_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=016a2efb) for method AdvSimdMethods:MaxTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 37. MaxNumber

`Vector64<float> MaxNumber(Vector64<float> left, Vector64<float> right)`

Performs 'MaxNumber' operation.

```csharp
private Vector64<float> MaxNumberTest(Vector64<float> left, Vector64<float> right)
{
  return AdvSimd.MaxNumber(left, right);
}
// left = <11.5, 12.5>
// right = <21.5, 22.5>
// Result = <21.5, 22.5>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<float> MaxNumber(Vector128<float> left, Vector128<float> right)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> MaxNumber(Vector128<double> left, Vector128<double> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.maxnumber?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.maxnumber?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MaxNumberTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M56215_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M56215_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            fmaxnm  v16.2s, v16.2s, v17.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M56215_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=06372468) for method AdvSimdMethods:MaxNumberTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 38. MaxNumberScalar

`Vector64<double> MaxNumberScalar(Vector64<double> left, Vector64<double> right)`

Performs 'MaxNumberScalar' operation.

```csharp
private Vector64<double> MaxNumberScalarTest(Vector64<double> left, Vector64<double> right)
{
  return AdvSimd.MaxNumberScalar(left, right);
}
// left = <11.5>
// right = <11.5>
// Result = <11.5>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<float> MaxNumberScalar(Vector64<float> left, Vector64<float> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.maxnumberscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MaxNumberScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M62230_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M62230_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            fmaxnm  d16, d16, d17
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M62230_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=ec8d0ce9) for method AdvSimdMethods:MaxNumberScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 39. MaxPairwise

`Vector64<byte> MaxPairwise(Vector64<byte> left, Vector64<byte> right)`

Performs 'MaxPairwise' operation.

```csharp
private Vector64<byte> MaxPairwiseTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.MaxPairwise(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <12, 14, 16, 18, 22, 24, 26, 28>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> MaxPairwise(Vector64<short> left, Vector64<short> right)
Vector64<int> MaxPairwise(Vector64<int> left, Vector64<int> right)
Vector64<sbyte> MaxPairwise(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<float> MaxPairwise(Vector64<float> left, Vector64<float> right)
Vector64<ushort> MaxPairwise(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> MaxPairwise(Vector64<uint> left, Vector64<uint> right)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<byte> MaxPairwise(Vector128<byte> left, Vector128<byte> right)
Vector128<double> MaxPairwise(Vector128<double> left, Vector128<double> right)
Vector128<short> MaxPairwise(Vector128<short> left, Vector128<short> right)
Vector128<int> MaxPairwise(Vector128<int> left, Vector128<int> right)
Vector128<sbyte> MaxPairwise(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<float> MaxPairwise(Vector128<float> left, Vector128<float> right)
Vector128<ushort> MaxPairwise(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> MaxPairwise(Vector128<uint> left, Vector128<uint> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.maxpairwise?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.maxpairwise?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MaxPairwiseTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M12294_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M12294_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            umaxp   v16.8b, v16.8b, v17.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M12294_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=9304cff9) for method AdvSimdMethods:MaxPairwiseTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 40. Min

`Vector64<byte> Min(Vector64<byte> left, Vector64<byte> right)`

Performs 'Min' operation.

```csharp
private Vector64<byte> MinTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.Min(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <11, 12, 13, 14, 15, 16, 17, 18>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> Min(Vector64<short> left, Vector64<short> right)
Vector64<int> Min(Vector64<int> left, Vector64<int> right)
Vector64<sbyte> Min(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<float> Min(Vector64<float> left, Vector64<float> right)
Vector64<ushort> Min(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> Min(Vector64<uint> left, Vector64<uint> right)
Vector128<byte> Min(Vector128<byte> left, Vector128<byte> right)
Vector128<short> Min(Vector128<short> left, Vector128<short> right)
Vector128<int> Min(Vector128<int> left, Vector128<int> right)
Vector128<sbyte> Min(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<float> Min(Vector128<float> left, Vector128<float> right)
Vector128<ushort> Min(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> Min(Vector128<uint> left, Vector128<uint> right)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> Min(Vector128<double> left, Vector128<double> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.min?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.min?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MinTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M10650_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M10650_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            umin    v16.8b, v16.8b, v17.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M10650_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=0551d665) for method AdvSimdMethods:MinTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 41. MinNumber

`Vector64<float> MinNumber(Vector64<float> left, Vector64<float> right)`

Performs 'MinNumber' operation.

```csharp
private Vector64<float> MinNumberTest(Vector64<float> left, Vector64<float> right)
{
  return AdvSimd.MinNumber(left, right);
}
// left = <11.5, 12.5>
// right = <21.5, 22.5>
// Result = <11.5, 12.5>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<float> MinNumber(Vector128<float> left, Vector128<float> right)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> MinNumber(Vector128<double> left, Vector128<double> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.minnumber?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.minnumber?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MinNumberTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M64265_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M64265_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            fminnm  v16.2s, v16.2s, v17.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M64265_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=3b7d04f6) for method AdvSimdMethods:MinNumberTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 42. MinNumberScalar

`Vector64<double> MinNumberScalar(Vector64<double> left, Vector64<double> right)`

Performs 'MinNumberScalar' operation.

```csharp
private Vector64<double> MinNumberScalarTest(Vector64<double> left, Vector64<double> right)
{
  return AdvSimd.MinNumberScalar(left, right);
}
// left = <11.5>
// right = <11.5>
// Result = <11.5>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<float> MinNumberScalar(Vector64<float> left, Vector64<float> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.minnumberscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MinNumberScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M2312_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M2312_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            fminnm  d16, d16, d17
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M2312_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=7a33f6f7) for method AdvSimdMethods:MinNumberScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 43. MinPairwise

`Vector64<byte> MinPairwise(Vector64<byte> left, Vector64<byte> right)`

Performs 'MinPairwise' operation.

```csharp
private Vector64<byte> MinPairwiseTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.MinPairwise(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <11, 13, 15, 17, 21, 23, 25, 27>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> MinPairwise(Vector64<short> left, Vector64<short> right)
Vector64<int> MinPairwise(Vector64<int> left, Vector64<int> right)
Vector64<sbyte> MinPairwise(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<float> MinPairwise(Vector64<float> left, Vector64<float> right)
Vector64<ushort> MinPairwise(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> MinPairwise(Vector64<uint> left, Vector64<uint> right)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<byte> MinPairwise(Vector128<byte> left, Vector128<byte> right)
Vector128<double> MinPairwise(Vector128<double> left, Vector128<double> right)
Vector128<short> MinPairwise(Vector128<short> left, Vector128<short> right)
Vector128<int> MinPairwise(Vector128<int> left, Vector128<int> right)
Vector128<sbyte> MinPairwise(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<float> MinPairwise(Vector128<float> left, Vector128<float> right)
Vector128<ushort> MinPairwise(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> MinPairwise(Vector128<uint> left, Vector128<uint> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.minpairwise?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.minpairwise?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MinPairwiseTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M15256_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M15256_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            uminp   v16.8b, v16.8b, v17.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M15256_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=eaedc467) for method AdvSimdMethods:MinPairwiseTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 44. Multiply

`Vector64<byte> Multiply(Vector64<byte> left, Vector64<byte> right)`

Performs 'Multiply' operation.

```csharp
private Vector64<byte> MultiplyTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.Multiply(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <231, 8, 43, 80, 119, 160, 203, 248>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> Multiply(Vector64<short> left, Vector64<short> right)
Vector64<int> Multiply(Vector64<int> left, Vector64<int> right)
Vector64<sbyte> Multiply(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<float> Multiply(Vector64<float> left, Vector64<float> right)
Vector64<ushort> Multiply(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> Multiply(Vector64<uint> left, Vector64<uint> right)
Vector128<byte> Multiply(Vector128<byte> left, Vector128<byte> right)
Vector128<short> Multiply(Vector128<short> left, Vector128<short> right)
Vector128<int> Multiply(Vector128<int> left, Vector128<int> right)
Vector128<sbyte> Multiply(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<float> Multiply(Vector128<float> left, Vector128<float> right)
Vector128<ushort> Multiply(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> Multiply(Vector128<uint> left, Vector128<uint> right)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> Multiply(Vector128<double> left, Vector128<double> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiply?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.multiply?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M48252_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M48252_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            mul     v16.8b, v16.8b, v17.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M48252_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=14434383) for method AdvSimdMethods:MultiplyTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 45. MultiplyAdd

`Vector64<byte> MultiplyAdd(Vector64<byte> addend, Vector64<byte> left, Vector64<byte> right)`

Performs 'MultiplyAdd' operation.

```csharp
private Vector64<byte> MultiplyAddTest(Vector64<byte> addend, Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.MultiplyAdd(addend, left, right);
}
// addend = <11, 12, 13, 14, 15, 16, 17, 18>
// left = <21, 22, 23, 24, 25, 26, 27, 28>
// right = <31, 32, 33, 34, 35, 36, 37, 38>
// Result = <150, 204, 4, 62, 122, 184, 248, 58>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> MultiplyAdd(Vector64<short> addend, Vector64<short> left, Vector64<short> right)
Vector64<int> MultiplyAdd(Vector64<int> addend, Vector64<int> left, Vector64<int> right)
Vector64<sbyte> MultiplyAdd(Vector64<sbyte> addend, Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<ushort> MultiplyAdd(Vector64<ushort> addend, Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> MultiplyAdd(Vector64<uint> addend, Vector64<uint> left, Vector64<uint> right)
Vector128<byte> MultiplyAdd(Vector128<byte> addend, Vector128<byte> left, Vector128<byte> right)
Vector128<short> MultiplyAdd(Vector128<short> addend, Vector128<short> left, Vector128<short> right)
Vector128<int> MultiplyAdd(Vector128<int> addend, Vector128<int> left, Vector128<int> right)
Vector128<sbyte> MultiplyAdd(Vector128<sbyte> addend, Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<ushort> MultiplyAdd(Vector128<ushort> addend, Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> MultiplyAdd(Vector128<uint> addend, Vector128<uint> left, Vector128<uint> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplyadd?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyAddTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x20]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M31244_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     d1, [fp,#32]
            str     d2, [fp,#24]
						;; bbWeight=1    PerfScore 4.50
G_M31244_IG02:
            ldr     d16, [fp,#40]
            ldr     d17, [fp,#32]
            ldr     d18, [fp,#24]
            mla     v16.8b, v17.8b, v18.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 9.50
G_M31244_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 20.80, (MethodHash=6b6185f3) for method AdvSimdMethods:MultiplyAddTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 46. MultiplyAddByScalar

`Vector64<short> MultiplyAddByScalar(Vector64<short> addend, Vector64<short> left, Vector64<short> right)`

Performs 'MultiplyAddByScalar' operation.

```csharp
private Vector64<short> MultiplyAddByScalarTest(Vector64<short> addend, Vector64<short> left, Vector64<short> right)
{
  return AdvSimd.MultiplyAddByScalar(addend, left, right);
}
// addend = <11, 12, 13, 14>
// left = <21, 22, 23, 24>
// right = <31, 32, 33, 34>
// Result = <662, 694, 726, 758>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<int> MultiplyAddByScalar(Vector64<int> addend, Vector64<int> left, Vector64<int> right)
Vector64<ushort> MultiplyAddByScalar(Vector64<ushort> addend, Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> MultiplyAddByScalar(Vector64<uint> addend, Vector64<uint> left, Vector64<uint> right)
Vector128<short> MultiplyAddByScalar(Vector128<short> addend, Vector128<short> left, Vector64<short> right)
Vector128<int> MultiplyAddByScalar(Vector128<int> addend, Vector128<int> left, Vector64<int> right)
Vector128<ushort> MultiplyAddByScalar(Vector128<ushort> addend, Vector128<ushort> left, Vector64<ushort> right)
Vector128<uint> MultiplyAddByScalar(Vector128<uint> addend, Vector128<uint> left, Vector64<uint> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplyaddbyscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyAddByScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x20]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M57977_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     d1, [fp,#32]
            str     d2, [fp,#24]
						;; bbWeight=1    PerfScore 4.50
G_M57977_IG02:
            ldr     d16, [fp,#40]
            ldr     d17, [fp,#32]
            ldr     d7, [fp,#24]
            mla     v16.4h, v17.4h, v7.h[0]
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 9.50
G_M57977_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 20.80, (MethodHash=f9521d86) for method AdvSimdMethods:MultiplyAddByScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 47. MultiplyAddBySelectedScalar

`Vector64<short> MultiplyAddBySelectedScalar(Vector64<short> addend, Vector64<short> left, Vector64<short> right, byte rightIndex)`

Performs 'MultiplyAddBySelectedScalar' operation.

```csharp
private Vector64<short> MultiplyAddBySelectedScalarTest(Vector64<short> addend, Vector64<short> left, Vector64<short> right, byte rightIndex)
{
  return AdvSimd.MultiplyAddBySelectedScalar(addend, left, right, rightIndex);
}
// addend = <11, 12, 13, 14>
// left = <21, 22, 23, 24>
// right = <31, 32, 33, 34>
// rightIndex = 0
// Result = <662, 694, 726, 758>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> MultiplyAddBySelectedScalar(Vector64<short> addend, Vector64<short> left, Vector128<short> right, byte rightIndex)
Vector64<int> MultiplyAddBySelectedScalar(Vector64<int> addend, Vector64<int> left, Vector64<int> right, byte rightIndex)
Vector64<int> MultiplyAddBySelectedScalar(Vector64<int> addend, Vector64<int> left, Vector128<int> right, byte rightIndex)
Vector64<ushort> MultiplyAddBySelectedScalar(Vector64<ushort> addend, Vector64<ushort> left, Vector64<ushort> right, byte rightIndex)
Vector64<ushort> MultiplyAddBySelectedScalar(Vector64<ushort> addend, Vector64<ushort> left, Vector128<ushort> right, byte rightIndex)
Vector64<uint> MultiplyAddBySelectedScalar(Vector64<uint> addend, Vector64<uint> left, Vector64<uint> right, byte rightIndex)
Vector64<uint> MultiplyAddBySelectedScalar(Vector64<uint> addend, Vector64<uint> left, Vector128<uint> right, byte rightIndex)
Vector128<short> MultiplyAddBySelectedScalar(Vector128<short> addend, Vector128<short> left, Vector64<short> right, byte rightIndex)
Vector128<short> MultiplyAddBySelectedScalar(Vector128<short> addend, Vector128<short> left, Vector128<short> right, byte rightIndex)
Vector128<int> MultiplyAddBySelectedScalar(Vector128<int> addend, Vector128<int> left, Vector64<int> right, byte rightIndex)
Vector128<int> MultiplyAddBySelectedScalar(Vector128<int> addend, Vector128<int> left, Vector128<int> right, byte rightIndex)
Vector128<ushort> MultiplyAddBySelectedScalar(Vector128<ushort> addend, Vector128<ushort> left, Vector64<ushort> right, byte rightIndex)
Vector128<ushort> MultiplyAddBySelectedScalar(Vector128<ushort> addend, Vector128<ushort> left, Vector128<ushort> right, byte rightIndex)
Vector128<uint> MultiplyAddBySelectedScalar(Vector128<uint> addend, Vector128<uint> left, Vector64<uint> right, byte rightIndex)
Vector128<uint> MultiplyAddBySelectedScalar(Vector128<uint> addend, Vector128<uint> left, Vector128<uint> right, byte rightIndex)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplyaddbyselectedscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyAddBySelectedScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x20]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V03 arg3         [V03,T00] (  3,  3   )   ubyte  ->   x0        
;# V04 OutArgs      [V04    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V05 tmp1         [V05,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V06 tmp2         [V06,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;  V07 tmp3         [V07,T03] (  2,  4   )   simd8  ->   d2         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 32

G_M24291_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     d1, [fp,#32]
            str     d2, [fp,#24]
						;; bbWeight=1    PerfScore 4.50
G_M24291_IG02:
            ldr     d0, [fp,#40]
            ldr     d1, [fp,#32]
            ldr     d2, [fp,#24]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:MultiplyAddBySelectedScalar(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
						;; bbWeight=1    PerfScore 7.50
G_M24291_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 18.80, (MethodHash=db83a11c) for method AdvSimdMethods:MultiplyAddBySelectedScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 48. MultiplyByScalar

`Vector64<short> MultiplyByScalar(Vector64<short> left, Vector64<short> right)`

Performs 'MultiplyByScalar' operation.

```csharp
private Vector64<short> MultiplyByScalarTest(Vector64<short> left, Vector64<short> right)
{
  return AdvSimd.MultiplyByScalar(left, right);
}
// left = <11, 12, 13, 14>
// right = <21, 22, 23, 24>
// Result = <231, 252, 273, 294>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<int> MultiplyByScalar(Vector64<int> left, Vector64<int> right)
Vector64<float> MultiplyByScalar(Vector64<float> left, Vector64<float> right)
Vector64<ushort> MultiplyByScalar(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> MultiplyByScalar(Vector64<uint> left, Vector64<uint> right)
Vector128<short> MultiplyByScalar(Vector128<short> left, Vector64<short> right)
Vector128<int> MultiplyByScalar(Vector128<int> left, Vector64<int> right)
Vector128<float> MultiplyByScalar(Vector128<float> left, Vector64<float> right)
Vector128<ushort> MultiplyByScalar(Vector128<ushort> left, Vector64<ushort> right)
Vector128<uint> MultiplyByScalar(Vector128<uint> left, Vector64<uint> right)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> MultiplyByScalar(Vector128<double> left, Vector64<double> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplybyscalar?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.multiplybyscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyByScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M18007_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M18007_IG02:
            ldr     d16, [fp,#24]
            ldr     d7, [fp,#16]
            mul     v16.4h, v16.4h, v7.h[0]
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M18007_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=3ef9b9a8) for method AdvSimdMethods:MultiplyByScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 49. MultiplyBySelectedScalar

`Vector64<short> MultiplyBySelectedScalar(Vector64<short> left, Vector64<short> right, byte rightIndex)`

Performs 'MultiplyBySelectedScalar' operation.

```csharp
private Vector64<short> MultiplyBySelectedScalarTest(Vector64<short> left, Vector64<short> right, byte rightIndex)
{
  return AdvSimd.MultiplyBySelectedScalar(left, right, rightIndex);
}
// left = <11, 12, 13, 14>
// right = <21, 22, 23, 24>
// rightIndex = 0
// Result = <231, 252, 273, 294>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> MultiplyBySelectedScalar(Vector64<short> left, Vector128<short> right, byte rightIndex)
Vector64<int> MultiplyBySelectedScalar(Vector64<int> left, Vector64<int> right, byte rightIndex)
Vector64<int> MultiplyBySelectedScalar(Vector64<int> left, Vector128<int> right, byte rightIndex)
Vector64<float> MultiplyBySelectedScalar(Vector64<float> left, Vector64<float> right, byte rightIndex)
Vector64<float> MultiplyBySelectedScalar(Vector64<float> left, Vector128<float> right, byte rightIndex)
Vector64<ushort> MultiplyBySelectedScalar(Vector64<ushort> left, Vector64<ushort> right, byte rightIndex)
Vector64<ushort> MultiplyBySelectedScalar(Vector64<ushort> left, Vector128<ushort> right, byte rightIndex)
Vector64<uint> MultiplyBySelectedScalar(Vector64<uint> left, Vector64<uint> right, byte rightIndex)
Vector64<uint> MultiplyBySelectedScalar(Vector64<uint> left, Vector128<uint> right, byte rightIndex)
Vector128<short> MultiplyBySelectedScalar(Vector128<short> left, Vector64<short> right, byte rightIndex)
Vector128<short> MultiplyBySelectedScalar(Vector128<short> left, Vector128<short> right, byte rightIndex)
Vector128<int> MultiplyBySelectedScalar(Vector128<int> left, Vector64<int> right, byte rightIndex)
Vector128<int> MultiplyBySelectedScalar(Vector128<int> left, Vector128<int> right, byte rightIndex)
Vector128<float> MultiplyBySelectedScalar(Vector128<float> left, Vector64<float> right, byte rightIndex)
Vector128<float> MultiplyBySelectedScalar(Vector128<float> left, Vector128<float> right, byte rightIndex)
Vector128<ushort> MultiplyBySelectedScalar(Vector128<ushort> left, Vector64<ushort> right, byte rightIndex)
Vector128<ushort> MultiplyBySelectedScalar(Vector128<ushort> left, Vector128<ushort> right, byte rightIndex)
Vector128<uint> MultiplyBySelectedScalar(Vector128<uint> left, Vector64<uint> right, byte rightIndex)
Vector128<uint> MultiplyBySelectedScalar(Vector128<uint> left, Vector128<uint> right, byte rightIndex)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> MultiplyBySelectedScalar(Vector128<double> left, Vector128<double> right, byte rightIndex)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplybyselectedscalar?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.multiplybyselectedscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyBySelectedScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M59917_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M59917_IG02:
            ldr     d0, [fp,#24]
            ldr     d1, [fp,#16]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:MultiplyBySelectedScalar(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
						;; bbWeight=1    PerfScore 5.50
G_M59917_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=36dc15f2) for method AdvSimdMethods:MultiplyBySelectedScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 50. MultiplyBySelectedScalarWideningLower

`Vector128<int> MultiplyBySelectedScalarWideningLower(Vector64<short> left, Vector64<short> right, byte rightIndex)`

Performs 'MultiplyBySelectedScalarWideningLower' operation.

```csharp
private Vector128<int> MultiplyBySelectedScalarWideningLowerTest(Vector64<short> left, Vector64<short> right, byte rightIndex)
{
  return AdvSimd.MultiplyBySelectedScalarWideningLower(left, right, rightIndex);
}
// left = <11, 12, 13, 14>
// right = <21, 22, 23, 24>
// rightIndex = 0
// Result = <231, 252, 273, 294>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<int> MultiplyBySelectedScalarWideningLower(Vector64<short> left, Vector128<short> right, byte rightIndex)
Vector128<long> MultiplyBySelectedScalarWideningLower(Vector64<int> left, Vector64<int> right, byte rightIndex)
Vector128<long> MultiplyBySelectedScalarWideningLower(Vector64<int> left, Vector128<int> right, byte rightIndex)
Vector128<uint> MultiplyBySelectedScalarWideningLower(Vector64<ushort> left, Vector64<ushort> right, byte rightIndex)
Vector128<uint> MultiplyBySelectedScalarWideningLower(Vector64<ushort> left, Vector128<ushort> right, byte rightIndex)
Vector128<ulong> MultiplyBySelectedScalarWideningLower(Vector64<uint> left, Vector64<uint> right, byte rightIndex)
Vector128<ulong> MultiplyBySelectedScalarWideningLower(Vector64<uint> left, Vector128<uint> right, byte rightIndex)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplybyselectedscalarwideninglower?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyBySelectedScalarWideningLowerTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M35040_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M35040_IG02:
            ldr     d0, [fp,#24]
            ldr     d1, [fp,#16]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:MultiplyBySelectedScalarWideningLower(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
						;; bbWeight=1    PerfScore 5.50
G_M35040_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=05e5771f) for method AdvSimdMethods:MultiplyBySelectedScalarWideningLowerTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
; ============================================================


```
------------------------------------------------

### 51. MultiplyBySelectedScalarWideningLowerAndAdd

`Vector128<int> MultiplyBySelectedScalarWideningLowerAndAdd(Vector128<int> addend, Vector64<short> left, Vector64<short> right, byte rightIndex)`

Performs 'MultiplyBySelectedScalarWideningLowerAndAdd' operation.

```csharp
private Vector128<int> MultiplyBySelectedScalarWideningLowerAndAddTest(Vector128<int> addend, Vector64<short> left, Vector64<short> right, byte rightIndex)
{
  return AdvSimd.MultiplyBySelectedScalarWideningLowerAndAdd(addend, left, right, rightIndex);
}
// addend = <11, 12, 13, 14>
// left = <11, 12, 13, 14>
// right = <21, 22, 23, 24>
// rightIndex = 0
// Result = <242, 264, 286, 308>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<int> MultiplyBySelectedScalarWideningLowerAndAdd(Vector128<int> addend, Vector64<short> left, Vector128<short> right, byte rightIndex)
Vector128<long> MultiplyBySelectedScalarWideningLowerAndAdd(Vector128<long> addend, Vector64<int> left, Vector64<int> right, byte rightIndex)
Vector128<long> MultiplyBySelectedScalarWideningLowerAndAdd(Vector128<long> addend, Vector64<int> left, Vector128<int> right, byte rightIndex)
Vector128<uint> MultiplyBySelectedScalarWideningLowerAndAdd(Vector128<uint> addend, Vector64<ushort> left, Vector64<ushort> right, byte rightIndex)
Vector128<uint> MultiplyBySelectedScalarWideningLowerAndAdd(Vector128<uint> addend, Vector64<ushort> left, Vector128<ushort> right, byte rightIndex)
Vector128<ulong> MultiplyBySelectedScalarWideningLowerAndAdd(Vector128<ulong> addend, Vector64<uint> left, Vector64<uint> right, byte rightIndex)
Vector128<ulong> MultiplyBySelectedScalarWideningLowerAndAdd(Vector128<ulong> addend, Vector64<uint> left, Vector128<uint> right, byte rightIndex)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplybyselectedscalarwideninglowerandadd?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyBySelectedScalarWideningLowerAndAddTest(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V03 arg3         [V03,T00] (  3,  3   )   ubyte  ->   x0        
;# V04 OutArgs      [V04    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V05 tmp1         [V05,T01] (  2,  4   )  simd16  ->   d0         HFA(simd16)  "Inlining Arg"
;  V06 tmp2         [V06,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;  V07 tmp3         [V07,T03] (  2,  4   )   simd8  ->   d2         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 32

G_M15162_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     q0, [fp,#32]
            str     d1, [fp,#24]
            str     d2, [fp,#16]
						;; bbWeight=1    PerfScore 4.50
G_M15162_IG02:
            ldr     q0, [fp,#32]
            ldr     d1, [fp,#24]
            ldr     d2, [fp,#16]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:MultiplyBySelectedScalarWideningLowerAndAdd(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
						;; bbWeight=1    PerfScore 7.50
G_M15162_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 18.80, (MethodHash=66b0c4c5) for method AdvSimdMethods:MultiplyBySelectedScalarWideningLowerAndAddTest(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
; ============================================================


```
------------------------------------------------

### 52. MultiplyBySelectedScalarWideningLowerAndSubtract

`Vector128<int> MultiplyBySelectedScalarWideningLowerAndSubtract(Vector128<int> minuend, Vector64<short> left, Vector64<short> right, byte rightIndex)`

Performs 'MultiplyBySelectedScalarWideningLowerAndSubtract' operation.

```csharp
private Vector128<int> MultiplyBySelectedScalarWideningLowerAndSubtractTest(Vector128<int> minuend, Vector64<short> left, Vector64<short> right, byte rightIndex)
{
  return AdvSimd.MultiplyBySelectedScalarWideningLowerAndSubtract(minuend, left, right, rightIndex);
}
// minuend = <11, 12, 13, 14>
// left = <11, 12, 13, 14>
// right = <21, 22, 23, 24>
// rightIndex = 0
// Result = <-220, -240, -260, -280>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<int> MultiplyBySelectedScalarWideningLowerAndSubtract(Vector128<int> minuend, Vector64<short> left, Vector128<short> right, byte rightIndex)
Vector128<long> MultiplyBySelectedScalarWideningLowerAndSubtract(Vector128<long> minuend, Vector64<int> left, Vector64<int> right, byte rightIndex)
Vector128<long> MultiplyBySelectedScalarWideningLowerAndSubtract(Vector128<long> minuend, Vector64<int> left, Vector128<int> right, byte rightIndex)
Vector128<uint> MultiplyBySelectedScalarWideningLowerAndSubtract(Vector128<uint> minuend, Vector64<ushort> left, Vector64<ushort> right, byte rightIndex)
Vector128<uint> MultiplyBySelectedScalarWideningLowerAndSubtract(Vector128<uint> minuend, Vector64<ushort> left, Vector128<ushort> right, byte rightIndex)
Vector128<ulong> MultiplyBySelectedScalarWideningLowerAndSubtract(Vector128<ulong> minuend, Vector64<uint> left, Vector64<uint> right, byte rightIndex)
Vector128<ulong> MultiplyBySelectedScalarWideningLowerAndSubtract(Vector128<ulong> minuend, Vector64<uint> left, Vector128<uint> right, byte rightIndex)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplybyselectedscalarwideninglowerandsubtract?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyBySelectedScalarWideningLowerAndSubtractTest(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V03 arg3         [V03,T00] (  3,  3   )   ubyte  ->   x0        
;# V04 OutArgs      [V04    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V05 tmp1         [V05,T01] (  2,  4   )  simd16  ->   d0         HFA(simd16)  "Inlining Arg"
;  V06 tmp2         [V06,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;  V07 tmp3         [V07,T03] (  2,  4   )   simd8  ->   d2         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 32

G_M24687_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     q0, [fp,#32]
            str     d1, [fp,#24]
            str     d2, [fp,#16]
						;; bbWeight=1    PerfScore 4.50
G_M24687_IG02:
            ldr     q0, [fp,#32]
            ldr     d1, [fp,#24]
            ldr     d2, [fp,#16]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:MultiplyBySelectedScalarWideningLowerAndSubtract(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
						;; bbWeight=1    PerfScore 7.50
G_M24687_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 18.80, (MethodHash=1e629f90) for method AdvSimdMethods:MultiplyBySelectedScalarWideningLowerAndSubtractTest(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
; ============================================================


```
------------------------------------------------

### 53. MultiplyBySelectedScalarWideningUpper

`Vector128<int> MultiplyBySelectedScalarWideningUpper(Vector128<short> left, Vector64<short> right, byte rightIndex)`

Performs 'MultiplyBySelectedScalarWideningUpper' operation.

```csharp
private Vector128<int> MultiplyBySelectedScalarWideningUpperTest(Vector128<short> left, Vector64<short> right, byte rightIndex)
{
  return AdvSimd.MultiplyBySelectedScalarWideningUpper(left, right, rightIndex);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <11, 12, 13, 14>
// rightIndex = 0
// Result = <165, 176, 187, 198>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<int> MultiplyBySelectedScalarWideningUpper(Vector128<short> left, Vector128<short> right, byte rightIndex)
Vector128<long> MultiplyBySelectedScalarWideningUpper(Vector128<int> left, Vector64<int> right, byte rightIndex)
Vector128<long> MultiplyBySelectedScalarWideningUpper(Vector128<int> left, Vector128<int> right, byte rightIndex)
Vector128<uint> MultiplyBySelectedScalarWideningUpper(Vector128<ushort> left, Vector64<ushort> right, byte rightIndex)
Vector128<uint> MultiplyBySelectedScalarWideningUpper(Vector128<ushort> left, Vector128<ushort> right, byte rightIndex)
Vector128<ulong> MultiplyBySelectedScalarWideningUpper(Vector128<uint> left, Vector64<uint> right, byte rightIndex)
Vector128<ulong> MultiplyBySelectedScalarWideningUpper(Vector128<uint> left, Vector128<uint> right, byte rightIndex)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplybyselectedscalarwideningupper?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyBySelectedScalarWideningUpperTest(System.Runtime.Intrinsics.Vector128`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T01] (  2,  4   )  simd16  ->   d0         HFA(simd16)  "Inlining Arg"
;  V05 tmp2         [V05,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 32

G_M8856_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     q0, [fp,#32]
            str     d1, [fp,#24]
						;; bbWeight=1    PerfScore 3.50
G_M8856_IG02:
            ldr     q0, [fp,#32]
            ldr     d1, [fp,#24]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:MultiplyBySelectedScalarWideningUpper(System.Runtime.Intrinsics.Vector128`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
						;; bbWeight=1    PerfScore 5.50
G_M8856_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=b8bcdd67) for method AdvSimdMethods:MultiplyBySelectedScalarWideningUpperTest(System.Runtime.Intrinsics.Vector128`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
; ============================================================


```
------------------------------------------------

### 54. MultiplyBySelectedScalarWideningUpperAndAdd

`Vector128<int> MultiplyBySelectedScalarWideningUpperAndAdd(Vector128<int> addend, Vector128<short> left, Vector64<short> right, byte rightIndex)`

Performs 'MultiplyBySelectedScalarWideningUpperAndAdd' operation.

```csharp
private Vector128<int> MultiplyBySelectedScalarWideningUpperAndAddTest(Vector128<int> addend, Vector128<short> left, Vector64<short> right, byte rightIndex)
{
  return AdvSimd.MultiplyBySelectedScalarWideningUpperAndAdd(addend, left, right, rightIndex);
}
// addend = <11, 12, 13, 14>
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <11, 12, 13, 14>
// rightIndex = 0
// Result = <176, 188, 200, 212>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<int> MultiplyBySelectedScalarWideningUpperAndAdd(Vector128<int> addend, Vector128<short> left, Vector128<short> right, byte rightIndex)
Vector128<long> MultiplyBySelectedScalarWideningUpperAndAdd(Vector128<long> addend, Vector128<int> left, Vector64<int> right, byte rightIndex)
Vector128<long> MultiplyBySelectedScalarWideningUpperAndAdd(Vector128<long> addend, Vector128<int> left, Vector128<int> right, byte rightIndex)
Vector128<uint> MultiplyBySelectedScalarWideningUpperAndAdd(Vector128<uint> addend, Vector128<ushort> left, Vector64<ushort> right, byte rightIndex)
Vector128<uint> MultiplyBySelectedScalarWideningUpperAndAdd(Vector128<uint> addend, Vector128<ushort> left, Vector128<ushort> right, byte rightIndex)
Vector128<ulong> MultiplyBySelectedScalarWideningUpperAndAdd(Vector128<ulong> addend, Vector128<uint> left, Vector64<uint> right, byte rightIndex)
Vector128<ulong> MultiplyBySelectedScalarWideningUpperAndAdd(Vector128<ulong> addend, Vector128<uint> left, Vector128<uint> right, byte rightIndex)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplybyselectedscalarwideningupperandadd?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyBySelectedScalarWideningUpperAndAddTest(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector128`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x30]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V03 arg3         [V03,T00] (  3,  3   )   ubyte  ->   x0        
;# V04 OutArgs      [V04    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V05 tmp1         [V05,T01] (  2,  4   )  simd16  ->   d0         HFA(simd16)  "Inlining Arg"
;  V06 tmp2         [V06,T02] (  2,  4   )  simd16  ->   d1         HFA(simd16)  "Inlining Arg"
;  V07 tmp3         [V07,T03] (  2,  4   )   simd8  ->   d2         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 48

G_M25826_IG01:
            stp     fp, lr, [sp,#-64]!
            mov     fp, sp
            str     q0, [fp,#48]
            str     q1, [fp,#32]
            str     d2, [fp,#24]
						;; bbWeight=1    PerfScore 4.50
G_M25826_IG02:
            ldr     q0, [fp,#48]
            ldr     q1, [fp,#32]
            ldr     d2, [fp,#24]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:MultiplyBySelectedScalarWideningUpperAndAdd(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector128`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
						;; bbWeight=1    PerfScore 7.50
G_M25826_IG03:
            ldp     fp, lr, [sp],#64
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 18.80, (MethodHash=f2549b1d) for method AdvSimdMethods:MultiplyBySelectedScalarWideningUpperAndAddTest(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector128`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
; ============================================================


```
------------------------------------------------

### 55. MultiplyBySelectedScalarWideningUpperAndSubtract

`Vector128<int> MultiplyBySelectedScalarWideningUpperAndSubtract(Vector128<int> minuend, Vector128<short> left, Vector64<short> right, byte rightIndex)`

Performs 'MultiplyBySelectedScalarWideningUpperAndSubtract' operation.

```csharp
private Vector128<int> MultiplyBySelectedScalarWideningUpperAndSubtractTest(Vector128<int> minuend, Vector128<short> left, Vector64<short> right, byte rightIndex)
{
  return AdvSimd.MultiplyBySelectedScalarWideningUpperAndSubtract(minuend, left, right, rightIndex);
}
// minuend = <11, 12, 13, 14>
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <11, 12, 13, 14>
// rightIndex = 0
// Result = <-154, -164, -174, -184>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<int> MultiplyBySelectedScalarWideningUpperAndSubtract(Vector128<int> minuend, Vector128<short> left, Vector128<short> right, byte rightIndex)
Vector128<long> MultiplyBySelectedScalarWideningUpperAndSubtract(Vector128<long> minuend, Vector128<int> left, Vector64<int> right, byte rightIndex)
Vector128<long> MultiplyBySelectedScalarWideningUpperAndSubtract(Vector128<long> minuend, Vector128<int> left, Vector128<int> right, byte rightIndex)
Vector128<uint> MultiplyBySelectedScalarWideningUpperAndSubtract(Vector128<uint> minuend, Vector128<ushort> left, Vector64<ushort> right, byte rightIndex)
Vector128<uint> MultiplyBySelectedScalarWideningUpperAndSubtract(Vector128<uint> minuend, Vector128<ushort> left, Vector128<ushort> right, byte rightIndex)
Vector128<ulong> MultiplyBySelectedScalarWideningUpperAndSubtract(Vector128<ulong> minuend, Vector128<uint> left, Vector64<uint> right, byte rightIndex)
Vector128<ulong> MultiplyBySelectedScalarWideningUpperAndSubtract(Vector128<ulong> minuend, Vector128<uint> left, Vector128<uint> right, byte rightIndex)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplybyselectedscalarwideningupperandsubtract?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyBySelectedScalarWideningUpperAndSubtractTest(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector128`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x30]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V03 arg3         [V03,T00] (  3,  3   )   ubyte  ->   x0        
;# V04 OutArgs      [V04    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V05 tmp1         [V05,T01] (  2,  4   )  simd16  ->   d0         HFA(simd16)  "Inlining Arg"
;  V06 tmp2         [V06,T02] (  2,  4   )  simd16  ->   d1         HFA(simd16)  "Inlining Arg"
;  V07 tmp3         [V07,T03] (  2,  4   )   simd8  ->   d2         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 48

G_M35127_IG01:
            stp     fp, lr, [sp,#-64]!
            mov     fp, sp
            str     q0, [fp,#48]
            str     q1, [fp,#32]
            str     d2, [fp,#24]
						;; bbWeight=1    PerfScore 4.50
G_M35127_IG02:
            ldr     q0, [fp,#48]
            ldr     q1, [fp,#32]
            ldr     d2, [fp,#24]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:MultiplyBySelectedScalarWideningUpperAndSubtract(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector128`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
						;; bbWeight=1    PerfScore 7.50
G_M35127_IG03:
            ldp     fp, lr, [sp],#64
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 18.80, (MethodHash=bad976c8) for method AdvSimdMethods:MultiplyBySelectedScalarWideningUpperAndSubtractTest(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector128`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
; ============================================================


```
------------------------------------------------

### 56. MultiplyDoublingByScalarSaturateHigh

`Vector64<short> MultiplyDoublingByScalarSaturateHigh(Vector64<short> left, Vector64<short> right)`

Performs 'MultiplyDoublingByScalarSaturateHigh' operation.

```csharp
private Vector64<short> MultiplyDoublingByScalarSaturateHighTest(Vector64<short> left, Vector64<short> right)
{
  return AdvSimd.MultiplyDoublingByScalarSaturateHigh(left, right);
}
// left = <11, 12, 13, 14>
// right = <21, 22, 23, 24>
// Result = <0, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<int> MultiplyDoublingByScalarSaturateHigh(Vector64<int> left, Vector64<int> right)
Vector128<short> MultiplyDoublingByScalarSaturateHigh(Vector128<short> left, Vector64<short> right)
Vector128<int> MultiplyDoublingByScalarSaturateHigh(Vector128<int> left, Vector64<int> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplydoublingbyscalarsaturatehigh?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyDoublingByScalarSaturateHighTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M21816_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M21816_IG02:
            ldr     d16, [fp,#24]
            ldr     d7, [fp,#16]
            sqdmulh v16.4h, v16.4h, v7.h[0]
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M21816_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=d12aaac7) for method AdvSimdMethods:MultiplyDoublingByScalarSaturateHighTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 57. MultiplyDoublingBySelectedScalarSaturateHigh

`Vector64<short> MultiplyDoublingBySelectedScalarSaturateHigh(Vector64<short> left, Vector64<short> right, byte rightIndex)`

Performs 'MultiplyDoublingBySelectedScalarSaturateHigh' operation.

```csharp
private Vector64<short> MultiplyDoublingBySelectedScalarSaturateHighTest(Vector64<short> left, Vector64<short> right, byte rightIndex)
{
  return AdvSimd.MultiplyDoublingBySelectedScalarSaturateHigh(left, right, rightIndex);
}
// left = <11, 12, 13, 14>
// right = <21, 22, 23, 24>
// rightIndex = 0
// Result = <0, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> MultiplyDoublingBySelectedScalarSaturateHigh(Vector64<short> left, Vector128<short> right, byte rightIndex)
Vector64<int> MultiplyDoublingBySelectedScalarSaturateHigh(Vector64<int> left, Vector64<int> right, byte rightIndex)
Vector64<int> MultiplyDoublingBySelectedScalarSaturateHigh(Vector64<int> left, Vector128<int> right, byte rightIndex)
Vector128<short> MultiplyDoublingBySelectedScalarSaturateHigh(Vector128<short> left, Vector64<short> right, byte rightIndex)
Vector128<short> MultiplyDoublingBySelectedScalarSaturateHigh(Vector128<short> left, Vector128<short> right, byte rightIndex)
Vector128<int> MultiplyDoublingBySelectedScalarSaturateHigh(Vector128<int> left, Vector64<int> right, byte rightIndex)
Vector128<int> MultiplyDoublingBySelectedScalarSaturateHigh(Vector128<int> left, Vector128<int> right, byte rightIndex)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplydoublingbyselectedscalarsaturatehigh?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyDoublingBySelectedScalarSaturateHighTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M46434_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M46434_IG02:
            ldr     d0, [fp,#24]
            ldr     d1, [fp,#16]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:MultiplyDoublingBySelectedScalarSaturateHigh(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
						;; bbWeight=1    PerfScore 5.50
G_M46434_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=e60b4a9d) for method AdvSimdMethods:MultiplyDoublingBySelectedScalarSaturateHighTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 58. MultiplyDoublingSaturateHigh

`Vector64<short> MultiplyDoublingSaturateHigh(Vector64<short> left, Vector64<short> right)`

Performs 'MultiplyDoublingSaturateHigh' operation.

```csharp
private Vector64<short> MultiplyDoublingSaturateHighTest(Vector64<short> left, Vector64<short> right)
{
  return AdvSimd.MultiplyDoublingSaturateHigh(left, right);
}
// left = <11, 12, 13, 14>
// right = <21, 22, 23, 24>
// Result = <0, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<int> MultiplyDoublingSaturateHigh(Vector64<int> left, Vector64<int> right)
Vector128<short> MultiplyDoublingSaturateHigh(Vector128<short> left, Vector128<short> right)
Vector128<int> MultiplyDoublingSaturateHigh(Vector128<int> left, Vector128<int> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplydoublingsaturatehigh?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyDoublingSaturateHighTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M29357_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M29357_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            sqdmulh v16.4h, v16.4h, v17.4h
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M29357_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=d3cd8d52) for method AdvSimdMethods:MultiplyDoublingSaturateHighTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 59. MultiplyDoublingWideningLowerAndAddSaturate

`Vector128<int> MultiplyDoublingWideningLowerAndAddSaturate(Vector128<int> addend, Vector64<short> left, Vector64<short> right)`

Performs 'MultiplyDoublingWideningLowerAndAddSaturate' operation.

```csharp
private Vector128<int> MultiplyDoublingWideningLowerAndAddSaturateTest(Vector128<int> addend, Vector64<short> left, Vector64<short> right)
{
  return AdvSimd.MultiplyDoublingWideningLowerAndAddSaturate(addend, left, right);
}
// addend = <11, 12, 13, 14>
// left = <11, 12, 13, 14>
// right = <21, 22, 23, 24>
// Result = <473, 540, 611, 686>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<long> MultiplyDoublingWideningLowerAndAddSaturate(Vector128<long> addend, Vector64<int> left, Vector64<int> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplydoublingwideninglowerandaddsaturate?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyDoublingWideningLowerAndAddSaturateTest(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector128`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M27124_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     q0, [fp,#32]
            str     d1, [fp,#24]
            str     d2, [fp,#16]
						;; bbWeight=1    PerfScore 4.50
G_M27124_IG02:
            ldr     q16, [fp,#32]
            ldr     d17, [fp,#24]
            ldr     d18, [fp,#16]
            sqdmlal v16.4s, v17.4h, v18.4h
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 9.50
G_M27124_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 20.80, (MethodHash=061c960b) for method AdvSimdMethods:MultiplyDoublingWideningLowerAndAddSaturateTest(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector128`1[Int32]
; ============================================================


```
------------------------------------------------

### 60. MultiplyDoublingWideningLowerAndSubtractSaturate

`Vector128<int> MultiplyDoublingWideningLowerAndSubtractSaturate(Vector128<int> minuend, Vector64<short> left, Vector64<short> right)`

Performs 'MultiplyDoublingWideningLowerAndSubtractSaturate' operation.

```csharp
private Vector128<int> MultiplyDoublingWideningLowerAndSubtractSaturateTest(Vector128<int> minuend, Vector64<short> left, Vector64<short> right)
{
  return AdvSimd.MultiplyDoublingWideningLowerAndSubtractSaturate(minuend, left, right);
}
// minuend = <11, 12, 13, 14>
// left = <11, 12, 13, 14>
// right = <21, 22, 23, 24>
// Result = <-451, -516, -585, -658>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<long> MultiplyDoublingWideningLowerAndSubtractSaturate(Vector128<long> minuend, Vector64<int> left, Vector64<int> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplydoublingwideninglowerandsubtractsaturate?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyDoublingWideningLowerAndSubtractSaturateTest(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector128`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M22753_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     q0, [fp,#32]
            str     d1, [fp,#24]
            str     d2, [fp,#16]
						;; bbWeight=1    PerfScore 4.50
G_M22753_IG02:
            ldr     q16, [fp,#32]
            ldr     d17, [fp,#24]
            ldr     d18, [fp,#16]
            sqdmlsl v16.4s, v17.4h, v18.4h
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 9.50
G_M22753_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 20.80, (MethodHash=6622a71e) for method AdvSimdMethods:MultiplyDoublingWideningLowerAndSubtractSaturateTest(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector128`1[Int32]
; ============================================================

```

---
STARTlayout:post
title: Hardware Intrinsics APIs for ARM64 - Part 3
subtitle: With examples
tags: [work, arm64, intrinsics]
---

### Introduction

In my [last post](../2019-01-01-Vectorization-APIs), I describe SIMD datatypes `Vector64<T>` and `Vector128<T>` that operates on 'hardware intrisic' APIs. In this post I will describe the intrinsic APIs for ARM64 and how you can use them to optimize your code if you are writing a .NET API targetting ARM64. This is 3 post series TODO.


### API list

[MultiplyDoublingWideningLowerByScalarAndAddSaturate](#1-multiplydoublingwideninglowerbyscalarandaddsaturate), [MultiplyDoublingWideningLowerByScalarAndSubtractSaturate](#2-multiplydoublingwideninglowerbyscalarandsubtractsaturate), [MultiplyDoublingWideningLowerBySelectedScalarAndAddSaturate](#3-multiplydoublingwideninglowerbyselectedscalarandaddsaturate), [MultiplyDoublingWideningLowerBySelectedScalarAndSubtractSaturate](#4-multiplydoublingwideninglowerbyselectedscalarandsubtractsaturate), [MultiplyDoublingWideningSaturateLower](#5-multiplydoublingwideningsaturatelower), [MultiplyDoublingWideningSaturateLowerByScalar](#6-multiplydoublingwideningsaturatelowerbyscalar), [MultiplyDoublingWideningSaturateLowerBySelectedScalar](#7-multiplydoublingwideningsaturatelowerbyselectedscalar), [MultiplyDoublingWideningSaturateUpper](#8-multiplydoublingwideningsaturateupper), [MultiplyDoublingWideningSaturateUpperByScalar](#9-multiplydoublingwideningsaturateupperbyscalar), [MultiplyDoublingWideningSaturateUpperBySelectedScalar](#10-multiplydoublingwideningsaturateupperbyselectedscalar), [MultiplyDoublingWideningUpperAndAddSaturate](#11-multiplydoublingwideningupperandaddsaturate), [MultiplyDoublingWideningUpperAndSubtractSaturate](#12-multiplydoublingwideningupperandsubtractsaturate), [MultiplyDoublingWideningUpperByScalarAndAddSaturate](#13-multiplydoublingwideningupperbyscalarandaddsaturate), [MultiplyDoublingWideningUpperByScalarAndSubtractSaturate](#14-multiplydoublingwideningupperbyscalarandsubtractsaturate), [MultiplyDoublingWideningUpperBySelectedScalarAndAddSaturate](#15-multiplydoublingwideningupperbyselectedscalarandaddsaturate), [MultiplyDoublingWideningUpperBySelectedScalarAndSubtractSaturate](#16-multiplydoublingwideningupperbyselectedscalarandsubtractsaturate), [MultiplyRoundedDoublingByScalarSaturateHigh](#17-multiplyroundeddoublingbyscalarsaturatehigh), [MultiplyRoundedDoublingBySelectedScalarSaturateHigh](#18-multiplyroundeddoublingbyselectedscalarsaturatehigh), [MultiplyRoundedDoublingSaturateHigh](#19-multiplyroundeddoublingsaturatehigh), [MultiplyScalar](#20-multiplyscalar), [MultiplyScalarBySelectedScalar](#21-multiplyscalarbyselectedscalar), [MultiplySubtract](#22-multiplysubtract), [MultiplySubtractByScalar](#23-multiplysubtractbyscalar), [MultiplySubtractBySelectedScalar](#24-multiplysubtractbyselectedscalar), [MultiplyWideningLower](#25-multiplywideninglower), [MultiplyWideningLowerAndAdd](#26-multiplywideninglowerandadd), [MultiplyWideningLowerAndSubtract](#27-multiplywideninglowerandsubtract), [MultiplyWideningUpper](#28-multiplywideningupper), [MultiplyWideningUpperAndAdd](#29-multiplywideningupperandadd), [MultiplyWideningUpperAndSubtract](#30-multiplywideningupperandsubtract), [Negate](#31-negate), [NegateSaturate](#32-negatesaturate), [NegateScalar](#33-negatescalar), [Not](#34-not), [Or](#35-or), [OrNot](#36-ornot), [PolynomialMultiply](#37-polynomialmultiply), [PolynomialMultiplyWideningLower](#38-polynomialmultiplywideninglower), [PolynomialMultiplyWideningUpper](#39-polynomialmultiplywideningupper), [PopCount](#40-popcount), [ReciprocalEstimate](#41-reciprocalestimate), [ReciprocalSquareRootEstimate](#42-reciprocalsquarerootestimate), [ReciprocalSquareRootStep](#43-reciprocalsquarerootstep), [ReciprocalStep](#44-reciprocalstep), [ReverseElement16](#45-reverseelement16), [ReverseElement32](#46-reverseelement32), [ReverseElement8](#47-reverseelement8), [RoundAwayFromZero](#48-roundawayfromzero), [RoundAwayFromZeroScalar](#49-roundawayfromzeroscalar), [RoundToNearest](#50-roundtonearest), [RoundToNearestScalar](#51-roundtonearestscalar), [RoundToNegativeInfinity](#52-roundtonegativeinfinity), [RoundToNegativeInfinityScalar](#53-roundtonegativeinfinityscalar), [RoundToPositiveInfinity](#54-roundtopositiveinfinity), [RoundToPositiveInfinityScalar](#55-roundtopositiveinfinityscalar), [RoundToZero](#56-roundtozero), [RoundToZeroScalar](#57-roundtozeroscalar), [ShiftArithmetic](#58-shiftarithmetic), [ShiftArithmeticRounded](#59-shiftarithmeticrounded), [ShiftArithmeticRoundedSaturate](#60-shiftarithmeticroundedsaturate),[...](Part3.md)






### 1. MultiplyDoublingWideningLowerByScalarAndAddSaturate

`Vector128<int> MultiplyDoublingWideningLowerByScalarAndAddSaturate(Vector128<int> addend, Vector64<short> left, Vector64<short> right)`

Performs 'MultiplyDoublingWideningLowerByScalarAndAddSaturate' operation.

```csharp
private Vector128<int> MultiplyDoublingWideningLowerByScalarAndAddSaturateTest(Vector128<int> addend, Vector64<short> left, Vector64<short> right)
{
  return AdvSimd.MultiplyDoublingWideningLowerByScalarAndAddSaturate(addend, left, right);
}
// addend = <11, 12, 13, 14>
// left = <11, 12, 13, 14>
// right = <21, 22, 23, 24>
// Result = <473, 516, 559, 602>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<long> MultiplyDoublingWideningLowerByScalarAndAddSaturate(Vector128<long> addend, Vector64<int> left, Vector64<int> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplydoublingwideninglowerbyscalarandaddsaturate?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyDoublingWideningLowerByScalarAndAddSaturateTest(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector128`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M13025_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     q0, [fp,#32]
            str     d1, [fp,#24]
            str     d2, [fp,#16]
						;; bbWeight=1    PerfScore 4.50
G_M13025_IG02:
            ldr     q16, [fp,#32]
            ldr     d17, [fp,#24]
            ldr     d7, [fp,#16]
            sqdmlal v16.4s, v17.4h, v7.h[0]
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 9.50
G_M13025_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 20.80, (MethodHash=e33ecd1e) for method AdvSimdMethods:MultiplyDoublingWideningLowerByScalarAndAddSaturateTest(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector128`1[Int32]
; ============================================================


```
------------------------------------------------

### 2. MultiplyDoublingWideningLowerByScalarAndSubtractSaturate

`Vector128<int> MultiplyDoublingWideningLowerByScalarAndSubtractSaturate(Vector128<int> minuend, Vector64<short> left, Vector64<short> right)`

Performs 'MultiplyDoublingWideningLowerByScalarAndSubtractSaturate' operation.

```csharp
private Vector128<int> MultiplyDoublingWideningLowerByScalarAndSubtractSaturateTest(Vector128<int> minuend, Vector64<short> left, Vector64<short> right)
{
  return AdvSimd.MultiplyDoublingWideningLowerByScalarAndSubtractSaturate(minuend, left, right);
}
// minuend = <11, 12, 13, 14>
// left = <11, 12, 13, 14>
// right = <21, 22, 23, 24>
// Result = <-451, -492, -533, -574>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<long> MultiplyDoublingWideningLowerByScalarAndSubtractSaturate(Vector128<long> minuend, Vector64<int> left, Vector64<int> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplydoublingwideninglowerbyscalarandsubtractsaturate?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyDoublingWideningLowerByScalarAndSubtractSaturateTest(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector128`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M62164_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     q0, [fp,#32]
            str     d1, [fp,#24]
            str     d2, [fp,#16]
						;; bbWeight=1    PerfScore 4.50
G_M62164_IG02:
            ldr     q16, [fp,#32]
            ldr     d17, [fp,#24]
            ldr     d7, [fp,#16]
            sqdmlsl v16.4s, v17.4h, v7.h[0]
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 9.50
G_M62164_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 20.80, (MethodHash=4f1e0d2b) for method AdvSimdMethods:MultiplyDoublingWideningLowerByScalarAndSubtractSaturateTest(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector128`1[Int32]
; ============================================================


```
------------------------------------------------

### 3. MultiplyDoublingWideningLowerBySelectedScalarAndAddSaturate

`Vector128<int> MultiplyDoublingWideningLowerBySelectedScalarAndAddSaturate(Vector128<int> addend, Vector64<short> left, Vector64<short> right, byte rightIndex)`

Performs 'MultiplyDoublingWideningLowerBySelectedScalarAndAddSaturate' operation.

```csharp
private Vector128<int> MultiplyDoublingWideningLowerBySelectedScalarAndAddSaturateTest(Vector128<int> addend, Vector64<short> left, Vector64<short> right, byte rightIndex)
{
  return AdvSimd.MultiplyDoublingWideningLowerBySelectedScalarAndAddSaturate(addend, left, right, rightIndex);
}
// addend = <11, 12, 13, 14>
// left = <11, 12, 13, 14>
// right = <21, 22, 23, 24>
// rightIndex = 0
// Result = <473, 516, 559, 602>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<int> MultiplyDoublingWideningLowerBySelectedScalarAndAddSaturate(Vector128<int> addend, Vector64<short> left, Vector128<short> right, byte rightIndex)
Vector128<long> MultiplyDoublingWideningLowerBySelectedScalarAndAddSaturate(Vector128<long> addend, Vector64<int> left, Vector64<int> right, byte rightIndex)
Vector128<long> MultiplyDoublingWideningLowerBySelectedScalarAndAddSaturate(Vector128<long> addend, Vector64<int> left, Vector128<int> right, byte rightIndex)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplydoublingwideninglowerbyselectedscalarandaddsaturate?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyDoublingWideningLowerBySelectedScalarAndAddSaturateTest(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V03 arg3         [V03,T00] (  3,  3   )   ubyte  ->   x0        
;# V04 OutArgs      [V04    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V05 tmp1         [V05,T01] (  2,  4   )  simd16  ->   d0         HFA(simd16)  "Inlining Arg"
;  V06 tmp2         [V06,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;  V07 tmp3         [V07,T03] (  2,  4   )   simd8  ->   d2         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 32

G_M16667_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     q0, [fp,#32]
            str     d1, [fp,#24]
            str     d2, [fp,#16]
						;; bbWeight=1    PerfScore 4.50
G_M16667_IG02:
            ldr     q0, [fp,#32]
            ldr     d1, [fp,#24]
            ldr     d2, [fp,#16]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:MultiplyDoublingWideningLowerBySelectedScalarAndAddSaturate(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
						;; bbWeight=1    PerfScore 7.50
G_M16667_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 18.80, (MethodHash=4b9abee4) for method AdvSimdMethods:MultiplyDoublingWideningLowerBySelectedScalarAndAddSaturateTest(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
; ============================================================


```
------------------------------------------------

### 4. MultiplyDoublingWideningLowerBySelectedScalarAndSubtractSaturate

`Vector128<int> MultiplyDoublingWideningLowerBySelectedScalarAndSubtractSaturate(Vector128<int> minuend, Vector64<short> left, Vector64<short> right, byte rightIndex)`

Performs 'MultiplyDoublingWideningLowerBySelectedScalarAndSubtractSaturate' operation.

```csharp
private Vector128<int> MultiplyDoublingWideningLowerBySelectedScalarAndSubtractSaturateTest(Vector128<int> minuend, Vector64<short> left, Vector64<short> right, byte rightIndex)
{
  return AdvSimd.MultiplyDoublingWideningLowerBySelectedScalarAndSubtractSaturate(minuend, left, right, rightIndex);
}
// minuend = <11, 12, 13, 14>
// left = <11, 12, 13, 14>
// right = <21, 22, 23, 24>
// rightIndex = 0
// Result = <-451, -492, -533, -574>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<int> MultiplyDoublingWideningLowerBySelectedScalarAndSubtractSaturate(Vector128<int> minuend, Vector64<short> left, Vector128<short> right, byte rightIndex)
Vector128<long> MultiplyDoublingWideningLowerBySelectedScalarAndSubtractSaturate(Vector128<long> minuend, Vector64<int> left, Vector64<int> right, byte rightIndex)
Vector128<long> MultiplyDoublingWideningLowerBySelectedScalarAndSubtractSaturate(Vector128<long> minuend, Vector64<int> left, Vector128<int> right, byte rightIndex)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplydoublingwideninglowerbyselectedscalarandsubtractsaturate?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyDoublingWideningLowerBySelectedScalarAndSubtractSaturateTest(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V03 arg3         [V03,T00] (  3,  3   )   ubyte  ->   x0        
;# V04 OutArgs      [V04    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V05 tmp1         [V05,T01] (  2,  4   )  simd16  ->   d0         HFA(simd16)  "Inlining Arg"
;  V06 tmp2         [V06,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;  V07 tmp3         [V07,T03] (  2,  4   )   simd8  ->   d2         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 32

G_M11086_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     q0, [fp,#32]
            str     d1, [fp,#24]
            str     d2, [fp,#16]
						;; bbWeight=1    PerfScore 4.50
G_M11086_IG02:
            ldr     q0, [fp,#32]
            ldr     d1, [fp,#24]
            ldr     d2, [fp,#16]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:MultiplyDoublingWideningLowerBySelectedScalarAndSubtractSaturate(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
						;; bbWeight=1    PerfScore 7.50
G_M11086_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 18.80, (MethodHash=318dd4b1) for method AdvSimdMethods:MultiplyDoublingWideningLowerBySelectedScalarAndSubtractSaturateTest(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
; ============================================================


```
------------------------------------------------

### 5. MultiplyDoublingWideningSaturateLower

`Vector128<int> MultiplyDoublingWideningSaturateLower(Vector64<short> left, Vector64<short> right)`

Performs 'MultiplyDoublingWideningSaturateLower' operation.

```csharp
private Vector128<int> MultiplyDoublingWideningSaturateLowerTest(Vector64<short> left, Vector64<short> right)
{
  return AdvSimd.MultiplyDoublingWideningSaturateLower(left, right);
}
// left = <11, 12, 13, 14>
// right = <21, 22, 23, 24>
// Result = <462, 528, 598, 672>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<long> MultiplyDoublingWideningSaturateLower(Vector64<int> left, Vector64<int> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplydoublingwideningsaturatelower?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyDoublingWideningSaturateLowerTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector128`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M29102_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M29102_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            sqdmull v16.4s, v16.4h, v17.4h
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 7.50
G_M29102_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=64988e51) for method AdvSimdMethods:MultiplyDoublingWideningSaturateLowerTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector128`1[Int32]
; ============================================================


```
------------------------------------------------

### 6. MultiplyDoublingWideningSaturateLowerByScalar

`Vector128<int> MultiplyDoublingWideningSaturateLowerByScalar(Vector64<short> left, Vector64<short> right)`

Performs 'MultiplyDoublingWideningSaturateLowerByScalar' operation.

```csharp
private Vector128<int> MultiplyDoublingWideningSaturateLowerByScalarTest(Vector64<short> left, Vector64<short> right)
{
  return AdvSimd.MultiplyDoublingWideningSaturateLowerByScalar(left, right);
}
// left = <11, 12, 13, 14>
// right = <21, 22, 23, 24>
// Result = <462, 504, 546, 588>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<long> MultiplyDoublingWideningSaturateLowerByScalar(Vector64<int> left, Vector64<int> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplydoublingwideningsaturatelowerbyscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyDoublingWideningSaturateLowerByScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector128`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M38619_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M38619_IG02:
            ldr     d16, [fp,#24]
            ldr     d7, [fp,#16]
            sqdmull v16.4s, v16.4h, v7.h[0]
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 7.50
G_M38619_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=0d316924) for method AdvSimdMethods:MultiplyDoublingWideningSaturateLowerByScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector128`1[Int32]
; ============================================================


```
------------------------------------------------

### 7. MultiplyDoublingWideningSaturateLowerBySelectedScalar

`Vector128<int> MultiplyDoublingWideningSaturateLowerBySelectedScalar(Vector64<short> left, Vector64<short> right, byte rightIndex)`

Performs 'MultiplyDoublingWideningSaturateLowerBySelectedScalar' operation.

```csharp
private Vector128<int> MultiplyDoublingWideningSaturateLowerBySelectedScalarTest(Vector64<short> left, Vector64<short> right, byte rightIndex)
{
  return AdvSimd.MultiplyDoublingWideningSaturateLowerBySelectedScalar(left, right, rightIndex);
}
// left = <11, 12, 13, 14>
// right = <21, 22, 23, 24>
// rightIndex = 0
// Result = <462, 504, 546, 588>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<int> MultiplyDoublingWideningSaturateLowerBySelectedScalar(Vector64<short> left, Vector128<short> right, byte rightIndex)
Vector128<long> MultiplyDoublingWideningSaturateLowerBySelectedScalar(Vector64<int> left, Vector64<int> right, byte rightIndex)
Vector128<long> MultiplyDoublingWideningSaturateLowerBySelectedScalar(Vector64<int> left, Vector128<int> right, byte rightIndex)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplydoublingwideningsaturatelowerbyselectedscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyDoublingWideningSaturateLowerBySelectedScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M60161_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M60161_IG02:
            ldr     d0, [fp,#24]
            ldr     d1, [fp,#16]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:MultiplyDoublingWideningSaturateLowerBySelectedScalar(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
						;; bbWeight=1    PerfScore 5.50
G_M60161_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=80f714fe) for method AdvSimdMethods:MultiplyDoublingWideningSaturateLowerBySelectedScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
; ============================================================


```
------------------------------------------------

### 8. MultiplyDoublingWideningSaturateUpper

`Vector128<int> MultiplyDoublingWideningSaturateUpper(Vector128<short> left, Vector128<short> right)`

Performs 'MultiplyDoublingWideningSaturateUpper' operation.

```csharp
private Vector128<int> MultiplyDoublingWideningSaturateUpperTest(Vector128<short> left, Vector128<short> right)
{
  return AdvSimd.MultiplyDoublingWideningSaturateUpper(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <750, 832, 918, 1008>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<long> MultiplyDoublingWideningSaturateUpper(Vector128<int> left, Vector128<int> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplydoublingwideningsaturateupper?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyDoublingWideningSaturateUpperTest(System.Runtime.Intrinsics.Vector128`1[Int16],System.Runtime.Intrinsics.Vector128`1[Int16]):System.Runtime.Intrinsics.Vector128`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M3151_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     q0, [fp,#32]
            str     q1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M3151_IG02:
            ldr     q16, [fp,#32]
            ldr     q17, [fp,#16]
            sqdmull2 v16.4s, v16.8h, v17.8h
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 7.50
G_M3151_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=bd6bf3b0) for method AdvSimdMethods:MultiplyDoublingWideningSaturateUpperTest(System.Runtime.Intrinsics.Vector128`1[Int16],System.Runtime.Intrinsics.Vector128`1[Int16]):System.Runtime.Intrinsics.Vector128`1[Int32]
; ============================================================


```
------------------------------------------------

### 9. MultiplyDoublingWideningSaturateUpperByScalar

`Vector128<int> MultiplyDoublingWideningSaturateUpperByScalar(Vector128<short> left, Vector64<short> right)`

Performs 'MultiplyDoublingWideningSaturateUpperByScalar' operation.

```csharp
private Vector128<int> MultiplyDoublingWideningSaturateUpperByScalarTest(Vector128<short> left, Vector64<short> right)
{
  return AdvSimd.MultiplyDoublingWideningSaturateUpperByScalar(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <11, 12, 13, 14>
// Result = <330, 352, 374, 396>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<long> MultiplyDoublingWideningSaturateUpperByScalar(Vector128<int> left, Vector64<int> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplydoublingwideningsaturateupperbyscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyDoublingWideningSaturateUpperByScalarTest(System.Runtime.Intrinsics.Vector128`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector128`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M16547_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     q0, [fp,#32]
            str     d1, [fp,#24]
						;; bbWeight=1    PerfScore 3.50
G_M16547_IG02:
            ldr     q16, [fp,#32]
            ldr     d7, [fp,#24]
            sqdmull2 v16.4s, v16.8h, v7.h[0]
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 7.50
G_M16547_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=36e1bf5c) for method AdvSimdMethods:MultiplyDoublingWideningSaturateUpperByScalarTest(System.Runtime.Intrinsics.Vector128`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector128`1[Int32]
; ============================================================


```
------------------------------------------------

### 10. MultiplyDoublingWideningSaturateUpperBySelectedScalar

`Vector128<int> MultiplyDoublingWideningSaturateUpperBySelectedScalar(Vector128<short> left, Vector64<short> right, byte rightIndex)`

Performs 'MultiplyDoublingWideningSaturateUpperBySelectedScalar' operation.

```csharp
private Vector128<int> MultiplyDoublingWideningSaturateUpperBySelectedScalarTest(Vector128<short> left, Vector64<short> right, byte rightIndex)
{
  return AdvSimd.MultiplyDoublingWideningSaturateUpperBySelectedScalar(left, right, rightIndex);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <11, 12, 13, 14>
// rightIndex = 0
// Result = <330, 352, 374, 396>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<int> MultiplyDoublingWideningSaturateUpperBySelectedScalar(Vector128<short> left, Vector128<short> right, byte rightIndex)
Vector128<long> MultiplyDoublingWideningSaturateUpperBySelectedScalar(Vector128<int> left, Vector64<int> right, byte rightIndex)
Vector128<long> MultiplyDoublingWideningSaturateUpperBySelectedScalar(Vector128<int> left, Vector128<int> right, byte rightIndex)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplydoublingwideningsaturateupperbyselectedscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyDoublingWideningSaturateUpperBySelectedScalarTest(System.Runtime.Intrinsics.Vector128`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T01] (  2,  4   )  simd16  ->   d0         HFA(simd16)  "Inlining Arg"
;  V05 tmp2         [V05,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 32

G_M7513_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     q0, [fp,#32]
            str     d1, [fp,#24]
						;; bbWeight=1    PerfScore 3.50
G_M7513_IG02:
            ldr     q0, [fp,#32]
            ldr     d1, [fp,#24]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:MultiplyDoublingWideningSaturateUpperBySelectedScalar(System.Runtime.Intrinsics.Vector128`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
						;; bbWeight=1    PerfScore 5.50
G_M7513_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=55e2e2a6) for method AdvSimdMethods:MultiplyDoublingWideningSaturateUpperBySelectedScalarTest(System.Runtime.Intrinsics.Vector128`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
; ============================================================


```
------------------------------------------------

### 11. MultiplyDoublingWideningUpperAndAddSaturate

`Vector128<int> MultiplyDoublingWideningUpperAndAddSaturate(Vector128<int> addend, Vector128<short> left, Vector128<short> right)`

Performs 'MultiplyDoublingWideningUpperAndAddSaturate' operation.

```csharp
private Vector128<int> MultiplyDoublingWideningUpperAndAddSaturateTest(Vector128<int> addend, Vector128<short> left, Vector128<short> right)
{
  return AdvSimd.MultiplyDoublingWideningUpperAndAddSaturate(addend, left, right);
}
// addend = <11, 12, 13, 14>
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <761, 844, 931, 1022>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<long> MultiplyDoublingWideningUpperAndAddSaturate(Vector128<long> addend, Vector128<int> left, Vector128<int> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplydoublingwideningupperandaddsaturate?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyDoublingWideningUpperAndAddSaturateTest(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector128`1[Int16],System.Runtime.Intrinsics.Vector128`1[Int16]):System.Runtime.Intrinsics.Vector128`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x30]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 48

G_M3573_IG01:
            stp     fp, lr, [sp,#-64]!
            mov     fp, sp
            str     q0, [fp,#48]
            str     q1, [fp,#32]
            str     q2, [fp,#16]
						;; bbWeight=1    PerfScore 4.50
G_M3573_IG02:
            ldr     q16, [fp,#48]
            ldr     q17, [fp,#32]
            ldr     q18, [fp,#16]
            sqdmlal2 v16.4s, v17.8h, v18.8h
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 9.50
G_M3573_IG03:
            ldp     fp, lr, [sp],#64
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 20.80, (MethodHash=55ccf20a) for method AdvSimdMethods:MultiplyDoublingWideningUpperAndAddSaturateTest(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector128`1[Int16],System.Runtime.Intrinsics.Vector128`1[Int16]):System.Runtime.Intrinsics.Vector128`1[Int32]
; ============================================================


```
------------------------------------------------

### 12. MultiplyDoublingWideningUpperAndSubtractSaturate

`Vector128<int> MultiplyDoublingWideningUpperAndSubtractSaturate(Vector128<int> minuend, Vector128<short> left, Vector128<short> right)`

Performs 'MultiplyDoublingWideningUpperAndSubtractSaturate' operation.

```csharp
private Vector128<int> MultiplyDoublingWideningUpperAndSubtractSaturateTest(Vector128<int> minuend, Vector128<short> left, Vector128<short> right)
{
  return AdvSimd.MultiplyDoublingWideningUpperAndSubtractSaturate(minuend, left, right);
}
// minuend = <11, 12, 13, 14>
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <-739, -820, -905, -994>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<long> MultiplyDoublingWideningUpperAndSubtractSaturate(Vector128<long> minuend, Vector128<int> left, Vector128<int> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplydoublingwideningupperandsubtractsaturate?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyDoublingWideningUpperAndSubtractSaturateTest(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector128`1[Int16],System.Runtime.Intrinsics.Vector128`1[Int16]):System.Runtime.Intrinsics.Vector128`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x30]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 48

G_M25600_IG01:
            stp     fp, lr, [sp,#-64]!
            mov     fp, sp
            str     q0, [fp,#48]
            str     q1, [fp,#32]
            str     q2, [fp,#16]
						;; bbWeight=1    PerfScore 4.50
G_M25600_IG02:
            ldr     q16, [fp,#48]
            ldr     q17, [fp,#32]
            ldr     q18, [fp,#16]
            sqdmlsl2 v16.4s, v17.8h, v18.8h
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 9.50
G_M25600_IG03:
            ldp     fp, lr, [sp],#64
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 20.80, (MethodHash=38419bff) for method AdvSimdMethods:MultiplyDoublingWideningUpperAndSubtractSaturateTest(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector128`1[Int16],System.Runtime.Intrinsics.Vector128`1[Int16]):System.Runtime.Intrinsics.Vector128`1[Int32]
; ============================================================


```
------------------------------------------------

### 13. MultiplyDoublingWideningUpperByScalarAndAddSaturate

`Vector128<int> MultiplyDoublingWideningUpperByScalarAndAddSaturate(Vector128<int> addend, Vector128<short> left, Vector64<short> right)`

Performs 'MultiplyDoublingWideningUpperByScalarAndAddSaturate' operation.

```csharp
private Vector128<int> MultiplyDoublingWideningUpperByScalarAndAddSaturateTest(Vector128<int> addend, Vector128<short> left, Vector64<short> right)
{
  return AdvSimd.MultiplyDoublingWideningUpperByScalarAndAddSaturate(addend, left, right);
}
// addend = <11, 12, 13, 14>
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <11, 12, 13, 14>
// Result = <341, 364, 387, 410>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<long> MultiplyDoublingWideningUpperByScalarAndAddSaturate(Vector128<long> addend, Vector128<int> left, Vector64<int> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplydoublingwideningupperbyscalarandaddsaturate?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyDoublingWideningUpperByScalarAndAddSaturateTest(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector128`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector128`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x30]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 48

G_M64057_IG01:
            stp     fp, lr, [sp,#-64]!
            mov     fp, sp
            str     q0, [fp,#48]
            str     q1, [fp,#32]
            str     d2, [fp,#24]
						;; bbWeight=1    PerfScore 4.50
G_M64057_IG02:
            ldr     q16, [fp,#48]
            ldr     q17, [fp,#32]
            ldr     d7, [fp,#24]
            sqdmlal2 v16.4s, v17.8h, v7.h[0]
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 9.50
G_M64057_IG03:
            ldp     fp, lr, [sp],#64
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 20.80, (MethodHash=83c805c6) for method AdvSimdMethods:MultiplyDoublingWideningUpperByScalarAndAddSaturateTest(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector128`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector128`1[Int32]
; ============================================================


```
------------------------------------------------

### 14. MultiplyDoublingWideningUpperByScalarAndSubtractSaturate

`Vector128<int> MultiplyDoublingWideningUpperByScalarAndSubtractSaturate(Vector128<int> minuend, Vector128<short> left, Vector64<short> right)`

Performs 'MultiplyDoublingWideningUpperByScalarAndSubtractSaturate' operation.

```csharp
private Vector128<int> MultiplyDoublingWideningUpperByScalarAndSubtractSaturateTest(Vector128<int> minuend, Vector128<short> left, Vector64<short> right)
{
  return AdvSimd.MultiplyDoublingWideningUpperByScalarAndSubtractSaturate(minuend, left, right);
}
// minuend = <11, 12, 13, 14>
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <11, 12, 13, 14>
// Result = <-319, -340, -361, -382>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<long> MultiplyDoublingWideningUpperByScalarAndSubtractSaturate(Vector128<long> minuend, Vector128<int> left, Vector64<int> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplydoublingwideningupperbyscalarandsubtractsaturate?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyDoublingWideningUpperByScalarAndSubtractSaturateTest(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector128`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector128`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x30]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 48

G_M22604_IG01:
            stp     fp, lr, [sp,#-64]!
            mov     fp, sp
            str     q0, [fp,#48]
            str     q1, [fp,#32]
            str     d2, [fp,#24]
						;; bbWeight=1    PerfScore 4.50
G_M22604_IG02:
            ldr     q16, [fp,#48]
            ldr     q17, [fp,#32]
            ldr     d7, [fp,#24]
            sqdmlsl2 v16.4s, v17.8h, v7.h[0]
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 9.50
G_M22604_IG03:
            ldp     fp, lr, [sp],#64
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 20.80, (MethodHash=6f61a7b3) for method AdvSimdMethods:MultiplyDoublingWideningUpperByScalarAndSubtractSaturateTest(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector128`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector128`1[Int32]
; ============================================================


```
------------------------------------------------

### 15. MultiplyDoublingWideningUpperBySelectedScalarAndAddSaturate

`Vector128<int> MultiplyDoublingWideningUpperBySelectedScalarAndAddSaturate(Vector128<int> addend, Vector128<short> left, Vector64<short> right, byte rightIndex)`

Performs 'MultiplyDoublingWideningUpperBySelectedScalarAndAddSaturate' operation.

```csharp
private Vector128<int> MultiplyDoublingWideningUpperBySelectedScalarAndAddSaturateTest(Vector128<int> addend, Vector128<short> left, Vector64<short> right, byte rightIndex)
{
  return AdvSimd.MultiplyDoublingWideningUpperBySelectedScalarAndAddSaturate(addend, left, right, rightIndex);
}
// addend = <11, 12, 13, 14>
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <11, 12, 13, 14>
// rightIndex = 0
// Result = <341, 364, 387, 410>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<int> MultiplyDoublingWideningUpperBySelectedScalarAndAddSaturate(Vector128<int> addend, Vector128<short> left, Vector128<short> right, byte rightIndex)
Vector128<long> MultiplyDoublingWideningUpperBySelectedScalarAndAddSaturate(Vector128<long> addend, Vector128<int> left, Vector64<int> right, byte rightIndex)
Vector128<long> MultiplyDoublingWideningUpperBySelectedScalarAndAddSaturate(Vector128<long> addend, Vector128<int> left, Vector128<int> right, byte rightIndex)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplydoublingwideningupperbyselectedscalarandaddsaturate?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyDoublingWideningUpperBySelectedScalarAndAddSaturateTest(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector128`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x30]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V03 arg3         [V03,T00] (  3,  3   )   ubyte  ->   x0        
;# V04 OutArgs      [V04    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V05 tmp1         [V05,T01] (  2,  4   )  simd16  ->   d0         HFA(simd16)  "Inlining Arg"
;  V06 tmp2         [V06,T02] (  2,  4   )  simd16  ->   d1         HFA(simd16)  "Inlining Arg"
;  V07 tmp3         [V07,T03] (  2,  4   )   simd8  ->   d2         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 48

G_M37539_IG01:
            stp     fp, lr, [sp,#-64]!
            mov     fp, sp
            str     q0, [fp,#48]
            str     q1, [fp,#32]
            str     d2, [fp,#24]
						;; bbWeight=1    PerfScore 4.50
G_M37539_IG02:
            ldr     q0, [fp,#48]
            ldr     q1, [fp,#32]
            ldr     d2, [fp,#24]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:MultiplyDoublingWideningUpperBySelectedScalarAndAddSaturate(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector128`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
						;; bbWeight=1    PerfScore 7.50
G_M37539_IG03:
            ldp     fp, lr, [sp],#64
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 18.80, (MethodHash=1c996d5c) for method AdvSimdMethods:MultiplyDoublingWideningUpperBySelectedScalarAndAddSaturateTest(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector128`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
; ============================================================


```
------------------------------------------------

### 16. MultiplyDoublingWideningUpperBySelectedScalarAndSubtractSaturate

`Vector128<int> MultiplyDoublingWideningUpperBySelectedScalarAndSubtractSaturate(Vector128<int> minuend, Vector128<short> left, Vector64<short> right, byte rightIndex)`

Performs 'MultiplyDoublingWideningUpperBySelectedScalarAndSubtractSaturate' operation.

```csharp
private Vector128<int> MultiplyDoublingWideningUpperBySelectedScalarAndSubtractSaturateTest(Vector128<int> minuend, Vector128<short> left, Vector64<short> right, byte rightIndex)
{
  return AdvSimd.MultiplyDoublingWideningUpperBySelectedScalarAndSubtractSaturate(minuend, left, right, rightIndex);
}
// minuend = <11, 12, 13, 14>
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <11, 12, 13, 14>
// rightIndex = 0
// Result = <-319, -340, -361, -382>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<int> MultiplyDoublingWideningUpperBySelectedScalarAndSubtractSaturate(Vector128<int> minuend, Vector128<short> left, Vector128<short> right, byte rightIndex)
Vector128<long> MultiplyDoublingWideningUpperBySelectedScalarAndSubtractSaturate(Vector128<long> minuend, Vector128<int> left, Vector64<int> right, byte rightIndex)
Vector128<long> MultiplyDoublingWideningUpperBySelectedScalarAndSubtractSaturate(Vector128<long> minuend, Vector128<int> left, Vector128<int> right, byte rightIndex)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplydoublingwideningupperbyselectedscalarandsubtractsaturate?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyDoublingWideningUpperBySelectedScalarAndSubtractSaturateTest(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector128`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x30]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V03 arg3         [V03,T00] (  3,  3   )   ubyte  ->   x0        
;# V04 OutArgs      [V04    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V05 tmp1         [V05,T01] (  2,  4   )  simd16  ->   d0         HFA(simd16)  "Inlining Arg"
;  V06 tmp2         [V06,T02] (  2,  4   )  simd16  ->   d1         HFA(simd16)  "Inlining Arg"
;  V07 tmp3         [V07,T03] (  2,  4   )   simd8  ->   d2         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 48

G_M17526_IG01:
            stp     fp, lr, [sp,#-64]!
            mov     fp, sp
            str     q0, [fp,#48]
            str     q1, [fp,#32]
            str     d2, [fp,#24]
						;; bbWeight=1    PerfScore 4.50
G_M17526_IG02:
            ldr     q0, [fp,#48]
            ldr     q1, [fp,#32]
            ldr     d2, [fp,#24]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:MultiplyDoublingWideningUpperBySelectedScalarAndSubtractSaturate(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector128`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
						;; bbWeight=1    PerfScore 7.50
G_M17526_IG03:
            ldp     fp, lr, [sp],#64
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 18.80, (MethodHash=c5b7bb89) for method AdvSimdMethods:MultiplyDoublingWideningUpperBySelectedScalarAndSubtractSaturateTest(System.Runtime.Intrinsics.Vector128`1[Int32],System.Runtime.Intrinsics.Vector128`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Int32]
; ============================================================


```
------------------------------------------------

### 17. MultiplyRoundedDoublingByScalarSaturateHigh

`Vector64<short> MultiplyRoundedDoublingByScalarSaturateHigh(Vector64<short> left, Vector64<short> right)`

Performs 'MultiplyRoundedDoublingByScalarSaturateHigh' operation.

```csharp
private Vector64<short> MultiplyRoundedDoublingByScalarSaturateHighTest(Vector64<short> left, Vector64<short> right)
{
  return AdvSimd.MultiplyRoundedDoublingByScalarSaturateHigh(left, right);
}
// left = <11, 12, 13, 14>
// right = <21, 22, 23, 24>
// Result = <0, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<int> MultiplyRoundedDoublingByScalarSaturateHigh(Vector64<int> left, Vector64<int> right)
Vector128<short> MultiplyRoundedDoublingByScalarSaturateHigh(Vector128<short> left, Vector64<short> right)
Vector128<int> MultiplyRoundedDoublingByScalarSaturateHigh(Vector128<int> left, Vector64<int> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplyroundeddoublingbyscalarsaturatehigh?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyRoundedDoublingByScalarSaturateHighTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M62075_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M62075_IG02:
            ldr     d16, [fp,#24]
            ldr     d7, [fp,#16]
            sqrdmulh v16.4h, v16.4h, v7.h[0]
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M62075_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=a1d60d84) for method AdvSimdMethods:MultiplyRoundedDoublingByScalarSaturateHighTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 18. MultiplyRoundedDoublingBySelectedScalarSaturateHigh

`Vector64<short> MultiplyRoundedDoublingBySelectedScalarSaturateHigh(Vector64<short> left, Vector64<short> right, byte rightIndex)`

Performs 'MultiplyRoundedDoublingBySelectedScalarSaturateHigh' operation.

```csharp
private Vector64<short> MultiplyRoundedDoublingBySelectedScalarSaturateHighTest(Vector64<short> left, Vector64<short> right, byte rightIndex)
{
  return AdvSimd.MultiplyRoundedDoublingBySelectedScalarSaturateHigh(left, right, rightIndex);
}
// left = <11, 12, 13, 14>
// right = <21, 22, 23, 24>
// rightIndex = 0
// Result = <0, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> MultiplyRoundedDoublingBySelectedScalarSaturateHigh(Vector64<short> left, Vector128<short> right, byte rightIndex)
Vector64<int> MultiplyRoundedDoublingBySelectedScalarSaturateHigh(Vector64<int> left, Vector64<int> right, byte rightIndex)
Vector64<int> MultiplyRoundedDoublingBySelectedScalarSaturateHigh(Vector64<int> left, Vector128<int> right, byte rightIndex)
Vector128<short> MultiplyRoundedDoublingBySelectedScalarSaturateHigh(Vector128<short> left, Vector64<short> right, byte rightIndex)
Vector128<short> MultiplyRoundedDoublingBySelectedScalarSaturateHigh(Vector128<short> left, Vector128<short> right, byte rightIndex)
Vector128<int> MultiplyRoundedDoublingBySelectedScalarSaturateHigh(Vector128<int> left, Vector64<int> right, byte rightIndex)
Vector128<int> MultiplyRoundedDoublingBySelectedScalarSaturateHigh(Vector128<int> left, Vector128<int> right, byte rightIndex)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplyroundeddoublingbyselectedscalarsaturatehigh?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyRoundedDoublingBySelectedScalarSaturateHighTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M46177_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M46177_IG02:
            ldr     d0, [fp,#24]
            ldr     d1, [fp,#16]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:MultiplyRoundedDoublingBySelectedScalarSaturateHigh(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
						;; bbWeight=1    PerfScore 5.50
G_M46177_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=b31f4b9e) for method AdvSimdMethods:MultiplyRoundedDoublingBySelectedScalarSaturateHighTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 19. MultiplyRoundedDoublingSaturateHigh

`Vector64<short> MultiplyRoundedDoublingSaturateHigh(Vector64<short> left, Vector64<short> right)`

Performs 'MultiplyRoundedDoublingSaturateHigh' operation.

```csharp
private Vector64<short> MultiplyRoundedDoublingSaturateHighTest(Vector64<short> left, Vector64<short> right)
{
  return AdvSimd.MultiplyRoundedDoublingSaturateHigh(left, right);
}
// left = <11, 12, 13, 14>
// right = <21, 22, 23, 24>
// Result = <0, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<int> MultiplyRoundedDoublingSaturateHigh(Vector64<int> left, Vector64<int> right)
Vector128<short> MultiplyRoundedDoublingSaturateHigh(Vector128<short> left, Vector128<short> right)
Vector128<int> MultiplyRoundedDoublingSaturateHigh(Vector128<int> left, Vector128<int> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplyroundeddoublingsaturatehigh?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyRoundedDoublingSaturateHighTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M26478_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M26478_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            sqrdmulh v16.4h, v16.4h, v17.4h
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M26478_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=ea039891) for method AdvSimdMethods:MultiplyRoundedDoublingSaturateHighTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 20. MultiplyScalar

`Vector64<double> MultiplyScalar(Vector64<double> left, Vector64<double> right)`

Performs 'MultiplyScalar' operation.

```csharp
private Vector64<double> MultiplyScalarTest(Vector64<double> left, Vector64<double> right)
{
  return AdvSimd.MultiplyScalar(left, right);
}
// left = <11.5>
// right = <11.5>
// Result = <132.25>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<float> MultiplyScalar(Vector64<float> left, Vector64<float> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplyscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M31949_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M31949_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            fmul    d16, d16, d17
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M31949_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=7aff8332) for method AdvSimdMethods:MultiplyScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 21. MultiplyScalarBySelectedScalar

`Vector64<float> MultiplyScalarBySelectedScalar(Vector64<float> left, Vector64<float> right, byte rightIndex)`

Performs 'MultiplyScalarBySelectedScalar' operation.

```csharp
private Vector64<float> MultiplyScalarBySelectedScalarTest(Vector64<float> left, Vector64<float> right, byte rightIndex)
{
  return AdvSimd.MultiplyScalarBySelectedScalar(left, right, rightIndex);
}
// left = <11.5, 12.5>
// right = <21.5, 22.5>
// rightIndex = 0
// Result = <247.25, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<float> MultiplyScalarBySelectedScalar(Vector64<float> left, Vector128<float> right, byte rightIndex)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<double> MultiplyScalarBySelectedScalar(Vector64<double> left, Vector128<double> right, byte rightIndex)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplyscalarbyselectedscalar?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.multiplyscalarbyselectedscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyScalarBySelectedScalarTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single],ubyte):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M33517_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M33517_IG02:
            ldr     d0, [fp,#24]
            ldr     d1, [fp,#16]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:MultiplyScalarBySelectedScalar(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single],ubyte):System.Runtime.Intrinsics.Vector64`1[Single]
						;; bbWeight=1    PerfScore 5.50
G_M33517_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=3cb37d12) for method AdvSimdMethods:MultiplyScalarBySelectedScalarTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single],ubyte):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 22. MultiplySubtract

`Vector64<byte> MultiplySubtract(Vector64<byte> minuend, Vector64<byte> left, Vector64<byte> right)`

Performs 'MultiplySubtract' operation.

```csharp
private Vector64<byte> MultiplySubtractTest(Vector64<byte> minuend, Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.MultiplySubtract(minuend, left, right);
}
// minuend = <11, 12, 13, 14, 15, 16, 17, 18>
// left = <21, 22, 23, 24, 25, 26, 27, 28>
// right = <31, 32, 33, 34, 35, 36, 37, 38>
// Result = <128, 76, 22, 222, 164, 104, 42, 234>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> MultiplySubtract(Vector64<short> minuend, Vector64<short> left, Vector64<short> right)
Vector64<int> MultiplySubtract(Vector64<int> minuend, Vector64<int> left, Vector64<int> right)
Vector64<sbyte> MultiplySubtract(Vector64<sbyte> minuend, Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<ushort> MultiplySubtract(Vector64<ushort> minuend, Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> MultiplySubtract(Vector64<uint> minuend, Vector64<uint> left, Vector64<uint> right)
Vector128<byte> MultiplySubtract(Vector128<byte> minuend, Vector128<byte> left, Vector128<byte> right)
Vector128<short> MultiplySubtract(Vector128<short> minuend, Vector128<short> left, Vector128<short> right)
Vector128<int> MultiplySubtract(Vector128<int> minuend, Vector128<int> left, Vector128<int> right)
Vector128<sbyte> MultiplySubtract(Vector128<sbyte> minuend, Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<ushort> MultiplySubtract(Vector128<ushort> minuend, Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> MultiplySubtract(Vector128<uint> minuend, Vector128<uint> left, Vector128<uint> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplysubtract?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplySubtractTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x20]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M31737_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     d1, [fp,#32]
            str     d2, [fp,#24]
						;; bbWeight=1    PerfScore 4.50
G_M31737_IG02:
            ldr     d16, [fp,#40]
            ldr     d17, [fp,#32]
            ldr     d18, [fp,#24]
            mls     v16.8b, v17.8b, v18.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 9.50
G_M31737_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 20.80, (MethodHash=b1378406) for method AdvSimdMethods:MultiplySubtractTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 23. MultiplySubtractByScalar

`Vector64<short> MultiplySubtractByScalar(Vector64<short> minuend, Vector64<short> left, Vector64<short> right)`

Performs 'MultiplySubtractByScalar' operation.

```csharp
private Vector64<short> MultiplySubtractByScalarTest(Vector64<short> minuend, Vector64<short> left, Vector64<short> right)
{
  return AdvSimd.MultiplySubtractByScalar(minuend, left, right);
}
// minuend = <11, 12, 13, 14>
// left = <21, 22, 23, 24>
// right = <31, 32, 33, 34>
// Result = <-640, -670, -700, -730>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<int> MultiplySubtractByScalar(Vector64<int> minuend, Vector64<int> left, Vector64<int> right)
Vector64<ushort> MultiplySubtractByScalar(Vector64<ushort> minuend, Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> MultiplySubtractByScalar(Vector64<uint> minuend, Vector64<uint> left, Vector64<uint> right)
Vector128<short> MultiplySubtractByScalar(Vector128<short> minuend, Vector128<short> left, Vector64<short> right)
Vector128<int> MultiplySubtractByScalar(Vector128<int> minuend, Vector128<int> left, Vector64<int> right)
Vector128<ushort> MultiplySubtractByScalar(Vector128<ushort> minuend, Vector128<ushort> left, Vector64<ushort> right)
Vector128<uint> MultiplySubtractByScalar(Vector128<uint> minuend, Vector128<uint> left, Vector64<uint> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplysubtractbyscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplySubtractByScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x20]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M9996_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     d1, [fp,#32]
            str     d2, [fp,#24]
						;; bbWeight=1    PerfScore 4.50
G_M9996_IG02:
            ldr     d16, [fp,#40]
            ldr     d17, [fp,#32]
            ldr     d7, [fp,#24]
            mls     v16.4h, v17.4h, v7.h[0]
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 9.50
G_M9996_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 20.80, (MethodHash=2998d8f3) for method AdvSimdMethods:MultiplySubtractByScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 24. MultiplySubtractBySelectedScalar

`Vector64<short> MultiplySubtractBySelectedScalar(Vector64<short> minuend, Vector64<short> left, Vector64<short> right, byte rightIndex)`

Performs 'MultiplySubtractBySelectedScalar' operation.

```csharp
private Vector64<short> MultiplySubtractBySelectedScalarTest(Vector64<short> minuend, Vector64<short> left, Vector64<short> right, byte rightIndex)
{
  return AdvSimd.MultiplySubtractBySelectedScalar(minuend, left, right, rightIndex);
}
// minuend = <11, 12, 13, 14>
// left = <21, 22, 23, 24>
// right = <31, 32, 33, 34>
// rightIndex = 0
// Result = <-640, -670, -700, -730>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> MultiplySubtractBySelectedScalar(Vector64<short> minuend, Vector64<short> left, Vector128<short> right, byte rightIndex)
Vector64<int> MultiplySubtractBySelectedScalar(Vector64<int> minuend, Vector64<int> left, Vector64<int> right, byte rightIndex)
Vector64<int> MultiplySubtractBySelectedScalar(Vector64<int> minuend, Vector64<int> left, Vector128<int> right, byte rightIndex)
Vector64<ushort> MultiplySubtractBySelectedScalar(Vector64<ushort> minuend, Vector64<ushort> left, Vector64<ushort> right, byte rightIndex)
Vector64<ushort> MultiplySubtractBySelectedScalar(Vector64<ushort> minuend, Vector64<ushort> left, Vector128<ushort> right, byte rightIndex)
Vector64<uint> MultiplySubtractBySelectedScalar(Vector64<uint> minuend, Vector64<uint> left, Vector64<uint> right, byte rightIndex)
Vector64<uint> MultiplySubtractBySelectedScalar(Vector64<uint> minuend, Vector64<uint> left, Vector128<uint> right, byte rightIndex)
Vector128<short> MultiplySubtractBySelectedScalar(Vector128<short> minuend, Vector128<short> left, Vector64<short> right, byte rightIndex)
Vector128<short> MultiplySubtractBySelectedScalar(Vector128<short> minuend, Vector128<short> left, Vector128<short> right, byte rightIndex)
Vector128<int> MultiplySubtractBySelectedScalar(Vector128<int> minuend, Vector128<int> left, Vector64<int> right, byte rightIndex)
Vector128<int> MultiplySubtractBySelectedScalar(Vector128<int> minuend, Vector128<int> left, Vector128<int> right, byte rightIndex)
Vector128<ushort> MultiplySubtractBySelectedScalar(Vector128<ushort> minuend, Vector128<ushort> left, Vector64<ushort> right, byte rightIndex)
Vector128<ushort> MultiplySubtractBySelectedScalar(Vector128<ushort> minuend, Vector128<ushort> left, Vector128<ushort> right, byte rightIndex)
Vector128<uint> MultiplySubtractBySelectedScalar(Vector128<uint> minuend, Vector128<uint> left, Vector64<uint> right, byte rightIndex)
Vector128<uint> MultiplySubtractBySelectedScalar(Vector128<uint> minuend, Vector128<uint> left, Vector128<uint> right, byte rightIndex)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplysubtractbyselectedscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplySubtractBySelectedScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x20]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V03 arg3         [V03,T00] (  3,  3   )   ubyte  ->   x0        
;# V04 OutArgs      [V04    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V05 tmp1         [V05,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V06 tmp2         [V06,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;  V07 tmp3         [V07,T03] (  2,  4   )   simd8  ->   d2         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 32

G_M24342_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     d1, [fp,#32]
            str     d2, [fp,#24]
						;; bbWeight=1    PerfScore 4.50
G_M24342_IG02:
            ldr     d0, [fp,#40]
            ldr     d1, [fp,#32]
            ldr     d2, [fp,#24]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:MultiplySubtractBySelectedScalar(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
						;; bbWeight=1    PerfScore 7.50
G_M24342_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 18.80, (MethodHash=5ed5a0e9) for method AdvSimdMethods:MultiplySubtractBySelectedScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 25. MultiplyWideningLower

`Vector128<ushort> MultiplyWideningLower(Vector64<byte> left, Vector64<byte> right)`

Performs 'MultiplyWideningLower' operation.

```csharp
private Vector128<ushort> MultiplyWideningLowerTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.MultiplyWideningLower(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <231, 264, 299, 336, 375, 416, 459, 504>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<int> MultiplyWideningLower(Vector64<short> left, Vector64<short> right)
Vector128<long> MultiplyWideningLower(Vector64<int> left, Vector64<int> right)
Vector128<short> MultiplyWideningLower(Vector64<sbyte> left, Vector64<sbyte> right)
Vector128<uint> MultiplyWideningLower(Vector64<ushort> left, Vector64<ushort> right)
Vector128<ulong> MultiplyWideningLower(Vector64<uint> left, Vector64<uint> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplywideninglower?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyWideningLowerTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector128`1[UInt16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M6812_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M6812_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            umull   v16.8h, v16.8b, v17.8b
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 7.50
G_M6812_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=fe1ae563) for method AdvSimdMethods:MultiplyWideningLowerTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector128`1[UInt16]
; ============================================================


```
------------------------------------------------

### 26. MultiplyWideningLowerAndAdd

`Vector128<ushort> MultiplyWideningLowerAndAdd(Vector128<ushort> addend, Vector64<byte> left, Vector64<byte> right)`

Performs 'MultiplyWideningLowerAndAdd' operation.

```csharp
private Vector128<ushort> MultiplyWideningLowerAndAddTest(Vector128<ushort> addend, Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.MultiplyWideningLowerAndAdd(addend, left, right);
}
// addend = <11, 12, 13, 14, 15, 16, 17, 18>
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <242, 276, 312, 350, 390, 432, 476, 522>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<int> MultiplyWideningLowerAndAdd(Vector128<int> addend, Vector64<short> left, Vector64<short> right)
Vector128<long> MultiplyWideningLowerAndAdd(Vector128<long> addend, Vector64<int> left, Vector64<int> right)
Vector128<short> MultiplyWideningLowerAndAdd(Vector128<short> addend, Vector64<sbyte> left, Vector64<sbyte> right)
Vector128<uint> MultiplyWideningLowerAndAdd(Vector128<uint> addend, Vector64<ushort> left, Vector64<ushort> right)
Vector128<ulong> MultiplyWideningLowerAndAdd(Vector128<ulong> addend, Vector64<uint> left, Vector64<uint> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplywideninglowerandadd?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyWideningLowerAndAddTest(System.Runtime.Intrinsics.Vector128`1[UInt16],System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector128`1[UInt16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M55669_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     q0, [fp,#32]
            str     d1, [fp,#24]
            str     d2, [fp,#16]
						;; bbWeight=1    PerfScore 4.50
G_M55669_IG02:
            ldr     q16, [fp,#32]
            ldr     d17, [fp,#24]
            ldr     d18, [fp,#16]
            umlal   v16.8h, v17.8b, v18.8b
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 9.50
G_M55669_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 20.80, (MethodHash=5c25268a) for method AdvSimdMethods:MultiplyWideningLowerAndAddTest(System.Runtime.Intrinsics.Vector128`1[UInt16],System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector128`1[UInt16]
; ============================================================


```
------------------------------------------------

### 27. MultiplyWideningLowerAndSubtract

`Vector128<ushort> MultiplyWideningLowerAndSubtract(Vector128<ushort> minuend, Vector64<byte> left, Vector64<byte> right)`

Performs 'MultiplyWideningLowerAndSubtract' operation.

```csharp
private Vector128<ushort> MultiplyWideningLowerAndSubtractTest(Vector128<ushort> minuend, Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.MultiplyWideningLowerAndSubtract(minuend, left, right);
}
// minuend = <11, 12, 13, 14, 15, 16, 17, 18>
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <65316, 65284, 65250, 65214, 65176, 65136, 65094, 65050>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<int> MultiplyWideningLowerAndSubtract(Vector128<int> minuend, Vector64<short> left, Vector64<short> right)
Vector128<long> MultiplyWideningLowerAndSubtract(Vector128<long> minuend, Vector64<int> left, Vector64<int> right)
Vector128<short> MultiplyWideningLowerAndSubtract(Vector128<short> minuend, Vector64<sbyte> left, Vector64<sbyte> right)
Vector128<uint> MultiplyWideningLowerAndSubtract(Vector128<uint> minuend, Vector64<ushort> left, Vector64<ushort> right)
Vector128<ulong> MultiplyWideningLowerAndSubtract(Vector128<ulong> minuend, Vector64<uint> left, Vector64<uint> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplywideninglowerandsubtract?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyWideningLowerAndSubtractTest(System.Runtime.Intrinsics.Vector128`1[UInt16],System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector128`1[UInt16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M49760_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     q0, [fp,#32]
            str     d1, [fp,#24]
            str     d2, [fp,#16]
						;; bbWeight=1    PerfScore 4.50
G_M49760_IG02:
            ldr     q16, [fp,#32]
            ldr     d17, [fp,#24]
            ldr     d18, [fp,#16]
            umlsl   v16.8h, v17.8b, v18.8b
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 9.50
G_M49760_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 20.80, (MethodHash=b2ae3d9f) for method AdvSimdMethods:MultiplyWideningLowerAndSubtractTest(System.Runtime.Intrinsics.Vector128`1[UInt16],System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector128`1[UInt16]
; ============================================================


```
------------------------------------------------

### 28. MultiplyWideningUpper

`Vector128<ushort> MultiplyWideningUpper(Vector128<byte> left, Vector128<byte> right)`

Performs 'MultiplyWideningUpper' operation.

```csharp
private Vector128<ushort> MultiplyWideningUpperTest(Vector128<byte> left, Vector128<byte> right)
{
  return AdvSimd.MultiplyWideningUpper(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26>
// right = <21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36>
// Result = <551, 600, 651, 704, 759, 816, 875, 936>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<int> MultiplyWideningUpper(Vector128<short> left, Vector128<short> right)
Vector128<long> MultiplyWideningUpper(Vector128<int> left, Vector128<int> right)
Vector128<short> MultiplyWideningUpper(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<uint> MultiplyWideningUpper(Vector128<ushort> left, Vector128<ushort> right)
Vector128<ulong> MultiplyWideningUpper(Vector128<uint> left, Vector128<uint> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplywideningupper?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyWideningUpperTest(System.Runtime.Intrinsics.Vector128`1[Byte],System.Runtime.Intrinsics.Vector128`1[Byte]):System.Runtime.Intrinsics.Vector128`1[UInt16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M3645_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     q0, [fp,#32]
            str     q1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M3645_IG02:
            ldr     q16, [fp,#32]
            ldr     q17, [fp,#16]
            umull2  v16.8h, v16.16b, v17.16b
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 7.50
G_M3645_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=11fdf1c2) for method AdvSimdMethods:MultiplyWideningUpperTest(System.Runtime.Intrinsics.Vector128`1[Byte],System.Runtime.Intrinsics.Vector128`1[Byte]):System.Runtime.Intrinsics.Vector128`1[UInt16]
; ============================================================


```
------------------------------------------------

### 29. MultiplyWideningUpperAndAdd

`Vector128<ushort> MultiplyWideningUpperAndAdd(Vector128<ushort> addend, Vector128<byte> left, Vector128<byte> right)`

Performs 'MultiplyWideningUpperAndAdd' operation.

```csharp
private Vector128<ushort> MultiplyWideningUpperAndAddTest(Vector128<ushort> addend, Vector128<byte> left, Vector128<byte> right)
{
  return AdvSimd.MultiplyWideningUpperAndAdd(addend, left, right);
}
// addend = <11, 12, 13, 14, 15, 16, 17, 18>
// left = <11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26>
// right = <21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36>
// Result = <562, 612, 664, 718, 774, 832, 892, 954>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<int> MultiplyWideningUpperAndAdd(Vector128<int> addend, Vector128<short> left, Vector128<short> right)
Vector128<long> MultiplyWideningUpperAndAdd(Vector128<long> addend, Vector128<int> left, Vector128<int> right)
Vector128<short> MultiplyWideningUpperAndAdd(Vector128<short> addend, Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<uint> MultiplyWideningUpperAndAdd(Vector128<uint> addend, Vector128<ushort> left, Vector128<ushort> right)
Vector128<ulong> MultiplyWideningUpperAndAdd(Vector128<ulong> addend, Vector128<uint> left, Vector128<uint> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplywideningupperandadd?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyWideningUpperAndAddTest(System.Runtime.Intrinsics.Vector128`1[UInt16],System.Runtime.Intrinsics.Vector128`1[Byte],System.Runtime.Intrinsics.Vector128`1[Byte]):System.Runtime.Intrinsics.Vector128`1[UInt16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x30]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 48

G_M62740_IG01:
            stp     fp, lr, [sp,#-64]!
            mov     fp, sp
            str     q0, [fp,#48]
            str     q1, [fp,#32]
            str     q2, [fp,#16]
						;; bbWeight=1    PerfScore 4.50
G_M62740_IG02:
            ldr     q16, [fp,#48]
            ldr     q17, [fp,#32]
            ldr     q18, [fp,#16]
            umlal2  v16.8h, v17.16b, v18.16b
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 9.50
G_M62740_IG03:
            ldp     fp, lr, [sp],#64
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 20.80, (MethodHash=26f70aeb) for method AdvSimdMethods:MultiplyWideningUpperAndAddTest(System.Runtime.Intrinsics.Vector128`1[UInt16],System.Runtime.Intrinsics.Vector128`1[Byte],System.Runtime.Intrinsics.Vector128`1[Byte]):System.Runtime.Intrinsics.Vector128`1[UInt16]
; ============================================================


```
------------------------------------------------

### 30. MultiplyWideningUpperAndSubtract

`Vector128<ushort> MultiplyWideningUpperAndSubtract(Vector128<ushort> minuend, Vector128<byte> left, Vector128<byte> right)`

Performs 'MultiplyWideningUpperAndSubtract' operation.

```csharp
private Vector128<ushort> MultiplyWideningUpperAndSubtractTest(Vector128<ushort> minuend, Vector128<byte> left, Vector128<byte> right)
{
  return AdvSimd.MultiplyWideningUpperAndSubtract(minuend, left, right);
}
// minuend = <11, 12, 13, 14, 15, 16, 17, 18>
// left = <11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26>
// right = <21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36>
// Result = <64996, 64948, 64898, 64846, 64792, 64736, 64678, 64618>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<int> MultiplyWideningUpperAndSubtract(Vector128<int> minuend, Vector128<short> left, Vector128<short> right)
Vector128<long> MultiplyWideningUpperAndSubtract(Vector128<long> minuend, Vector128<int> left, Vector128<int> right)
Vector128<short> MultiplyWideningUpperAndSubtract(Vector128<short> minuend, Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<uint> MultiplyWideningUpperAndSubtract(Vector128<uint> minuend, Vector128<ushort> left, Vector128<ushort> right)
Vector128<ulong> MultiplyWideningUpperAndSubtract(Vector128<ulong> minuend, Vector128<uint> left, Vector128<uint> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.multiplywideningupperandsubtract?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyWideningUpperAndSubtractTest(System.Runtime.Intrinsics.Vector128`1[UInt16],System.Runtime.Intrinsics.Vector128`1[Byte],System.Runtime.Intrinsics.Vector128`1[Byte]):System.Runtime.Intrinsics.Vector128`1[UInt16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x30]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 48

G_M25121_IG01:
            stp     fp, lr, [sp,#-64]!
            mov     fp, sp
            str     q0, [fp,#48]
            str     q1, [fp,#32]
            str     q2, [fp,#16]
						;; bbWeight=1    PerfScore 4.50
G_M25121_IG02:
            ldr     q16, [fp,#48]
            ldr     q17, [fp,#32]
            ldr     q18, [fp,#16]
            umlsl2  v16.8h, v17.16b, v18.16b
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 9.50
G_M25121_IG03:
            ldp     fp, lr, [sp],#64
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 20.80, (MethodHash=cd559dde) for method AdvSimdMethods:MultiplyWideningUpperAndSubtractTest(System.Runtime.Intrinsics.Vector128`1[UInt16],System.Runtime.Intrinsics.Vector128`1[Byte],System.Runtime.Intrinsics.Vector128`1[Byte]):System.Runtime.Intrinsics.Vector128`1[UInt16]
; ============================================================


```
------------------------------------------------

### 31. Negate

`Vector64<short> Negate(Vector64<short> value)`

Performs 'Negate' operation.

```csharp
private Vector64<short> NegateTest(Vector64<short> value)
{
  return AdvSimd.Negate(value);
}
// value = <11, 12, 13, 14>
// Result = <-11, -12, -13, -14>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<int> Negate(Vector64<int> value)
Vector64<sbyte> Negate(Vector64<sbyte> value)
Vector64<float> Negate(Vector64<float> value)
Vector128<short> Negate(Vector128<short> value)
Vector128<int> Negate(Vector128<int> value)
Vector128<sbyte> Negate(Vector128<sbyte> value)
Vector128<float> Negate(Vector128<float> value)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> Negate(Vector128<double> value)
Vector128<long> Negate(Vector128<long> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.negate?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.negate?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:NegateTest(System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M12893_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M12893_IG02:
            ldr     d16, [fp,#24]
            neg     v16.4h, v16.4h
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 3.00
G_M12893_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 10.70, (MethodHash=fe48cda2) for method AdvSimdMethods:NegateTest(System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 32. NegateSaturate

`Vector64<short> NegateSaturate(Vector64<short> value)`

Performs 'NegateSaturate' operation.

```csharp
private Vector64<short> NegateSaturateTest(Vector64<short> value)
{
  return AdvSimd.NegateSaturate(value);
}
// value = <11, 12, 13, 14>
// Result = <-11, -12, -13, -14>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<int> NegateSaturate(Vector64<int> value)
Vector64<sbyte> NegateSaturate(Vector64<sbyte> value)
Vector128<short> NegateSaturate(Vector128<short> value)
Vector128<int> NegateSaturate(Vector128<int> value)
Vector128<sbyte> NegateSaturate(Vector128<sbyte> value)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<long> NegateSaturate(Vector128<long> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.negatesaturate?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.negatesaturate?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:NegateSaturateTest(System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M44332_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M44332_IG02:
            ldr     d16, [fp,#24]
            sqneg   v16.4h, v16.4h
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 4.50
G_M44332_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 12.20, (MethodHash=3ddc52d3) for method AdvSimdMethods:NegateSaturateTest(System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 33. NegateScalar

`Vector64<double> NegateScalar(Vector64<double> value)`

Performs 'NegateScalar' operation.

```csharp
private Vector64<double> NegateScalarTest(Vector64<double> value)
{
  return AdvSimd.NegateScalar(value);
}
// value = <11.5>
// Result = <-11.5>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<float> NegateScalar(Vector64<float> value)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<long> NegateScalar(Vector64<long> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.negatescalar?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.negatescalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:NegateScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M2707_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M2707_IG02:
            ldr     d16, [fp,#24]
            fneg    d16, d16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 4.50
G_M2707_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 12.20, (MethodHash=848bf56c) for method AdvSimdMethods:NegateScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 34. Not

`Vector64<byte> Not(Vector64<byte> value)`

Performs 'Not' operation.

```csharp
private Vector64<byte> NotTest(Vector64<byte> value)
{
  return AdvSimd.Not(value);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// Result = <244, 243, 242, 241, 240, 239, 238, 237>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<double> Not(Vector64<double> value)
Vector64<short> Not(Vector64<short> value)
Vector64<int> Not(Vector64<int> value)
Vector64<long> Not(Vector64<long> value)
Vector64<sbyte> Not(Vector64<sbyte> value)
Vector64<float> Not(Vector64<float> value)
Vector64<ushort> Not(Vector64<ushort> value)
Vector64<uint> Not(Vector64<uint> value)
Vector64<ulong> Not(Vector64<ulong> value)
Vector128<byte> Not(Vector128<byte> value)
Vector128<double> Not(Vector128<double> value)
Vector128<short> Not(Vector128<short> value)
Vector128<int> Not(Vector128<int> value)
Vector128<long> Not(Vector128<long> value)
Vector128<sbyte> Not(Vector128<sbyte> value)
Vector128<float> Not(Vector128<float> value)
Vector128<ushort> Not(Vector128<ushort> value)
Vector128<uint> Not(Vector128<uint> value)
Vector128<ulong> Not(Vector128<ulong> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.not?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:NotTest(System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M23796_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M23796_IG02:
            ldr     d16, [fp,#24]
            mvn     v16.8b, v16.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 3.00
G_M23796_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 10.70, (MethodHash=1f96a30b) for method AdvSimdMethods:NotTest(System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 35. Or

`Vector64<byte> Or(Vector64<byte> left, Vector64<byte> right)`

Performs 'Or' operation.

```csharp
private Vector64<byte> OrTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.Or(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <31, 30, 31, 30, 31, 26, 27, 30>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<double> Or(Vector64<double> left, Vector64<double> right)
Vector64<short> Or(Vector64<short> left, Vector64<short> right)
Vector64<int> Or(Vector64<int> left, Vector64<int> right)
Vector64<long> Or(Vector64<long> left, Vector64<long> right)
Vector64<sbyte> Or(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<float> Or(Vector64<float> left, Vector64<float> right)
Vector64<ushort> Or(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> Or(Vector64<uint> left, Vector64<uint> right)
Vector64<ulong> Or(Vector64<ulong> left, Vector64<ulong> right)
Vector128<byte> Or(Vector128<byte> left, Vector128<byte> right)
Vector128<double> Or(Vector128<double> left, Vector128<double> right)
Vector128<short> Or(Vector128<short> left, Vector128<short> right)
Vector128<int> Or(Vector128<int> left, Vector128<int> right)
Vector128<long> Or(Vector128<long> left, Vector128<long> right)
Vector128<sbyte> Or(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<float> Or(Vector128<float> left, Vector128<float> right)
Vector128<ushort> Or(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> Or(Vector128<uint> left, Vector128<uint> right)
Vector128<ulong> Or(Vector128<ulong> left, Vector128<ulong> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.or?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:OrTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M10701_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M10701_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            orr     v16.8b, v16.8b, v17.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.00
G_M10701_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 14.50, (MethodHash=d6f8d632) for method AdvSimdMethods:OrTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 36. OrNot

`Vector64<byte> OrNot(Vector64<byte> left, Vector64<byte> right)`

Performs 'OrNot' operation.

```csharp
private Vector64<byte> OrNotTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.OrNot(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <235, 237, 237, 239, 239, 245, 245, 243>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<double> OrNot(Vector64<double> left, Vector64<double> right)
Vector64<short> OrNot(Vector64<short> left, Vector64<short> right)
Vector64<int> OrNot(Vector64<int> left, Vector64<int> right)
Vector64<long> OrNot(Vector64<long> left, Vector64<long> right)
Vector64<sbyte> OrNot(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<float> OrNot(Vector64<float> left, Vector64<float> right)
Vector64<ushort> OrNot(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> OrNot(Vector64<uint> left, Vector64<uint> right)
Vector64<ulong> OrNot(Vector64<ulong> left, Vector64<ulong> right)
Vector128<byte> OrNot(Vector128<byte> left, Vector128<byte> right)
Vector128<double> OrNot(Vector128<double> left, Vector128<double> right)
Vector128<short> OrNot(Vector128<short> left, Vector128<short> right)
Vector128<int> OrNot(Vector128<int> left, Vector128<int> right)
Vector128<long> OrNot(Vector128<long> left, Vector128<long> right)
Vector128<sbyte> OrNot(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<float> OrNot(Vector128<float> left, Vector128<float> right)
Vector128<ushort> OrNot(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> OrNot(Vector128<uint> left, Vector128<uint> right)
Vector128<ulong> OrNot(Vector128<ulong> left, Vector128<ulong> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.ornot?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:OrNotTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M64056_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M64056_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            orn     v16.8b, v16.8b, v17.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.00
G_M64056_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 14.50, (MethodHash=583505c7) for method AdvSimdMethods:OrNotTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 37. PolynomialMultiply

`Vector64<byte> PolynomialMultiply(Vector64<byte> left, Vector64<byte> right)`

Performs 'PolynomialMultiply' operation.

```csharp
private Vector64<byte> PolynomialMultiplyTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.PolynomialMultiply(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <151, 232, 243, 144, 135, 160, 171, 248>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<sbyte> PolynomialMultiply(Vector64<sbyte> left, Vector64<sbyte> right)
Vector128<byte> PolynomialMultiply(Vector128<byte> left, Vector128<byte> right)
Vector128<sbyte> PolynomialMultiply(Vector128<sbyte> left, Vector128<sbyte> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.polynomialmultiply?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:PolynomialMultiplyTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M57310_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M57310_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            pmul    v16.8b, v16.8b, v17.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 6.50
G_M57310_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 16.00, (MethodHash=b4a62021) for method AdvSimdMethods:PolynomialMultiplyTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 38. PolynomialMultiplyWideningLower

`Vector128<ushort> PolynomialMultiplyWideningLower(Vector64<byte> left, Vector64<byte> right)`

Performs 'PolynomialMultiplyWideningLower' operation.

```csharp
private Vector128<ushort> PolynomialMultiplyWideningLowerTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.PolynomialMultiplyWideningLower(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <151, 232, 243, 144, 135, 416, 427, 504>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<short> PolynomialMultiplyWideningLower(Vector64<sbyte> left, Vector64<sbyte> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.polynomialmultiplywideninglower?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:PolynomialMultiplyWideningLowerTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector128`1[UInt16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M25534_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M25534_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            pmull   v16.8h, v16.8b, v17.8b
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 6.50
G_M25534_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 16.00, (MethodHash=421b9c41) for method AdvSimdMethods:PolynomialMultiplyWideningLowerTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector128`1[UInt16]
; ============================================================


```
------------------------------------------------

### 39. PolynomialMultiplyWideningUpper

`Vector128<ushort> PolynomialMultiplyWideningUpper(Vector128<byte> left, Vector128<byte> right)`

Performs 'PolynomialMultiplyWideningUpper' operation.

```csharp
private Vector128<ushort> PolynomialMultiplyWideningUpperTest(Vector128<byte> left, Vector128<byte> right)
{
  return AdvSimd.PolynomialMultiplyWideningUpper(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26>
// right = <21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36>
// Result = <503, 408, 403, 704, 759, 816, 779, 808>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<short> PolynomialMultiplyWideningUpper(Vector128<sbyte> left, Vector128<sbyte> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.polynomialmultiplywideningupper?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:PolynomialMultiplyWideningUpperTest(System.Runtime.Intrinsics.Vector128`1[Byte],System.Runtime.Intrinsics.Vector128`1[Byte]):System.Runtime.Intrinsics.Vector128`1[UInt16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M29407_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     q0, [fp,#32]
            str     q1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M29407_IG02:
            ldr     q16, [fp,#32]
            ldr     q17, [fp,#16]
            pmull2  v16.8h, v16.16b, v17.16b
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 6.50
G_M29407_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 16.00, (MethodHash=c52f8d20) for method AdvSimdMethods:PolynomialMultiplyWideningUpperTest(System.Runtime.Intrinsics.Vector128`1[Byte],System.Runtime.Intrinsics.Vector128`1[Byte]):System.Runtime.Intrinsics.Vector128`1[UInt16]
; ============================================================


```
------------------------------------------------

### 40. PopCount

`Vector64<byte> PopCount(Vector64<byte> value)`

Performs 'PopCount' operation.

```csharp
private Vector64<byte> PopCountTest(Vector64<byte> value)
{
  return AdvSimd.PopCount(value);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// Result = <3, 2, 3, 3, 4, 1, 2, 2>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<sbyte> PopCount(Vector64<sbyte> value)
Vector128<byte> PopCount(Vector128<byte> value)
Vector128<sbyte> PopCount(Vector128<sbyte> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.popcount?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:PopCountTest(System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M53485_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M53485_IG02:
            ldr     d16, [fp,#24]
            cnt     v16.8b, v16.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 3.50
G_M53485_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=bbeb2f12) for method AdvSimdMethods:PopCountTest(System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 41. ReciprocalEstimate

`Vector64<float> ReciprocalEstimate(Vector64<float> value)`

Performs 'ReciprocalEstimate' operation.

```csharp
private Vector64<float> ReciprocalEstimateTest(Vector64<float> value)
{
  return AdvSimd.ReciprocalEstimate(value);
}
// value = <11.5, 12.5>
// Result = <0.08691406, 0.079833984>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<uint> ReciprocalEstimate(Vector64<uint> value)
Vector128<float> ReciprocalEstimate(Vector128<float> value)
Vector128<uint> ReciprocalEstimate(Vector128<uint> value)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> ReciprocalEstimate(Vector128<double> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.reciprocalestimate?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.reciprocalestimate?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ReciprocalEstimateTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M27177_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M27177_IG02:
            ldr     d16, [fp,#24]
            frecpe  v16.2s, v16.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 3.50
G_M27177_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=68c295d6) for method AdvSimdMethods:ReciprocalEstimateTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 42. ReciprocalSquareRootEstimate

`Vector64<float> ReciprocalSquareRootEstimate(Vector64<float> value)`

Performs 'ReciprocalSquareRootEstimate' operation.

```csharp
private Vector64<float> ReciprocalSquareRootEstimateTest(Vector64<float> value)
{
  return AdvSimd.ReciprocalSquareRootEstimate(value);
}
// value = <11.5, 12.5>
// Result = <0.29492188, 0.28222656>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<uint> ReciprocalSquareRootEstimate(Vector64<uint> value)
Vector128<float> ReciprocalSquareRootEstimate(Vector128<float> value)
Vector128<uint> ReciprocalSquareRootEstimate(Vector128<uint> value)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> ReciprocalSquareRootEstimate(Vector128<double> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.reciprocalsquarerootestimate?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.reciprocalsquarerootestimate?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ReciprocalSquareRootEstimateTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M60014_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M60014_IG02:
            ldr     d16, [fp,#24]
            frsqrte v16.2s, v16.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 3.50
G_M60014_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=7e8c1591) for method AdvSimdMethods:ReciprocalSquareRootEstimateTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 43. ReciprocalSquareRootStep

`Vector64<float> ReciprocalSquareRootStep(Vector64<float> left, Vector64<float> right)`

Performs 'ReciprocalSquareRootStep' operation.

```csharp
private Vector64<float> ReciprocalSquareRootStepTest(Vector64<float> left, Vector64<float> right)
{
  return AdvSimd.ReciprocalSquareRootStep(left, right);
}
// left = <11.5, 12.5>
// right = <21.5, 22.5>
// Result = <-122.125, -139.125>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<float> ReciprocalSquareRootStep(Vector128<float> left, Vector128<float> right)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> ReciprocalSquareRootStep(Vector128<double> left, Vector128<double> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.reciprocalsquarerootstep?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.reciprocalsquarerootstep?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ReciprocalSquareRootStepTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M52651_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M52651_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            frsqrts v16.2s, v16.2s, v17.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M52651_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=8f103254) for method AdvSimdMethods:ReciprocalSquareRootStepTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 44. ReciprocalStep

`Vector64<float> ReciprocalStep(Vector64<float> left, Vector64<float> right)`

Performs 'ReciprocalStep' operation.

```csharp
private Vector64<float> ReciprocalStepTest(Vector64<float> left, Vector64<float> right)
{
  return AdvSimd.ReciprocalStep(left, right);
}
// left = <11.5, 12.5>
// right = <21.5, 22.5>
// Result = <-245.25, -279.25>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<float> ReciprocalStep(Vector128<float> left, Vector128<float> right)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> ReciprocalStep(Vector128<double> left, Vector128<double> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.reciprocalstep?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.reciprocalstep?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ReciprocalStepTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M7948_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M7948_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            frecps  v16.2s, v16.2s, v17.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M7948_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=b68de0f3) for method AdvSimdMethods:ReciprocalStepTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 45. ReverseElement16

`Vector64<int> ReverseElement16(Vector64<int> value)`

Performs 'ReverseElement16' operation.

```csharp
private Vector64<int> ReverseElement16Test(Vector64<int> value)
{
  return AdvSimd.ReverseElement16(value);
}
// value = <11, 12>
// Result = <720896, 786432>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<long> ReverseElement16(Vector64<long> value)
Vector64<uint> ReverseElement16(Vector64<uint> value)
Vector64<ulong> ReverseElement16(Vector64<ulong> value)
Vector128<int> ReverseElement16(Vector128<int> value)
Vector128<long> ReverseElement16(Vector128<long> value)
Vector128<uint> ReverseElement16(Vector128<uint> value)
Vector128<ulong> ReverseElement16(Vector128<ulong> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.reverseelement16?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ReverseElement16Test(System.Runtime.Intrinsics.Vector64`1[Int32]):System.Runtime.Intrinsics.Vector64`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M56088_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M56088_IG02:
            ldr     d16, [fp,#24]
            rev32   v16.4h, v16.4h
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 3.50
G_M56088_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=fbcd24e7) for method AdvSimdMethods:ReverseElement16Test(System.Runtime.Intrinsics.Vector64`1[Int32]):System.Runtime.Intrinsics.Vector64`1[Int32]
; ============================================================


```
------------------------------------------------

### 46. ReverseElement32

`Vector64<long> ReverseElement32(Vector64<long> value)`

Performs 'ReverseElement32' operation.

```csharp
private Vector64<long> ReverseElement32Test(Vector64<long> value)
{
  return AdvSimd.ReverseElement32(value);
}
// value = <11>
// Result = <47244640256>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<ulong> ReverseElement32(Vector64<ulong> value)
Vector128<long> ReverseElement32(Vector128<long> value)
Vector128<ulong> ReverseElement32(Vector128<ulong> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.reverseelement32?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ReverseElement32Test(System.Runtime.Intrinsics.Vector64`1[Int64]):System.Runtime.Intrinsics.Vector64`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M44286_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M44286_IG02:
            ldr     d16, [fp,#24]
            rev64   v16.2s, v16.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 3.50
G_M44286_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=f3435301) for method AdvSimdMethods:ReverseElement32Test(System.Runtime.Intrinsics.Vector64`1[Int64]):System.Runtime.Intrinsics.Vector64`1[Int64]
; ============================================================


```
------------------------------------------------

### 47. ReverseElement8

`Vector64<short> ReverseElement8(Vector64<short> value)`

Performs 'ReverseElement8' operation.

```csharp
private Vector64<short> ReverseElement8Test(Vector64<short> value)
{
  return AdvSimd.ReverseElement8(value);
}
// value = <11, 12, 13, 14>
// Result = <2816, 3072, 3328, 3584>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<int> ReverseElement8(Vector64<int> value)
Vector64<long> ReverseElement8(Vector64<long> value)
Vector64<ushort> ReverseElement8(Vector64<ushort> value)
Vector64<uint> ReverseElement8(Vector64<uint> value)
Vector64<ulong> ReverseElement8(Vector64<ulong> value)
Vector128<short> ReverseElement8(Vector128<short> value)
Vector128<int> ReverseElement8(Vector128<int> value)
Vector128<long> ReverseElement8(Vector128<long> value)
Vector128<ushort> ReverseElement8(Vector128<ushort> value)
Vector128<uint> ReverseElement8(Vector128<uint> value)
Vector128<ulong> ReverseElement8(Vector128<ulong> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.reverseelement8?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ReverseElement8Test(System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M52167_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M52167_IG02:
            ldr     d16, [fp,#24]
            rev16   v16.8b, v16.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 3.50
G_M52167_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=f8603438) for method AdvSimdMethods:ReverseElement8Test(System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 48. RoundAwayFromZero

`Vector64<float> RoundAwayFromZero(Vector64<float> value)`

Performs 'RoundAwayFromZero' operation.

```csharp
private Vector64<float> RoundAwayFromZeroTest(Vector64<float> value)
{
  return AdvSimd.RoundAwayFromZero(value);
}
// value = <11.5, 12.5>
// Result = <12, 13>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<float> RoundAwayFromZero(Vector128<float> value)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> RoundAwayFromZero(Vector128<double> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.roundawayfromzero?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.roundawayfromzero?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:RoundAwayFromZeroTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M45977_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M45977_IG02:
            ldr     d16, [fp,#24]
            frinta  v16.2s, v16.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M45977_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=1f624c66) for method AdvSimdMethods:RoundAwayFromZeroTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 49. RoundAwayFromZeroScalar

`Vector64<double> RoundAwayFromZeroScalar(Vector64<double> value)`

Performs 'RoundAwayFromZeroScalar' operation.

```csharp
private Vector64<double> RoundAwayFromZeroScalarTest(Vector64<double> value)
{
  return AdvSimd.RoundAwayFromZeroScalar(value);
}
// value = <11.5>
// Result = <12>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<float> RoundAwayFromZeroScalar(Vector64<float> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.roundawayfromzeroscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:RoundAwayFromZeroScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M16919_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M16919_IG02:
            ldr     d16, [fp,#24]
            frinta  d16, d16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 4.50
G_M16919_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 12.20, (MethodHash=e192bde8) for method AdvSimdMethods:RoundAwayFromZeroScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 50. RoundToNearest

`Vector64<float> RoundToNearest(Vector64<float> value)`

Performs 'RoundToNearest' operation.

```csharp
private Vector64<float> RoundToNearestTest(Vector64<float> value)
{
  return AdvSimd.RoundToNearest(value);
}
// value = <11.5, 12.5>
// Result = <12, 12>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<float> RoundToNearest(Vector128<float> value)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> RoundToNearest(Vector128<double> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.roundtonearest?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.roundtonearest?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:RoundToNearestTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M15234_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M15234_IG02:
            ldr     d16, [fp,#24]
            frintn  v16.2s, v16.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M15234_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=f78ac47d) for method AdvSimdMethods:RoundToNearestTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 51. RoundToNearestScalar

`Vector64<double> RoundToNearestScalar(Vector64<double> value)`

Performs 'RoundToNearestScalar' operation.

```csharp
private Vector64<double> RoundToNearestScalarTest(Vector64<double> value)
{
  return AdvSimd.RoundToNearestScalar(value);
}
// value = <11.5>
// Result = <12>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<float> RoundToNearestScalar(Vector64<float> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.roundtonearestscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:RoundToNearestScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M11340_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M11340_IG02:
            ldr     d16, [fp,#24]
            frintn  d16, d16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 4.50
G_M11340_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 12.20, (MethodHash=a0add3b3) for method AdvSimdMethods:RoundToNearestScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 52. RoundToNegativeInfinity

`Vector64<float> RoundToNegativeInfinity(Vector64<float> value)`

Performs 'RoundToNegativeInfinity' operation.

```csharp
private Vector64<float> RoundToNegativeInfinityTest(Vector64<float> value)
{
  return AdvSimd.RoundToNegativeInfinity(value);
}
// value = <11.5, 12.5>
// Result = <11, 12>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<float> RoundToNegativeInfinity(Vector128<float> value)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> RoundToNegativeInfinity(Vector128<double> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.roundtonegativeinfinity?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.roundtonegativeinfinity?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:RoundToNegativeInfinityTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M42041_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M42041_IG02:
            ldr     d16, [fp,#24]
            frintm  v16.2s, v16.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M42041_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=d4a75bc6) for method AdvSimdMethods:RoundToNegativeInfinityTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 53. RoundToNegativeInfinityScalar

`Vector64<double> RoundToNegativeInfinityScalar(Vector64<double> value)`

Performs 'RoundToNegativeInfinityScalar' operation.

```csharp
private Vector64<double> RoundToNegativeInfinityScalarTest(Vector64<double> value)
{
  return AdvSimd.RoundToNegativeInfinityScalar(value);
}
// value = <11.5>
// Result = <11>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<float> RoundToNegativeInfinityScalar(Vector64<float> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.roundtonegativeinfinityscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:RoundToNegativeInfinityScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M49527_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M49527_IG02:
            ldr     d16, [fp,#24]
            frintm  d16, d16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 4.50
G_M49527_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 12.20, (MethodHash=25df3e88) for method AdvSimdMethods:RoundToNegativeInfinityScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 54. RoundToPositiveInfinity

`Vector64<float> RoundToPositiveInfinity(Vector64<float> value)`

Performs 'RoundToPositiveInfinity' operation.

```csharp
private Vector64<float> RoundToPositiveInfinityTest(Vector64<float> value)
{
  return AdvSimd.RoundToPositiveInfinity(value);
}
// value = <11.5, 12.5>
// Result = <12, 13>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<float> RoundToPositiveInfinity(Vector128<float> value)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> RoundToPositiveInfinity(Vector128<double> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.roundtopositiveinfinity?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.roundtopositiveinfinity?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:RoundToPositiveInfinityTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M27761_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M27761_IG02:
            ldr     d16, [fp,#24]
            frintp  v16.2s, v16.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M27761_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=23c8938e) for method AdvSimdMethods:RoundToPositiveInfinityTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 55. RoundToPositiveInfinityScalar

`Vector64<double> RoundToPositiveInfinityScalar(Vector64<double> value)`

Performs 'RoundToPositiveInfinityScalar' operation.

```csharp
private Vector64<double> RoundToPositiveInfinityScalarTest(Vector64<double> value)
{
  return AdvSimd.RoundToPositiveInfinityScalar(value);
}
// value = <11.5>
// Result = <12>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<float> RoundToPositiveInfinityScalar(Vector64<float> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.roundtopositiveinfinityscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:RoundToPositiveInfinityScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M48063_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M48063_IG02:
            ldr     d16, [fp,#24]
            frintp  d16, d16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 4.50
G_M48063_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 12.20, (MethodHash=68da4440) for method AdvSimdMethods:RoundToPositiveInfinityScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 56. RoundToZero

`Vector64<float> RoundToZero(Vector64<float> value)`

Performs 'RoundToZero' operation.

```csharp
private Vector64<float> RoundToZeroTest(Vector64<float> value)
{
  return AdvSimd.RoundToZero(value);
}
// value = <11.5, 12.5>
// Result = <11, 12>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<float> RoundToZero(Vector128<float> value)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> RoundToZero(Vector128<double> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.roundtozero?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.roundtozero?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:RoundToZeroTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M34234_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M34234_IG02:
            ldr     d16, [fp,#24]
            frintz  v16.2s, v16.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M34234_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=3c467a45) for method AdvSimdMethods:RoundToZeroTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 57. RoundToZeroScalar

`Vector64<double> RoundToZeroScalar(Vector64<double> value)`

Performs 'RoundToZeroScalar' operation.

```csharp
private Vector64<double> RoundToZeroScalarTest(Vector64<double> value)
{
  return AdvSimd.RoundToZeroScalar(value);
}
// value = <11.5>
// Result = <11>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<float> RoundToZeroScalar(Vector64<float> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.roundtozeroscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:RoundToZeroScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M42548_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M42548_IG02:
            ldr     d16, [fp,#24]
            frintz  d16, d16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 4.50
G_M42548_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 12.20, (MethodHash=a46e59cb) for method AdvSimdMethods:RoundToZeroScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 58. ShiftArithmetic

`Vector64<short> ShiftArithmetic(Vector64<short> value, Vector64<short> count)`

Performs 'ShiftArithmetic' operation.

```csharp
private Vector64<short> ShiftArithmeticTest(Vector64<short> value, Vector64<short> count)
{
  return AdvSimd.ShiftArithmetic(value, count);
}
// value = <11, 12, 13, 14>
// count = <21, 22, 23, 24>
// Result = <0, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<int> ShiftArithmetic(Vector64<int> value, Vector64<int> count)
Vector64<sbyte> ShiftArithmetic(Vector64<sbyte> value, Vector64<sbyte> count)
Vector128<short> ShiftArithmetic(Vector128<short> value, Vector128<short> count)
Vector128<int> ShiftArithmetic(Vector128<int> value, Vector128<int> count)
Vector128<long> ShiftArithmetic(Vector128<long> value, Vector128<long> count)
Vector128<sbyte> ShiftArithmetic(Vector128<sbyte> value, Vector128<sbyte> count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftarithmetic?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftArithmeticTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M13566_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M13566_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            sshl    v16.4h, v16.4h, v17.4h
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M13566_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=687dcb01) for method AdvSimdMethods:ShiftArithmeticTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 59. ShiftArithmeticRounded

`Vector64<short> ShiftArithmeticRounded(Vector64<short> value, Vector64<short> count)`

Performs 'ShiftArithmeticRounded' operation.

```csharp
private Vector64<short> ShiftArithmeticRoundedTest(Vector64<short> value, Vector64<short> count)
{
  return AdvSimd.ShiftArithmeticRounded(value, count);
}
// value = <11, 12, 13, 14>
// count = <21, 22, 23, 24>
// Result = <0, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<int> ShiftArithmeticRounded(Vector64<int> value, Vector64<int> count)
Vector64<sbyte> ShiftArithmeticRounded(Vector64<sbyte> value, Vector64<sbyte> count)
Vector128<short> ShiftArithmeticRounded(Vector128<short> value, Vector128<short> count)
Vector128<int> ShiftArithmeticRounded(Vector128<int> value, Vector128<int> count)
Vector128<long> ShiftArithmeticRounded(Vector128<long> value, Vector128<long> count)
Vector128<sbyte> ShiftArithmeticRounded(Vector128<sbyte> value, Vector128<sbyte> count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftarithmeticrounded?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftArithmeticRoundedTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M51901_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M51901_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            srshl   v16.4h, v16.4h, v17.4h
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M51901_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=52083542) for method AdvSimdMethods:ShiftArithmeticRoundedTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 60. ShiftArithmeticRoundedSaturate

`Vector64<short> ShiftArithmeticRoundedSaturate(Vector64<short> value, Vector64<short> count)`

Performs 'ShiftArithmeticRoundedSaturate' operation.

```csharp
private Vector64<short> ShiftArithmeticRoundedSaturateTest(Vector64<short> value, Vector64<short> count)
{
  return AdvSimd.ShiftArithmeticRoundedSaturate(value, count);
}
// value = <11, 12, 13, 14>
// count = <21, 22, 23, 24>
// Result = <32767, 32767, 32767, 32767>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<int> ShiftArithmeticRoundedSaturate(Vector64<int> value, Vector64<int> count)
Vector64<sbyte> ShiftArithmeticRoundedSaturate(Vector64<sbyte> value, Vector64<sbyte> count)
Vector128<short> ShiftArithmeticRoundedSaturate(Vector128<short> value, Vector128<short> count)
Vector128<int> ShiftArithmeticRoundedSaturate(Vector128<int> value, Vector128<int> count)
Vector128<long> ShiftArithmeticRoundedSaturate(Vector128<long> value, Vector128<long> count)
Vector128<sbyte> ShiftArithmeticRoundedSaturate(Vector128<sbyte> value, Vector128<sbyte> count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftarithmeticroundedsaturate?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftArithmeticRoundedSaturateTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M61900_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M61900_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            sqrshl  v16.4h, v16.4h, v17.4h
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M61900_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=68880e33) for method AdvSimdMethods:ShiftArithmeticRoundedSaturateTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================

```

---
STARTlayout:post
title: Hardware Intrinsics APIs for ARM64 - Part 4
subtitle: With examples
tags: [work, arm64, intrinsics]
---

### Introduction

In my [last post](../2019-01-01-Vectorization-APIs), I describe SIMD datatypes `Vector64<T>` and `Vector128<T>` that operates on 'hardware intrisic' APIs. In this post I will describe the intrinsic APIs for ARM64 and how you can use them to optimize your code if you are writing a .NET API targetting ARM64. This is 3 post series TODO.


### API list

[ShiftArithmeticRoundedSaturateScalar](#1-shiftarithmeticroundedsaturatescalar), [ShiftArithmeticRoundedScalar](#2-shiftarithmeticroundedscalar), [ShiftArithmeticSaturate](#3-shiftarithmeticsaturate), [ShiftArithmeticSaturateScalar](#4-shiftarithmeticsaturatescalar), [ShiftArithmeticScalar](#5-shiftarithmeticscalar), [ShiftLeftAndInsert](#6-shiftleftandinsert), [ShiftLeftAndInsertScalar](#7-shiftleftandinsertscalar), [ShiftLeftLogical](#8-shiftleftlogical), [ShiftLeftLogicalSaturate](#9-shiftleftlogicalsaturate), [ShiftLeftLogicalSaturateScalar](#10-shiftleftlogicalsaturatescalar), [ShiftLeftLogicalSaturateUnsigned](#11-shiftleftlogicalsaturateunsigned), [ShiftLeftLogicalSaturateUnsignedScalar](#12-shiftleftlogicalsaturateunsignedscalar), [ShiftLeftLogicalScalar](#13-shiftleftlogicalscalar), [ShiftLeftLogicalWideningLower](#14-shiftleftlogicalwideninglower), [ShiftLeftLogicalWideningUpper](#15-shiftleftlogicalwideningupper), [ShiftLogical](#16-shiftlogical), [ShiftLogicalRounded](#17-shiftlogicalrounded), [ShiftLogicalRoundedSaturate](#18-shiftlogicalroundedsaturate), [ShiftLogicalRoundedSaturateScalar](#19-shiftlogicalroundedsaturatescalar), [ShiftLogicalRoundedScalar](#20-shiftlogicalroundedscalar), [ShiftLogicalSaturate](#21-shiftlogicalsaturate), [ShiftLogicalSaturateScalar](#22-shiftlogicalsaturatescalar), [ShiftLogicalScalar](#23-shiftlogicalscalar), [ShiftRightAndInsert](#24-shiftrightandinsert), [ShiftRightAndInsertScalar](#25-shiftrightandinsertscalar), [ShiftRightArithmetic](#26-shiftrightarithmetic), [ShiftRightArithmeticAdd](#27-shiftrightarithmeticadd), [ShiftRightArithmeticAddScalar](#28-shiftrightarithmeticaddscalar), [ShiftRightArithmeticNarrowingSaturateLower](#29-shiftrightarithmeticnarrowingsaturatelower), [ShiftRightArithmeticNarrowingSaturateUnsignedLower](#30-shiftrightarithmeticnarrowingsaturateunsignedlower), [ShiftRightArithmeticNarrowingSaturateUnsignedUpper](#31-shiftrightarithmeticnarrowingsaturateunsignedupper), [ShiftRightArithmeticNarrowingSaturateUpper](#32-shiftrightarithmeticnarrowingsaturateupper), [ShiftRightArithmeticRounded](#33-shiftrightarithmeticrounded), [ShiftRightArithmeticRoundedAdd](#34-shiftrightarithmeticroundedadd), [ShiftRightArithmeticRoundedAddScalar](#35-shiftrightarithmeticroundedaddscalar), [ShiftRightArithmeticRoundedNarrowingSaturateLower](#36-shiftrightarithmeticroundednarrowingsaturatelower), [ShiftRightArithmeticRoundedNarrowingSaturateUnsignedLower](#37-shiftrightarithmeticroundednarrowingsaturateunsignedlower), [ShiftRightArithmeticRoundedNarrowingSaturateUnsignedUpper](#38-shiftrightarithmeticroundednarrowingsaturateunsignedupper), [ShiftRightArithmeticRoundedNarrowingSaturateUpper](#39-shiftrightarithmeticroundednarrowingsaturateupper), [ShiftRightArithmeticRoundedScalar](#40-shiftrightarithmeticroundedscalar), [ShiftRightArithmeticScalar](#41-shiftrightarithmeticscalar), [ShiftRightLogical](#42-shiftrightlogical), [ShiftRightLogicalAdd](#43-shiftrightlogicaladd), [ShiftRightLogicalAddScalar](#44-shiftrightlogicaladdscalar), [ShiftRightLogicalNarrowingLower](#45-shiftrightlogicalnarrowinglower), [ShiftRightLogicalNarrowingSaturateLower](#46-shiftrightlogicalnarrowingsaturatelower), [ShiftRightLogicalNarrowingSaturateUpper](#47-shiftrightlogicalnarrowingsaturateupper), [ShiftRightLogicalNarrowingUpper](#48-shiftrightlogicalnarrowingupper), [ShiftRightLogicalRounded](#49-shiftrightlogicalrounded), [ShiftRightLogicalRoundedAdd](#50-shiftrightlogicalroundedadd), [ShiftRightLogicalRoundedAddScalar](#51-shiftrightlogicalroundedaddscalar), [ShiftRightLogicalRoundedNarrowingLower](#52-shiftrightlogicalroundednarrowinglower), [ShiftRightLogicalRoundedNarrowingSaturateLower](#53-shiftrightlogicalroundednarrowingsaturatelower), [ShiftRightLogicalRoundedNarrowingSaturateUpper](#54-shiftrightlogicalroundednarrowingsaturateupper), [ShiftRightLogicalRoundedNarrowingUpper](#55-shiftrightlogicalroundednarrowingupper), [ShiftRightLogicalRoundedScalar](#56-shiftrightlogicalroundedscalar), [ShiftRightLogicalScalar](#57-shiftrightlogicalscalar), [SignExtendWideningLower](#58-signextendwideninglower), [SignExtendWideningUpper](#59-signextendwideningupper), [SqrtScalar](#60-sqrtscalar),[...](Part4.md)






### 1. ShiftArithmeticRoundedSaturateScalar

`Vector64<long> ShiftArithmeticRoundedSaturateScalar(Vector64<long> value, Vector64<long> count)`

Performs 'ShiftArithmeticRoundedSaturateScalar' operation.

```csharp
private Vector64<long> ShiftArithmeticRoundedSaturateScalarTest(Vector64<long> value, Vector64<long> count)
{
  return AdvSimd.ShiftArithmeticRoundedSaturateScalar(value, count);
}
// value = <11>
// count = <11>
// Result = <22528>

```

Similar APIs that operate on different sizes:

```csharp


// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<short> ShiftArithmeticRoundedSaturateScalar(Vector64<short> value, Vector64<short> count)
Vector64<int> ShiftArithmeticRoundedSaturateScalar(Vector64<int> value, Vector64<int> count)
Vector64<sbyte> ShiftArithmeticRoundedSaturateScalar(Vector64<sbyte> value, Vector64<sbyte> count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftarithmeticroundedsaturatescalar?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.shiftarithmeticroundedsaturatescalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftArithmeticRoundedSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64]):System.Runtime.Intrinsics.Vector64`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M30407_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M30407_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            sqrshl  d16, d16, d17
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M30407_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=4b728938) for method AdvSimdMethods:ShiftArithmeticRoundedSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64]):System.Runtime.Intrinsics.Vector64`1[Int64]
; ============================================================


```
------------------------------------------------

### 2. ShiftArithmeticRoundedScalar

`Vector64<long> ShiftArithmeticRoundedScalar(Vector64<long> value, Vector64<long> count)`

Performs 'ShiftArithmeticRoundedScalar' operation.

```csharp
private Vector64<long> ShiftArithmeticRoundedScalarTest(Vector64<long> value, Vector64<long> count)
{
  return AdvSimd.ShiftArithmeticRoundedScalar(value, count);
}
// value = <11>
// count = <11>
// Result = <22528>

```



See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftarithmeticroundedscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftArithmeticRoundedScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64]):System.Runtime.Intrinsics.Vector64`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M33718_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M33718_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            srshl   d16, d16, d17
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M33718_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=69517c49) for method AdvSimdMethods:ShiftArithmeticRoundedScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64]):System.Runtime.Intrinsics.Vector64`1[Int64]
; ============================================================


```
------------------------------------------------

### 3. ShiftArithmeticSaturate

`Vector64<short> ShiftArithmeticSaturate(Vector64<short> value, Vector64<short> count)`

Performs 'ShiftArithmeticSaturate' operation.

```csharp
private Vector64<short> ShiftArithmeticSaturateTest(Vector64<short> value, Vector64<short> count)
{
  return AdvSimd.ShiftArithmeticSaturate(value, count);
}
// value = <11, 12, 13, 14>
// count = <21, 22, 23, 24>
// Result = <32767, 32767, 32767, 32767>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<int> ShiftArithmeticSaturate(Vector64<int> value, Vector64<int> count)
Vector64<sbyte> ShiftArithmeticSaturate(Vector64<sbyte> value, Vector64<sbyte> count)
Vector128<short> ShiftArithmeticSaturate(Vector128<short> value, Vector128<short> count)
Vector128<int> ShiftArithmeticSaturate(Vector128<int> value, Vector128<int> count)
Vector128<long> ShiftArithmeticSaturate(Vector128<long> value, Vector128<long> count)
Vector128<sbyte> ShiftArithmeticSaturate(Vector128<sbyte> value, Vector128<sbyte> count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftarithmeticsaturate?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftArithmeticSaturateTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M61071_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M61071_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            sqshl   v16.4h, v16.4h, v17.4h
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M61071_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=11d11170) for method AdvSimdMethods:ShiftArithmeticSaturateTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 4. ShiftArithmeticSaturateScalar

`Vector64<long> ShiftArithmeticSaturateScalar(Vector64<long> value, Vector64<long> count)`

Performs 'ShiftArithmeticSaturateScalar' operation.

```csharp
private Vector64<long> ShiftArithmeticSaturateScalarTest(Vector64<long> value, Vector64<long> count)
{
  return AdvSimd.ShiftArithmeticSaturateScalar(value, count);
}
// value = <11>
// count = <11>
// Result = <22528>

```

Similar APIs that operate on different sizes:

```csharp


// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<short> ShiftArithmeticSaturateScalar(Vector64<short> value, Vector64<short> count)
Vector64<int> ShiftArithmeticSaturateScalar(Vector64<int> value, Vector64<int> count)
Vector64<sbyte> ShiftArithmeticSaturateScalar(Vector64<sbyte> value, Vector64<sbyte> count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftarithmeticsaturatescalar?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.shiftarithmeticsaturatescalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftArithmeticSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64]):System.Runtime.Intrinsics.Vector64`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M42436_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M42436_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            sqshl   d16, d16, d17
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M42436_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=34045a3b) for method AdvSimdMethods:ShiftArithmeticSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64]):System.Runtime.Intrinsics.Vector64`1[Int64]
; ============================================================


```
------------------------------------------------

### 5. ShiftArithmeticScalar

`Vector64<long> ShiftArithmeticScalar(Vector64<long> value, Vector64<long> count)`

Performs 'ShiftArithmeticScalar' operation.

```csharp
private Vector64<long> ShiftArithmeticScalarTest(Vector64<long> value, Vector64<long> count)
{
  return AdvSimd.ShiftArithmeticScalar(value, count);
}
// value = <11>
// count = <11>
// Result = <22528>

```



See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftarithmeticscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftArithmeticScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64]):System.Runtime.Intrinsics.Vector64`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M18869_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M18869_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            sshl    d16, d16, d17
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M18869_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=9a96b64a) for method AdvSimdMethods:ShiftArithmeticScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64]):System.Runtime.Intrinsics.Vector64`1[Int64]
; ============================================================


```
------------------------------------------------

### 6. ShiftLeftAndInsert

`Vector64<byte> ShiftLeftAndInsert(Vector64<byte> left, Vector64<byte> right, byte shift)`

Performs 'ShiftLeftAndInsert' operation.

```csharp
private Vector64<byte> ShiftLeftAndInsertTest(Vector64<byte> left, Vector64<byte> right, byte shift)
{
  return AdvSimd.ShiftLeftAndInsert(left, right, shift);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// shift = 0
// Result = <21, 22, 23, 24, 25, 26, 27, 28>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> ShiftLeftAndInsert(Vector64<short> left, Vector64<short> right, byte shift)
Vector64<int> ShiftLeftAndInsert(Vector64<int> left, Vector64<int> right, byte shift)
Vector64<sbyte> ShiftLeftAndInsert(Vector64<sbyte> left, Vector64<sbyte> right, byte shift)
Vector64<ushort> ShiftLeftAndInsert(Vector64<ushort> left, Vector64<ushort> right, byte shift)
Vector64<uint> ShiftLeftAndInsert(Vector64<uint> left, Vector64<uint> right, byte shift)
Vector128<byte> ShiftLeftAndInsert(Vector128<byte> left, Vector128<byte> right, byte shift)
Vector128<short> ShiftLeftAndInsert(Vector128<short> left, Vector128<short> right, byte shift)
Vector128<int> ShiftLeftAndInsert(Vector128<int> left, Vector128<int> right, byte shift)
Vector128<long> ShiftLeftAndInsert(Vector128<long> left, Vector128<long> right, byte shift)
Vector128<sbyte> ShiftLeftAndInsert(Vector128<sbyte> left, Vector128<sbyte> right, byte shift)
Vector128<ushort> ShiftLeftAndInsert(Vector128<ushort> left, Vector128<ushort> right, byte shift)
Vector128<uint> ShiftLeftAndInsert(Vector128<uint> left, Vector128<uint> right, byte shift)
Vector128<ulong> ShiftLeftAndInsert(Vector128<ulong> left, Vector128<ulong> right, byte shift)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftleftandinsert?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftLeftAndInsertTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M65508_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M65508_IG02:
            ldr     d0, [fp,#24]
            ldr     d1, [fp,#16]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftLeftAndInsert(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
						;; bbWeight=1    PerfScore 5.50
G_M65508_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=5fe0001b) for method AdvSimdMethods:ShiftLeftAndInsertTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 7. ShiftLeftAndInsertScalar

`Vector64<long> ShiftLeftAndInsertScalar(Vector64<long> left, Vector64<long> right, byte shift)`

Performs 'ShiftLeftAndInsertScalar' operation.

```csharp
private Vector64<long> ShiftLeftAndInsertScalarTest(Vector64<long> left, Vector64<long> right, byte shift)
{
  return AdvSimd.ShiftLeftAndInsertScalar(left, right, shift);
}
// left = <11>
// right = <11>
// shift = 0
// Result = <11>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<ulong> ShiftLeftAndInsertScalar(Vector64<ulong> left, Vector64<ulong> right, byte shift)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftleftandinsertscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftLeftAndInsertScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M45713_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M45713_IG02:
            ldr     d0, [fp,#24]
            ldr     d1, [fp,#16]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftLeftAndInsertScalar(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
						;; bbWeight=1    PerfScore 5.50
G_M45713_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=2e634d6e) for method AdvSimdMethods:ShiftLeftAndInsertScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
; ============================================================


```
------------------------------------------------

### 8. ShiftLeftLogical

`Vector64<byte> ShiftLeftLogical(Vector64<byte> value, byte count)`

Performs 'ShiftLeftLogical' operation.

```csharp
private Vector64<byte> ShiftLeftLogicalTest(Vector64<byte> value, byte count)
{
  return AdvSimd.ShiftLeftLogical(value, count);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// count = 0
// Result = <11, 12, 13, 14, 15, 16, 17, 18>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> ShiftLeftLogical(Vector64<short> value, byte count)
Vector64<int> ShiftLeftLogical(Vector64<int> value, byte count)
Vector64<sbyte> ShiftLeftLogical(Vector64<sbyte> value, byte count)
Vector64<ushort> ShiftLeftLogical(Vector64<ushort> value, byte count)
Vector64<uint> ShiftLeftLogical(Vector64<uint> value, byte count)
Vector128<byte> ShiftLeftLogical(Vector128<byte> value, byte count)
Vector128<short> ShiftLeftLogical(Vector128<short> value, byte count)
Vector128<long> ShiftLeftLogical(Vector128<long> value, byte count)
Vector128<sbyte> ShiftLeftLogical(Vector128<sbyte> value, byte count)
Vector128<ushort> ShiftLeftLogical(Vector128<ushort> value, byte count)
Vector128<uint> ShiftLeftLogical(Vector128<uint> value, byte count)
Vector128<ulong> ShiftLeftLogical(Vector128<ulong> value, byte count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftleftlogical?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftLeftLogicalTest(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M1386_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M1386_IG02:
            ldr     d0, [fp,#24]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftLeftLogical(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
						;; bbWeight=1    PerfScore 3.50
G_M1386_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=7a1ffa95) for method AdvSimdMethods:ShiftLeftLogicalTest(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 9. ShiftLeftLogicalSaturate

`Vector64<byte> ShiftLeftLogicalSaturate(Vector64<byte> value, byte count)`

Performs 'ShiftLeftLogicalSaturate' operation.

```csharp
private Vector64<byte> ShiftLeftLogicalSaturateTest(Vector64<byte> value, byte count)
{
  return AdvSimd.ShiftLeftLogicalSaturate(value, count);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// count = 0
// Result = <11, 12, 13, 14, 15, 16, 17, 18>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> ShiftLeftLogicalSaturate(Vector64<short> value, byte count)
Vector64<int> ShiftLeftLogicalSaturate(Vector64<int> value, byte count)
Vector64<sbyte> ShiftLeftLogicalSaturate(Vector64<sbyte> value, byte count)
Vector64<ushort> ShiftLeftLogicalSaturate(Vector64<ushort> value, byte count)
Vector64<uint> ShiftLeftLogicalSaturate(Vector64<uint> value, byte count)
Vector128<byte> ShiftLeftLogicalSaturate(Vector128<byte> value, byte count)
Vector128<short> ShiftLeftLogicalSaturate(Vector128<short> value, byte count)
Vector128<int> ShiftLeftLogicalSaturate(Vector128<int> value, byte count)
Vector128<long> ShiftLeftLogicalSaturate(Vector128<long> value, byte count)
Vector128<sbyte> ShiftLeftLogicalSaturate(Vector128<sbyte> value, byte count)
Vector128<ushort> ShiftLeftLogicalSaturate(Vector128<ushort> value, byte count)
Vector128<uint> ShiftLeftLogicalSaturate(Vector128<uint> value, byte count)
Vector128<ulong> ShiftLeftLogicalSaturate(Vector128<ulong> value, byte count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftleftlogicalsaturate?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftLeftLogicalSaturateTest(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M3675_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M3675_IG02:
            ldr     d0, [fp,#24]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftLeftLogicalSaturate(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
						;; bbWeight=1    PerfScore 3.50
G_M3675_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=3951f1a4) for method AdvSimdMethods:ShiftLeftLogicalSaturateTest(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 10. ShiftLeftLogicalSaturateScalar

`Vector64<long> ShiftLeftLogicalSaturateScalar(Vector64<long> value, byte count)`

Performs 'ShiftLeftLogicalSaturateScalar' operation.

```csharp
private Vector64<long> ShiftLeftLogicalSaturateScalarTest(Vector64<long> value, byte count)
{
  return AdvSimd.ShiftLeftLogicalSaturateScalar(value, count);
}
// value = <11>
// count = 0
// Result = <11>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<ulong> ShiftLeftLogicalSaturateScalar(Vector64<ulong> value, byte count)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<byte> ShiftLeftLogicalSaturateScalar(Vector64<byte> value, byte count)
Vector64<short> ShiftLeftLogicalSaturateScalar(Vector64<short> value, byte count)
Vector64<int> ShiftLeftLogicalSaturateScalar(Vector64<int> value, byte count)
Vector64<sbyte> ShiftLeftLogicalSaturateScalar(Vector64<sbyte> value, byte count)
Vector64<ushort> ShiftLeftLogicalSaturateScalar(Vector64<ushort> value, byte count)
Vector64<uint> ShiftLeftLogicalSaturateScalar(Vector64<uint> value, byte count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftleftlogicalsaturatescalar?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.shiftleftlogicalsaturatescalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftLeftLogicalSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M9941_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M9941_IG02:
            ldr     d0, [fp,#24]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftLeftLogicalSaturateScalar(System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
						;; bbWeight=1    PerfScore 3.50
G_M9941_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=14a1d92a) for method AdvSimdMethods:ShiftLeftLogicalSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
; ============================================================


```
------------------------------------------------

### 11. ShiftLeftLogicalSaturateUnsigned

`Vector64<ushort> ShiftLeftLogicalSaturateUnsigned(Vector64<short> value, byte count)`

Performs 'ShiftLeftLogicalSaturateUnsigned' operation.

```csharp
private Vector64<ushort> ShiftLeftLogicalSaturateUnsignedTest(Vector64<short> value, byte count)
{
  return AdvSimd.ShiftLeftLogicalSaturateUnsigned(value, count);
}
// value = <11, 12, 13, 14>
// count = 0
// Result = <11, 12, 13, 14>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<uint> ShiftLeftLogicalSaturateUnsigned(Vector64<int> value, byte count)
Vector64<byte> ShiftLeftLogicalSaturateUnsigned(Vector64<sbyte> value, byte count)
Vector128<ushort> ShiftLeftLogicalSaturateUnsigned(Vector128<short> value, byte count)
Vector128<uint> ShiftLeftLogicalSaturateUnsigned(Vector128<int> value, byte count)
Vector128<ulong> ShiftLeftLogicalSaturateUnsigned(Vector128<long> value, byte count)
Vector128<byte> ShiftLeftLogicalSaturateUnsigned(Vector128<sbyte> value, byte count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftleftlogicalsaturateunsigned?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftLeftLogicalSaturateUnsignedTest(System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[UInt16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M17511_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M17511_IG02:
            ldr     d0, [fp,#24]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftLeftLogicalSaturateUnsigned(System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[UInt16]
						;; bbWeight=1    PerfScore 3.50
G_M17511_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=a77ebb98) for method AdvSimdMethods:ShiftLeftLogicalSaturateUnsignedTest(System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[UInt16]
; ============================================================


```
------------------------------------------------

### 12. ShiftLeftLogicalSaturateUnsignedScalar

`Vector64<ulong> ShiftLeftLogicalSaturateUnsignedScalar(Vector64<long> value, byte count)`

Performs 'ShiftLeftLogicalSaturateUnsignedScalar' operation.

```csharp
private Vector64<ulong> ShiftLeftLogicalSaturateUnsignedScalarTest(Vector64<long> value, byte count)
{
  return AdvSimd.ShiftLeftLogicalSaturateUnsignedScalar(value, count);
}
// value = <11>
// count = 0
// Result = <11>

```

Similar APIs that operate on different sizes:

```csharp


// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<ushort> ShiftLeftLogicalSaturateUnsignedScalar(Vector64<short> value, byte count)
Vector64<uint> ShiftLeftLogicalSaturateUnsignedScalar(Vector64<int> value, byte count)
Vector64<byte> ShiftLeftLogicalSaturateUnsignedScalar(Vector64<sbyte> value, byte count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftleftlogicalsaturateunsignedscalar?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.shiftleftlogicalsaturateunsignedscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftLeftLogicalSaturateUnsignedScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[UInt64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M35113_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M35113_IG02:
            ldr     d0, [fp,#24]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftLeftLogicalSaturateUnsignedScalar(System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[UInt64]
						;; bbWeight=1    PerfScore 3.50
G_M35113_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=4bed76d6) for method AdvSimdMethods:ShiftLeftLogicalSaturateUnsignedScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[UInt64]
; ============================================================


```
------------------------------------------------

### 13. ShiftLeftLogicalScalar

`Vector64<long> ShiftLeftLogicalScalar(Vector64<long> value, byte count)`

Performs 'ShiftLeftLogicalScalar' operation.

```csharp
private Vector64<long> ShiftLeftLogicalScalarTest(Vector64<long> value, byte count)
{
  return AdvSimd.ShiftLeftLogicalScalar(value, count);
}
// value = <11>
// count = 0
// Result = <11>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<ulong> ShiftLeftLogicalScalar(Vector64<ulong> value, byte count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftleftlogicalscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftLeftLogicalScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M61220_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M61220_IG02:
            ldr     d0, [fp,#24]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftLeftLogicalScalar(System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
						;; bbWeight=1    PerfScore 3.50
G_M61220_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=f0cb10db) for method AdvSimdMethods:ShiftLeftLogicalScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
; ============================================================


```
------------------------------------------------

### 14. ShiftLeftLogicalWideningLower

`Vector128<ushort> ShiftLeftLogicalWideningLower(Vector64<byte> value, byte count)`

Performs 'ShiftLeftLogicalWideningLower' operation.

```csharp
private Vector128<ushort> ShiftLeftLogicalWideningLowerTest(Vector64<byte> value, byte count)
{
  return AdvSimd.ShiftLeftLogicalWideningLower(value, count);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// count = 0
// Result = <11, 12, 13, 14, 15, 16, 17, 18>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<int> ShiftLeftLogicalWideningLower(Vector64<short> value, byte count)
Vector128<long> ShiftLeftLogicalWideningLower(Vector64<int> value, byte count)
Vector128<short> ShiftLeftLogicalWideningLower(Vector64<sbyte> value, byte count)
Vector128<uint> ShiftLeftLogicalWideningLower(Vector64<ushort> value, byte count)
Vector128<ulong> ShiftLeftLogicalWideningLower(Vector64<uint> value, byte count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftleftlogicalwideninglower?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftLeftLogicalWideningLowerTest(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector128`1[UInt16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M58250_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M58250_IG02:
            ldr     d0, [fp,#24]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftLeftLogicalWideningLower(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector128`1[UInt16]
						;; bbWeight=1    PerfScore 3.50
G_M58250_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=4eca1c75) for method AdvSimdMethods:ShiftLeftLogicalWideningLowerTest(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector128`1[UInt16]
; ============================================================


```
------------------------------------------------

### 15. ShiftLeftLogicalWideningUpper

`Vector128<ushort> ShiftLeftLogicalWideningUpper(Vector128<byte> value, byte count)`

Performs 'ShiftLeftLogicalWideningUpper' operation.

```csharp
private Vector128<ushort> ShiftLeftLogicalWideningUpperTest(Vector128<byte> value, byte count)
{
  return AdvSimd.ShiftLeftLogicalWideningUpper(value, count);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26>
// count = 0
// Result = <19, 20, 21, 22, 23, 24, 25, 26>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<int> ShiftLeftLogicalWideningUpper(Vector128<short> value, byte count)
Vector128<long> ShiftLeftLogicalWideningUpper(Vector128<int> value, byte count)
Vector128<short> ShiftLeftLogicalWideningUpper(Vector128<sbyte> value, byte count)
Vector128<uint> ShiftLeftLogicalWideningUpper(Vector128<ushort> value, byte count)
Vector128<ulong> ShiftLeftLogicalWideningUpper(Vector128<uint> value, byte count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftleftlogicalwideningupper?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftLeftLogicalWideningUpperTest(System.Runtime.Intrinsics.Vector128`1[Byte],ubyte):System.Runtime.Intrinsics.Vector128`1[UInt16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T01] (  2,  4   )  simd16  ->   d0         HFA(simd16)  "Inlining Arg"
;
; Lcl frame size = 16

G_M36338_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     q0, [fp,#16]
						;; bbWeight=1    PerfScore 2.50
G_M36338_IG02:
            ldr     q0, [fp,#16]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftLeftLogicalWideningUpper(System.Runtime.Intrinsics.Vector128`1[Byte],ubyte):System.Runtime.Intrinsics.Vector128`1[UInt16]
						;; bbWeight=1    PerfScore 3.50
G_M36338_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=fcbf720d) for method AdvSimdMethods:ShiftLeftLogicalWideningUpperTest(System.Runtime.Intrinsics.Vector128`1[Byte],ubyte):System.Runtime.Intrinsics.Vector128`1[UInt16]
; ============================================================


```
------------------------------------------------

### 16. ShiftLogical

`Vector64<byte> ShiftLogical(Vector64<byte> value, Vector64<sbyte> count)`

Performs 'ShiftLogical' operation.

```csharp
private Vector64<byte> ShiftLogicalTest(Vector64<byte> value, Vector64<sbyte> count)
{
  return AdvSimd.ShiftLogical(value, count);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// count = <11, 12, 13, 14, 15, 16, 17, 18>
// Result = <0, 0, 0, 0, 0, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> ShiftLogical(Vector64<short> value, Vector64<short> count)
Vector64<int> ShiftLogical(Vector64<int> value, Vector64<int> count)
Vector64<sbyte> ShiftLogical(Vector64<sbyte> value, Vector64<sbyte> count)
Vector64<ushort> ShiftLogical(Vector64<ushort> value, Vector64<short> count)
Vector64<uint> ShiftLogical(Vector64<uint> value, Vector64<int> count)
Vector128<byte> ShiftLogical(Vector128<byte> value, Vector128<sbyte> count)
Vector128<short> ShiftLogical(Vector128<short> value, Vector128<short> count)
Vector128<int> ShiftLogical(Vector128<int> value, Vector128<int> count)
Vector128<long> ShiftLogical(Vector128<long> value, Vector128<long> count)
Vector128<sbyte> ShiftLogical(Vector128<sbyte> value, Vector128<sbyte> count)
Vector128<ushort> ShiftLogical(Vector128<ushort> value, Vector128<short> count)
Vector128<uint> ShiftLogical(Vector128<uint> value, Vector128<int> count)
Vector128<ulong> ShiftLogical(Vector128<ulong> value, Vector128<long> count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftlogical?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftLogicalTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[SByte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M31328_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M31328_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            ushl    v16.8b, v16.8b, v17.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M31328_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=388f859f) for method AdvSimdMethods:ShiftLogicalTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[SByte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 17. ShiftLogicalRounded

`Vector64<byte> ShiftLogicalRounded(Vector64<byte> value, Vector64<sbyte> count)`

Performs 'ShiftLogicalRounded' operation.

```csharp
private Vector64<byte> ShiftLogicalRoundedTest(Vector64<byte> value, Vector64<sbyte> count)
{
  return AdvSimd.ShiftLogicalRounded(value, count);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// count = <11, 12, 13, 14, 15, 16, 17, 18>
// Result = <0, 0, 0, 0, 0, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> ShiftLogicalRounded(Vector64<short> value, Vector64<short> count)
Vector64<int> ShiftLogicalRounded(Vector64<int> value, Vector64<int> count)
Vector64<sbyte> ShiftLogicalRounded(Vector64<sbyte> value, Vector64<sbyte> count)
Vector64<ushort> ShiftLogicalRounded(Vector64<ushort> value, Vector64<short> count)
Vector64<uint> ShiftLogicalRounded(Vector64<uint> value, Vector64<int> count)
Vector128<byte> ShiftLogicalRounded(Vector128<byte> value, Vector128<sbyte> count)
Vector128<short> ShiftLogicalRounded(Vector128<short> value, Vector128<short> count)
Vector128<int> ShiftLogicalRounded(Vector128<int> value, Vector128<int> count)
Vector128<long> ShiftLogicalRounded(Vector128<long> value, Vector128<long> count)
Vector128<sbyte> ShiftLogicalRounded(Vector128<sbyte> value, Vector128<sbyte> count)
Vector128<ushort> ShiftLogicalRounded(Vector128<ushort> value, Vector128<short> count)
Vector128<uint> ShiftLogicalRounded(Vector128<uint> value, Vector128<int> count)
Vector128<ulong> ShiftLogicalRounded(Vector128<ulong> value, Vector128<long> count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftlogicalrounded?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftLogicalRoundedTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[SByte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M16387_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M16387_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            urshl   v16.8b, v16.8b, v17.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M16387_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=ba44bffc) for method AdvSimdMethods:ShiftLogicalRoundedTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[SByte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 18. ShiftLogicalRoundedSaturate

`Vector64<byte> ShiftLogicalRoundedSaturate(Vector64<byte> value, Vector64<sbyte> count)`

Performs 'ShiftLogicalRoundedSaturate' operation.

```csharp
private Vector64<byte> ShiftLogicalRoundedSaturateTest(Vector64<byte> value, Vector64<sbyte> count)
{
  return AdvSimd.ShiftLogicalRoundedSaturate(value, count);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// count = <11, 12, 13, 14, 15, 16, 17, 18>
// Result = <255, 255, 255, 255, 255, 255, 255, 255>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> ShiftLogicalRoundedSaturate(Vector64<short> value, Vector64<short> count)
Vector64<int> ShiftLogicalRoundedSaturate(Vector64<int> value, Vector64<int> count)
Vector64<sbyte> ShiftLogicalRoundedSaturate(Vector64<sbyte> value, Vector64<sbyte> count)
Vector64<ushort> ShiftLogicalRoundedSaturate(Vector64<ushort> value, Vector64<short> count)
Vector64<uint> ShiftLogicalRoundedSaturate(Vector64<uint> value, Vector64<int> count)
Vector128<byte> ShiftLogicalRoundedSaturate(Vector128<byte> value, Vector128<sbyte> count)
Vector128<short> ShiftLogicalRoundedSaturate(Vector128<short> value, Vector128<short> count)
Vector128<int> ShiftLogicalRoundedSaturate(Vector128<int> value, Vector128<int> count)
Vector128<long> ShiftLogicalRoundedSaturate(Vector128<long> value, Vector128<long> count)
Vector128<sbyte> ShiftLogicalRoundedSaturate(Vector128<sbyte> value, Vector128<sbyte> count)
Vector128<ushort> ShiftLogicalRoundedSaturate(Vector128<ushort> value, Vector128<short> count)
Vector128<uint> ShiftLogicalRoundedSaturate(Vector128<uint> value, Vector128<int> count)
Vector128<ulong> ShiftLogicalRoundedSaturate(Vector128<ulong> value, Vector128<long> count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftlogicalroundedsaturate?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftLogicalRoundedSaturateTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[SByte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M16754_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M16754_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            uqrshl  v16.8b, v16.8b, v17.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M16754_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=a55cbe8d) for method AdvSimdMethods:ShiftLogicalRoundedSaturateTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[SByte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 19. ShiftLogicalRoundedSaturateScalar

`Vector64<long> ShiftLogicalRoundedSaturateScalar(Vector64<long> value, Vector64<long> count)`

Performs 'ShiftLogicalRoundedSaturateScalar' operation.

```csharp
private Vector64<long> ShiftLogicalRoundedSaturateScalarTest(Vector64<long> value, Vector64<long> count)
{
  return AdvSimd.ShiftLogicalRoundedSaturateScalar(value, count);
}
// value = <11>
// count = <11>
// Result = <22528>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<ulong> ShiftLogicalRoundedSaturateScalar(Vector64<ulong> value, Vector64<long> count)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<byte> ShiftLogicalRoundedSaturateScalar(Vector64<byte> value, Vector64<sbyte> count)
Vector64<short> ShiftLogicalRoundedSaturateScalar(Vector64<short> value, Vector64<short> count)
Vector64<int> ShiftLogicalRoundedSaturateScalar(Vector64<int> value, Vector64<int> count)
Vector64<sbyte> ShiftLogicalRoundedSaturateScalar(Vector64<sbyte> value, Vector64<sbyte> count)
Vector64<ushort> ShiftLogicalRoundedSaturateScalar(Vector64<ushort> value, Vector64<short> count)
Vector64<uint> ShiftLogicalRoundedSaturateScalar(Vector64<uint> value, Vector64<int> count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftlogicalroundedsaturatescalar?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.shiftlogicalroundedsaturatescalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftLogicalRoundedSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64]):System.Runtime.Intrinsics.Vector64`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M17268_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M17268_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            uqrshl  d16, d16, d17
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M17268_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=d5f7bc8b) for method AdvSimdMethods:ShiftLogicalRoundedSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64]):System.Runtime.Intrinsics.Vector64`1[Int64]
; ============================================================


```
------------------------------------------------

### 20. ShiftLogicalRoundedScalar

`Vector64<long> ShiftLogicalRoundedScalar(Vector64<long> value, Vector64<long> count)`

Performs 'ShiftLogicalRoundedScalar' operation.

```csharp
private Vector64<long> ShiftLogicalRoundedScalarTest(Vector64<long> value, Vector64<long> count)
{
  return AdvSimd.ShiftLogicalRoundedScalar(value, count);
}
// value = <11>
// count = <11>
// Result = <22528>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<ulong> ShiftLogicalRoundedScalar(Vector64<ulong> value, Vector64<long> count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftlogicalroundedscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftLogicalRoundedScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64]):System.Runtime.Intrinsics.Vector64`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M12677_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M12677_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            urshl   d16, d16, d17
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M12677_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=c599ce7a) for method AdvSimdMethods:ShiftLogicalRoundedScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64]):System.Runtime.Intrinsics.Vector64`1[Int64]
; ============================================================


```
------------------------------------------------

### 21. ShiftLogicalSaturate

`Vector64<byte> ShiftLogicalSaturate(Vector64<byte> value, Vector64<sbyte> count)`

Performs 'ShiftLogicalSaturate' operation.

```csharp
private Vector64<byte> ShiftLogicalSaturateTest(Vector64<byte> value, Vector64<sbyte> count)
{
  return AdvSimd.ShiftLogicalSaturate(value, count);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// count = <11, 12, 13, 14, 15, 16, 17, 18>
// Result = <255, 255, 255, 255, 255, 255, 255, 255>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> ShiftLogicalSaturate(Vector64<short> value, Vector64<short> count)
Vector64<int> ShiftLogicalSaturate(Vector64<int> value, Vector64<int> count)
Vector64<sbyte> ShiftLogicalSaturate(Vector64<sbyte> value, Vector64<sbyte> count)
Vector64<ushort> ShiftLogicalSaturate(Vector64<ushort> value, Vector64<short> count)
Vector64<uint> ShiftLogicalSaturate(Vector64<uint> value, Vector64<int> count)
Vector128<byte> ShiftLogicalSaturate(Vector128<byte> value, Vector128<sbyte> count)
Vector128<short> ShiftLogicalSaturate(Vector128<short> value, Vector128<short> count)
Vector128<int> ShiftLogicalSaturate(Vector128<int> value, Vector128<int> count)
Vector128<long> ShiftLogicalSaturate(Vector128<long> value, Vector128<long> count)
Vector128<sbyte> ShiftLogicalSaturate(Vector128<sbyte> value, Vector128<sbyte> count)
Vector128<ushort> ShiftLogicalSaturate(Vector128<ushort> value, Vector128<short> count)
Vector128<uint> ShiftLogicalSaturate(Vector128<uint> value, Vector128<int> count)
Vector128<ulong> ShiftLogicalSaturate(Vector128<ulong> value, Vector128<long> count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftlogicalsaturate?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftLogicalSaturateTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[SByte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M7441_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M7441_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            uqshl   v16.8b, v16.8b, v17.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M7441_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=475fe2ee) for method AdvSimdMethods:ShiftLogicalSaturateTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[SByte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 22. ShiftLogicalSaturateScalar

`Vector64<long> ShiftLogicalSaturateScalar(Vector64<long> value, Vector64<long> count)`

Performs 'ShiftLogicalSaturateScalar' operation.

```csharp
private Vector64<long> ShiftLogicalSaturateScalarTest(Vector64<long> value, Vector64<long> count)
{
  return AdvSimd.ShiftLogicalSaturateScalar(value, count);
}
// value = <11>
// count = <11>
// Result = <22528>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<ulong> ShiftLogicalSaturateScalar(Vector64<ulong> value, Vector64<long> count)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<byte> ShiftLogicalSaturateScalar(Vector64<byte> value, Vector64<sbyte> count)
Vector64<short> ShiftLogicalSaturateScalar(Vector64<short> value, Vector64<short> count)
Vector64<int> ShiftLogicalSaturateScalar(Vector64<int> value, Vector64<int> count)
Vector64<sbyte> ShiftLogicalSaturateScalar(Vector64<sbyte> value, Vector64<sbyte> count)
Vector64<ushort> ShiftLogicalSaturateScalar(Vector64<ushort> value, Vector64<short> count)
Vector64<uint> ShiftLogicalSaturateScalar(Vector64<uint> value, Vector64<int> count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftlogicalsaturatescalar?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.shiftlogicalsaturatescalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftLogicalSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64]):System.Runtime.Intrinsics.Vector64`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M40855_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M40855_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            uqshl   d16, d16, d17
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M40855_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=e7ec6068) for method AdvSimdMethods:ShiftLogicalSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64]):System.Runtime.Intrinsics.Vector64`1[Int64]
; ============================================================


```
------------------------------------------------

### 23. ShiftLogicalScalar

`Vector64<long> ShiftLogicalScalar(Vector64<long> value, Vector64<long> count)`

Performs 'ShiftLogicalScalar' operation.

```csharp
private Vector64<long> ShiftLogicalScalarTest(Vector64<long> value, Vector64<long> count)
{
  return AdvSimd.ShiftLogicalScalar(value, count);
}
// value = <11>
// count = <11>
// Result = <22528>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<ulong> ShiftLogicalScalar(Vector64<ulong> value, Vector64<long> count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftlogicalscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftLogicalScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64]):System.Runtime.Intrinsics.Vector64`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M46694_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M46694_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            ushl    d16, d16, d17
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M46694_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=1ce74999) for method AdvSimdMethods:ShiftLogicalScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64]):System.Runtime.Intrinsics.Vector64`1[Int64]
; ============================================================


```
------------------------------------------------

### 24. ShiftRightAndInsert

`Vector64<byte> ShiftRightAndInsert(Vector64<byte> left, Vector64<byte> right, byte shift)`

Performs 'ShiftRightAndInsert' operation.

```csharp
private Vector64<byte> ShiftRightAndInsertTest(Vector64<byte> left, Vector64<byte> right, byte shift)
{
  return AdvSimd.ShiftRightAndInsert(left, right, shift);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// shift = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> ShiftRightAndInsert(Vector64<short> left, Vector64<short> right, byte shift)
Vector64<int> ShiftRightAndInsert(Vector64<int> left, Vector64<int> right, byte shift)
Vector64<sbyte> ShiftRightAndInsert(Vector64<sbyte> left, Vector64<sbyte> right, byte shift)
Vector64<ushort> ShiftRightAndInsert(Vector64<ushort> left, Vector64<ushort> right, byte shift)
Vector64<uint> ShiftRightAndInsert(Vector64<uint> left, Vector64<uint> right, byte shift)
Vector128<byte> ShiftRightAndInsert(Vector128<byte> left, Vector128<byte> right, byte shift)
Vector128<short> ShiftRightAndInsert(Vector128<short> left, Vector128<short> right, byte shift)
Vector128<int> ShiftRightAndInsert(Vector128<int> left, Vector128<int> right, byte shift)
Vector128<long> ShiftRightAndInsert(Vector128<long> left, Vector128<long> right, byte shift)
Vector128<sbyte> ShiftRightAndInsert(Vector128<sbyte> left, Vector128<sbyte> right, byte shift)
Vector128<ushort> ShiftRightAndInsert(Vector128<ushort> left, Vector128<ushort> right, byte shift)
Vector128<uint> ShiftRightAndInsert(Vector128<uint> left, Vector128<uint> right, byte shift)
Vector128<ulong> ShiftRightAndInsert(Vector128<ulong> left, Vector128<ulong> right, byte shift)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightandinsert?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftRightAndInsertTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M53631_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M53631_IG02:
            ldr     d0, [fp,#24]
            ldr     d1, [fp,#16]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightAndInsert(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
						;; bbWeight=1    PerfScore 5.50
G_M53631_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=19f42e80) for method AdvSimdMethods:ShiftRightAndInsertTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 25. ShiftRightAndInsertScalar

`Vector64<long> ShiftRightAndInsertScalar(Vector64<long> left, Vector64<long> right, byte shift)`

Performs 'ShiftRightAndInsertScalar' operation.

```csharp
private Vector64<long> ShiftRightAndInsertScalarTest(Vector64<long> left, Vector64<long> right, byte shift)
{
  return AdvSimd.ShiftRightAndInsertScalar(left, right, shift);
}
// left = <11>
// right = <11>
// shift = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<ulong> ShiftRightAndInsertScalar(Vector64<ulong> left, Vector64<ulong> right, byte shift)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightandinsertscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftRightAndInsertScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M29418_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M29418_IG02:
            ldr     d0, [fp,#24]
            ldr     d1, [fp,#16]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightAndInsertScalar(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
						;; bbWeight=1    PerfScore 5.50
G_M29418_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=f19f8d15) for method AdvSimdMethods:ShiftRightAndInsertScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
; ============================================================


```
------------------------------------------------

### 26. ShiftRightArithmetic

`Vector64<short> ShiftRightArithmetic(Vector64<short> value, byte count)`

Performs 'ShiftRightArithmetic' operation.

```csharp
private Vector64<short> ShiftRightArithmeticTest(Vector64<short> value, byte count)
{
  return AdvSimd.ShiftRightArithmetic(value, count);
}
// value = <11, 12, 13, 14>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<int> ShiftRightArithmetic(Vector64<int> value, byte count)
Vector64<sbyte> ShiftRightArithmetic(Vector64<sbyte> value, byte count)
Vector128<short> ShiftRightArithmetic(Vector128<short> value, byte count)
Vector128<int> ShiftRightArithmetic(Vector128<int> value, byte count)
Vector128<long> ShiftRightArithmetic(Vector128<long> value, byte count)
Vector128<sbyte> ShiftRightArithmetic(Vector128<sbyte> value, byte count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightarithmetic?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftRightArithmeticTest(System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M23266_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M23266_IG02:
            ldr     d0, [fp,#24]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightArithmetic(System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
						;; bbWeight=1    PerfScore 3.50
G_M23266_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=851aa51d) for method AdvSimdMethods:ShiftRightArithmeticTest(System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 27. ShiftRightArithmeticAdd

`Vector64<short> ShiftRightArithmeticAdd(Vector64<short> addend, Vector64<short> value, byte count)`

Performs 'ShiftRightArithmeticAdd' operation.

```csharp
private Vector64<short> ShiftRightArithmeticAddTest(Vector64<short> addend, Vector64<short> value, byte count)
{
  return AdvSimd.ShiftRightArithmeticAdd(addend, value, count);
}
// addend = <11, 12, 13, 14>
// value = <21, 22, 23, 24>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<int> ShiftRightArithmeticAdd(Vector64<int> addend, Vector64<int> value, byte count)
Vector64<sbyte> ShiftRightArithmeticAdd(Vector64<sbyte> addend, Vector64<sbyte> value, byte count)
Vector128<short> ShiftRightArithmeticAdd(Vector128<short> addend, Vector128<short> value, byte count)
Vector128<int> ShiftRightArithmeticAdd(Vector128<int> addend, Vector128<int> value, byte count)
Vector128<long> ShiftRightArithmeticAdd(Vector128<long> addend, Vector128<long> value, byte count)
Vector128<sbyte> ShiftRightArithmeticAdd(Vector128<sbyte> addend, Vector128<sbyte> value, byte count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightarithmeticadd?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftRightArithmeticAddTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M26636_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M26636_IG02:
            ldr     d0, [fp,#24]
            ldr     d1, [fp,#16]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightArithmeticAdd(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
						;; bbWeight=1    PerfScore 5.50
G_M26636_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=981d97f3) for method AdvSimdMethods:ShiftRightArithmeticAddTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 28. ShiftRightArithmeticAddScalar

`Vector64<long> ShiftRightArithmeticAddScalar(Vector64<long> addend, Vector64<long> value, byte count)`

Performs 'ShiftRightArithmeticAddScalar' operation.

```csharp
private Vector64<long> ShiftRightArithmeticAddScalarTest(Vector64<long> addend, Vector64<long> value, byte count)
{
  return AdvSimd.ShiftRightArithmeticAddScalar(addend, value, count);
}
// addend = <11>
// value = <11>
// count = 0
// Result = TODO

```



See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightarithmeticaddscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftRightArithmeticAddScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M60167_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M60167_IG02:
            ldr     d0, [fp,#24]
            ldr     d1, [fp,#16]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightArithmeticAddScalar(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
						;; bbWeight=1    PerfScore 5.50
G_M60167_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=532a14f8) for method AdvSimdMethods:ShiftRightArithmeticAddScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
; ============================================================


```
------------------------------------------------

### 29. ShiftRightArithmeticNarrowingSaturateLower

`Vector64<short> ShiftRightArithmeticNarrowingSaturateLower(Vector128<int> value, byte count)`

Performs 'ShiftRightArithmeticNarrowingSaturateLower' operation.

```csharp
private Vector64<short> ShiftRightArithmeticNarrowingSaturateLowerTest(Vector128<int> value, byte count)
{
  return AdvSimd.ShiftRightArithmeticNarrowingSaturateLower(value, count);
}
// value = <11, 12, 13, 14>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<int> ShiftRightArithmeticNarrowingSaturateLower(Vector128<long> value, byte count)
Vector64<sbyte> ShiftRightArithmeticNarrowingSaturateLower(Vector128<short> value, byte count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightarithmeticnarrowingsaturatelower?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftRightArithmeticNarrowingSaturateLowerTest(System.Runtime.Intrinsics.Vector128`1[Int32],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T01] (  2,  4   )  simd16  ->   d0         HFA(simd16)  "Inlining Arg"
;
; Lcl frame size = 16

G_M5432_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     q0, [fp,#16]
						;; bbWeight=1    PerfScore 2.50
G_M5432_IG02:
            ldr     q0, [fp,#16]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightArithmeticNarrowingSaturateLower(System.Runtime.Intrinsics.Vector128`1[Int32],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
						;; bbWeight=1    PerfScore 3.50
G_M5432_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=2129eac7) for method AdvSimdMethods:ShiftRightArithmeticNarrowingSaturateLowerTest(System.Runtime.Intrinsics.Vector128`1[Int32],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 30. ShiftRightArithmeticNarrowingSaturateUnsignedLower

`Vector64<byte> ShiftRightArithmeticNarrowingSaturateUnsignedLower(Vector128<short> value, byte count)`

Performs 'ShiftRightArithmeticNarrowingSaturateUnsignedLower' operation.

```csharp
private Vector64<byte> ShiftRightArithmeticNarrowingSaturateUnsignedLowerTest(Vector128<short> value, byte count)
{
  return AdvSimd.ShiftRightArithmeticNarrowingSaturateUnsignedLower(value, count);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<ushort> ShiftRightArithmeticNarrowingSaturateUnsignedLower(Vector128<int> value, byte count)
Vector64<uint> ShiftRightArithmeticNarrowingSaturateUnsignedLower(Vector128<long> value, byte count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightarithmeticnarrowingsaturateunsignedlower?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftRightArithmeticNarrowingSaturateUnsignedLowerTest(System.Runtime.Intrinsics.Vector128`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T01] (  2,  4   )  simd16  ->   d0         HFA(simd16)  "Inlining Arg"
;
; Lcl frame size = 16

G_M27529_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     q0, [fp,#16]
						;; bbWeight=1    PerfScore 2.50
G_M27529_IG02:
            ldr     q0, [fp,#16]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightArithmeticNarrowingSaturateUnsignedLower(System.Runtime.Intrinsics.Vector128`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
						;; bbWeight=1    PerfScore 3.50
G_M27529_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=ce1f9476) for method AdvSimdMethods:ShiftRightArithmeticNarrowingSaturateUnsignedLowerTest(System.Runtime.Intrinsics.Vector128`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 31. ShiftRightArithmeticNarrowingSaturateUnsignedUpper

`Vector128<byte> ShiftRightArithmeticNarrowingSaturateUnsignedUpper(Vector64<byte> lower, Vector128<short> value, byte count)`

Performs 'ShiftRightArithmeticNarrowingSaturateUnsignedUpper' operation.

```csharp
private Vector128<byte> ShiftRightArithmeticNarrowingSaturateUnsignedUpperTest(Vector64<byte> lower, Vector128<short> value, byte count)
{
  return AdvSimd.ShiftRightArithmeticNarrowingSaturateUnsignedUpper(lower, value, count);
}
// lower = <11, 12, 13, 14, 15, 16, 17, 18>
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<ushort> ShiftRightArithmeticNarrowingSaturateUnsignedUpper(Vector64<ushort> lower, Vector128<int> value, byte count)
Vector128<uint> ShiftRightArithmeticNarrowingSaturateUnsignedUpper(Vector64<uint> lower, Vector128<long> value, byte count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightarithmeticnarrowingsaturateunsignedupper?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftRightArithmeticNarrowingSaturateUnsignedUpperTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T02] (  2,  4   )  simd16  ->   d1         HFA(simd16)  "Inlining Arg"
;
; Lcl frame size = 32

G_M1312_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     q1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M1312_IG02:
            ldr     d0, [fp,#40]
            ldr     q1, [fp,#16]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightArithmeticNarrowingSaturateUnsignedUpper(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Byte]
						;; bbWeight=1    PerfScore 5.50
G_M1312_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=6456fadf) for method AdvSimdMethods:ShiftRightArithmeticNarrowingSaturateUnsignedUpperTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Byte]
; ============================================================


```
------------------------------------------------

### 32. ShiftRightArithmeticNarrowingSaturateUpper

`Vector128<short> ShiftRightArithmeticNarrowingSaturateUpper(Vector64<short> lower, Vector128<int> value, byte count)`

Performs 'ShiftRightArithmeticNarrowingSaturateUpper' operation.

```csharp
private Vector128<short> ShiftRightArithmeticNarrowingSaturateUpperTest(Vector64<short> lower, Vector128<int> value, byte count)
{
  return AdvSimd.ShiftRightArithmeticNarrowingSaturateUpper(lower, value, count);
}
// lower = <11, 12, 13, 14>
// value = <11, 12, 13, 14>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<int> ShiftRightArithmeticNarrowingSaturateUpper(Vector64<int> lower, Vector128<long> value, byte count)
Vector128<sbyte> ShiftRightArithmeticNarrowingSaturateUpper(Vector64<sbyte> lower, Vector128<short> value, byte count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightarithmeticnarrowingsaturateupper?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftRightArithmeticNarrowingSaturateUpperTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector128`1[Int32],ubyte):System.Runtime.Intrinsics.Vector128`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T02] (  2,  4   )  simd16  ->   d1         HFA(simd16)  "Inlining Arg"
;
; Lcl frame size = 32

G_M46415_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     q1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M46415_IG02:
            ldr     d0, [fp,#40]
            ldr     q1, [fp,#16]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightArithmeticNarrowingSaturateUpper(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector128`1[Int32],ubyte):System.Runtime.Intrinsics.Vector128`1[Int16]
						;; bbWeight=1    PerfScore 5.50
G_M46415_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=e8ad4ab0) for method AdvSimdMethods:ShiftRightArithmeticNarrowingSaturateUpperTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector128`1[Int32],ubyte):System.Runtime.Intrinsics.Vector128`1[Int16]
; ============================================================


```
------------------------------------------------

### 33. ShiftRightArithmeticRounded

`Vector64<short> ShiftRightArithmeticRounded(Vector64<short> value, byte count)`

Performs 'ShiftRightArithmeticRounded' operation.

```csharp
private Vector64<short> ShiftRightArithmeticRoundedTest(Vector64<short> value, byte count)
{
  return AdvSimd.ShiftRightArithmeticRounded(value, count);
}
// value = <11, 12, 13, 14>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<int> ShiftRightArithmeticRounded(Vector64<int> value, byte count)
Vector64<sbyte> ShiftRightArithmeticRounded(Vector64<sbyte> value, byte count)
Vector128<short> ShiftRightArithmeticRounded(Vector128<short> value, byte count)
Vector128<int> ShiftRightArithmeticRounded(Vector128<int> value, byte count)
Vector128<long> ShiftRightArithmeticRounded(Vector128<long> value, byte count)
Vector128<sbyte> ShiftRightArithmeticRounded(Vector128<sbyte> value, byte count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightarithmeticrounded?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftRightArithmeticRoundedTest(System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M4321_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M4321_IG02:
            ldr     d0, [fp,#24]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightArithmeticRounded(System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
						;; bbWeight=1    PerfScore 3.50
G_M4321_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=15beef1e) for method AdvSimdMethods:ShiftRightArithmeticRoundedTest(System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 34. ShiftRightArithmeticRoundedAdd

`Vector64<short> ShiftRightArithmeticRoundedAdd(Vector64<short> addend, Vector64<short> value, byte count)`

Performs 'ShiftRightArithmeticRoundedAdd' operation.

```csharp
private Vector64<short> ShiftRightArithmeticRoundedAddTest(Vector64<short> addend, Vector64<short> value, byte count)
{
  return AdvSimd.ShiftRightArithmeticRoundedAdd(addend, value, count);
}
// addend = <11, 12, 13, 14>
// value = <21, 22, 23, 24>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<int> ShiftRightArithmeticRoundedAdd(Vector64<int> addend, Vector64<int> value, byte count)
Vector64<sbyte> ShiftRightArithmeticRoundedAdd(Vector64<sbyte> addend, Vector64<sbyte> value, byte count)
Vector128<short> ShiftRightArithmeticRoundedAdd(Vector128<short> addend, Vector128<short> value, byte count)
Vector128<int> ShiftRightArithmeticRoundedAdd(Vector128<int> addend, Vector128<int> value, byte count)
Vector128<long> ShiftRightArithmeticRoundedAdd(Vector128<long> addend, Vector128<long> value, byte count)
Vector128<sbyte> ShiftRightArithmeticRoundedAdd(Vector128<sbyte> addend, Vector128<sbyte> value, byte count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightarithmeticroundedadd?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftRightArithmeticRoundedAddTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M4591_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M4591_IG02:
            ldr     d0, [fp,#24]
            ldr     d1, [fp,#16]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightArithmeticRoundedAdd(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
						;; bbWeight=1    PerfScore 5.50
G_M4591_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=6aa6ee10) for method AdvSimdMethods:ShiftRightArithmeticRoundedAddTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 35. ShiftRightArithmeticRoundedAddScalar

`Vector64<long> ShiftRightArithmeticRoundedAddScalar(Vector64<long> addend, Vector64<long> value, byte count)`

Performs 'ShiftRightArithmeticRoundedAddScalar' operation.

```csharp
private Vector64<long> ShiftRightArithmeticRoundedAddScalarTest(Vector64<long> addend, Vector64<long> value, byte count)
{
  return AdvSimd.ShiftRightArithmeticRoundedAddScalar(addend, value, count);
}
// addend = <11>
// value = <11>
// count = 0
// Result = TODO

```



See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightarithmeticroundedaddscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftRightArithmeticRoundedAddScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M24164_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M24164_IG02:
            ldr     d0, [fp,#24]
            ldr     d1, [fp,#16]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightArithmeticRoundedAddScalar(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
						;; bbWeight=1    PerfScore 5.50
G_M24164_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=4f01a19b) for method AdvSimdMethods:ShiftRightArithmeticRoundedAddScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
; ============================================================


```
------------------------------------------------

### 36. ShiftRightArithmeticRoundedNarrowingSaturateLower

`Vector64<short> ShiftRightArithmeticRoundedNarrowingSaturateLower(Vector128<int> value, byte count)`

Performs 'ShiftRightArithmeticRoundedNarrowingSaturateLower' operation.

```csharp
private Vector64<short> ShiftRightArithmeticRoundedNarrowingSaturateLowerTest(Vector128<int> value, byte count)
{
  return AdvSimd.ShiftRightArithmeticRoundedNarrowingSaturateLower(value, count);
}
// value = <11, 12, 13, 14>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<int> ShiftRightArithmeticRoundedNarrowingSaturateLower(Vector128<long> value, byte count)
Vector64<sbyte> ShiftRightArithmeticRoundedNarrowingSaturateLower(Vector128<short> value, byte count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightarithmeticroundednarrowingsaturatelower?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftRightArithmeticRoundedNarrowingSaturateLowerTest(System.Runtime.Intrinsics.Vector128`1[Int32],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T01] (  2,  4   )  simd16  ->   d0         HFA(simd16)  "Inlining Arg"
;
; Lcl frame size = 16

G_M48795_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     q0, [fp,#16]
						;; bbWeight=1    PerfScore 2.50
G_M48795_IG02:
            ldr     q0, [fp,#16]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightArithmeticRoundedNarrowingSaturateLower(System.Runtime.Intrinsics.Vector128`1[Int32],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
						;; bbWeight=1    PerfScore 3.50
G_M48795_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=e4264164) for method AdvSimdMethods:ShiftRightArithmeticRoundedNarrowingSaturateLowerTest(System.Runtime.Intrinsics.Vector128`1[Int32],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 37. ShiftRightArithmeticRoundedNarrowingSaturateUnsignedLower

`Vector64<byte> ShiftRightArithmeticRoundedNarrowingSaturateUnsignedLower(Vector128<short> value, byte count)`

Performs 'ShiftRightArithmeticRoundedNarrowingSaturateUnsignedLower' operation.

```csharp
private Vector64<byte> ShiftRightArithmeticRoundedNarrowingSaturateUnsignedLowerTest(Vector128<short> value, byte count)
{
  return AdvSimd.ShiftRightArithmeticRoundedNarrowingSaturateUnsignedLower(value, count);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<ushort> ShiftRightArithmeticRoundedNarrowingSaturateUnsignedLower(Vector128<int> value, byte count)
Vector64<uint> ShiftRightArithmeticRoundedNarrowingSaturateUnsignedLower(Vector128<long> value, byte count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightarithmeticroundednarrowingsaturateunsignedlower?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftRightArithmeticRoundedNarrowingSaturateUnsignedLowerTest(System.Runtime.Intrinsics.Vector128`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T01] (  2,  4   )  simd16  ->   d0         HFA(simd16)  "Inlining Arg"
;
; Lcl frame size = 16

G_M41034_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     q0, [fp,#16]
						;; bbWeight=1    PerfScore 2.50
G_M41034_IG02:
            ldr     q0, [fp,#16]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightArithmeticRoundedNarrowingSaturateUnsignedLower(System.Runtime.Intrinsics.Vector128`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
						;; bbWeight=1    PerfScore 3.50
G_M41034_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=120c5fb5) for method AdvSimdMethods:ShiftRightArithmeticRoundedNarrowingSaturateUnsignedLowerTest(System.Runtime.Intrinsics.Vector128`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 38. ShiftRightArithmeticRoundedNarrowingSaturateUnsignedUpper

`Vector128<byte> ShiftRightArithmeticRoundedNarrowingSaturateUnsignedUpper(Vector64<byte> lower, Vector128<short> value, byte count)`

Performs 'ShiftRightArithmeticRoundedNarrowingSaturateUnsignedUpper' operation.

```csharp
private Vector128<byte> ShiftRightArithmeticRoundedNarrowingSaturateUnsignedUpperTest(Vector64<byte> lower, Vector128<short> value, byte count)
{
  return AdvSimd.ShiftRightArithmeticRoundedNarrowingSaturateUnsignedUpper(lower, value, count);
}
// lower = <11, 12, 13, 14, 15, 16, 17, 18>
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<ushort> ShiftRightArithmeticRoundedNarrowingSaturateUnsignedUpper(Vector64<ushort> lower, Vector128<int> value, byte count)
Vector128<uint> ShiftRightArithmeticRoundedNarrowingSaturateUnsignedUpper(Vector64<uint> lower, Vector128<long> value, byte count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightarithmeticroundednarrowingsaturateunsignedupper?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftRightArithmeticRoundedNarrowingSaturateUnsignedUpperTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T02] (  2,  4   )  simd16  ->   d1         HFA(simd16)  "Inlining Arg"
;
; Lcl frame size = 32

G_M30179_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     q1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M30179_IG02:
            ldr     d0, [fp,#40]
            ldr     q1, [fp,#16]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightArithmeticRoundedNarrowingSaturateUnsignedUpper(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Byte]
						;; bbWeight=1    PerfScore 5.50
G_M30179_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=2b028a1c) for method AdvSimdMethods:ShiftRightArithmeticRoundedNarrowingSaturateUnsignedUpperTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[Int16],ubyte):System.Runtime.Intrinsics.Vector128`1[Byte]
; ============================================================


```
------------------------------------------------

### 39. ShiftRightArithmeticRoundedNarrowingSaturateUpper

`Vector128<short> ShiftRightArithmeticRoundedNarrowingSaturateUpper(Vector64<short> lower, Vector128<int> value, byte count)`

Performs 'ShiftRightArithmeticRoundedNarrowingSaturateUpper' operation.

```csharp
private Vector128<short> ShiftRightArithmeticRoundedNarrowingSaturateUpperTest(Vector64<short> lower, Vector128<int> value, byte count)
{
  return AdvSimd.ShiftRightArithmeticRoundedNarrowingSaturateUpper(lower, value, count);
}
// lower = <11, 12, 13, 14>
// value = <11, 12, 13, 14>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<int> ShiftRightArithmeticRoundedNarrowingSaturateUpper(Vector64<int> lower, Vector128<long> value, byte count)
Vector128<sbyte> ShiftRightArithmeticRoundedNarrowingSaturateUpper(Vector64<sbyte> lower, Vector128<short> value, byte count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightarithmeticroundednarrowingsaturateupper?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftRightArithmeticRoundedNarrowingSaturateUpperTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector128`1[Int32],ubyte):System.Runtime.Intrinsics.Vector128`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T02] (  2,  4   )  simd16  ->   d1         HFA(simd16)  "Inlining Arg"
;
; Lcl frame size = 32

G_M41932_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     q1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M41932_IG02:
            ldr     d0, [fp,#40]
            ldr     q1, [fp,#16]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightArithmeticRoundedNarrowingSaturateUpper(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector128`1[Int32],ubyte):System.Runtime.Intrinsics.Vector128`1[Int16]
						;; bbWeight=1    PerfScore 5.50
G_M41932_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=d22b5c33) for method AdvSimdMethods:ShiftRightArithmeticRoundedNarrowingSaturateUpperTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector128`1[Int32],ubyte):System.Runtime.Intrinsics.Vector128`1[Int16]
; ============================================================


```
------------------------------------------------

### 40. ShiftRightArithmeticRoundedScalar

`Vector64<long> ShiftRightArithmeticRoundedScalar(Vector64<long> value, byte count)`

Performs 'ShiftRightArithmeticRoundedScalar' operation.

```csharp
private Vector64<long> ShiftRightArithmeticRoundedScalarTest(Vector64<long> value, byte count)
{
  return AdvSimd.ShiftRightArithmeticRoundedScalar(value, count);
}
// value = <11>
// count = 0
// Result = TODO

```



See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightarithmeticroundedscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftRightArithmeticRoundedScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M5903_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M5903_IG02:
            ldr     d0, [fp,#24]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightArithmeticRoundedScalar(System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
						;; bbWeight=1    PerfScore 3.50
G_M5903_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=1fd8e8f0) for method AdvSimdMethods:ShiftRightArithmeticRoundedScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
; ============================================================


```
------------------------------------------------

### 41. ShiftRightArithmeticScalar

`Vector64<long> ShiftRightArithmeticScalar(Vector64<long> value, byte count)`

Performs 'ShiftRightArithmeticScalar' operation.

```csharp
private Vector64<long> ShiftRightArithmeticScalarTest(Vector64<long> value, byte count)
{
  return AdvSimd.ShiftRightArithmeticScalar(value, count);
}
// value = <11>
// count = 0
// Result = TODO

```



See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightarithmeticscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftRightArithmeticScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M38156_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M38156_IG02:
            ldr     d0, [fp,#24]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightArithmeticScalar(System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
						;; bbWeight=1    PerfScore 3.50
G_M38156_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=10616af3) for method AdvSimdMethods:ShiftRightArithmeticScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
; ============================================================


```
------------------------------------------------

### 42. ShiftRightLogical

`Vector64<byte> ShiftRightLogical(Vector64<byte> value, byte count)`

Performs 'ShiftRightLogical' operation.

```csharp
private Vector64<byte> ShiftRightLogicalTest(Vector64<byte> value, byte count)
{
  return AdvSimd.ShiftRightLogical(value, count);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> ShiftRightLogical(Vector64<short> value, byte count)
Vector64<int> ShiftRightLogical(Vector64<int> value, byte count)
Vector64<sbyte> ShiftRightLogical(Vector64<sbyte> value, byte count)
Vector64<ushort> ShiftRightLogical(Vector64<ushort> value, byte count)
Vector64<uint> ShiftRightLogical(Vector64<uint> value, byte count)
Vector128<byte> ShiftRightLogical(Vector128<byte> value, byte count)
Vector128<short> ShiftRightLogical(Vector128<short> value, byte count)
Vector128<int> ShiftRightLogical(Vector128<int> value, byte count)
Vector128<long> ShiftRightLogical(Vector128<long> value, byte count)
Vector128<sbyte> ShiftRightLogical(Vector128<sbyte> value, byte count)
Vector128<ushort> ShiftRightLogical(Vector128<ushort> value, byte count)
Vector128<uint> ShiftRightLogical(Vector128<uint> value, byte count)
Vector128<ulong> ShiftRightLogical(Vector128<ulong> value, byte count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightlogical?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftRightLogicalTest(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M5713_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M5713_IG02:
            ldr     d0, [fp,#24]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightLogical(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
						;; bbWeight=1    PerfScore 3.50
G_M5713_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=dddbe9ae) for method AdvSimdMethods:ShiftRightLogicalTest(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 43. ShiftRightLogicalAdd

`Vector64<byte> ShiftRightLogicalAdd(Vector64<byte> addend, Vector64<byte> value, byte count)`

Performs 'ShiftRightLogicalAdd' operation.

```csharp
private Vector64<byte> ShiftRightLogicalAddTest(Vector64<byte> addend, Vector64<byte> value, byte count)
{
  return AdvSimd.ShiftRightLogicalAdd(addend, value, count);
}
// addend = <11, 12, 13, 14, 15, 16, 17, 18>
// value = <21, 22, 23, 24, 25, 26, 27, 28>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> ShiftRightLogicalAdd(Vector64<short> addend, Vector64<short> value, byte count)
Vector64<int> ShiftRightLogicalAdd(Vector64<int> addend, Vector64<int> value, byte count)
Vector64<sbyte> ShiftRightLogicalAdd(Vector64<sbyte> addend, Vector64<sbyte> value, byte count)
Vector64<ushort> ShiftRightLogicalAdd(Vector64<ushort> addend, Vector64<ushort> value, byte count)
Vector64<uint> ShiftRightLogicalAdd(Vector64<uint> addend, Vector64<uint> value, byte count)
Vector128<byte> ShiftRightLogicalAdd(Vector128<byte> addend, Vector128<byte> value, byte count)
Vector128<short> ShiftRightLogicalAdd(Vector128<short> addend, Vector128<short> value, byte count)
Vector128<int> ShiftRightLogicalAdd(Vector128<int> addend, Vector128<int> value, byte count)
Vector128<long> ShiftRightLogicalAdd(Vector128<long> addend, Vector128<long> value, byte count)
Vector128<sbyte> ShiftRightLogicalAdd(Vector128<sbyte> addend, Vector128<sbyte> value, byte count)
Vector128<ushort> ShiftRightLogicalAdd(Vector128<ushort> addend, Vector128<ushort> value, byte count)
Vector128<uint> ShiftRightLogicalAdd(Vector128<uint> addend, Vector128<uint> value, byte count)
Vector128<ulong> ShiftRightLogicalAdd(Vector128<ulong> addend, Vector128<ulong> value, byte count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightlogicaladd?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftRightLogicalAddTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M61281_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M61281_IG02:
            ldr     d0, [fp,#24]
            ldr     d1, [fp,#16]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightLogicalAdd(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
						;; bbWeight=1    PerfScore 5.50
G_M61281_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=4eb4109e) for method AdvSimdMethods:ShiftRightLogicalAddTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 44. ShiftRightLogicalAddScalar

`Vector64<long> ShiftRightLogicalAddScalar(Vector64<long> addend, Vector64<long> value, byte count)`

Performs 'ShiftRightLogicalAddScalar' operation.

```csharp
private Vector64<long> ShiftRightLogicalAddScalarTest(Vector64<long> addend, Vector64<long> value, byte count)
{
  return AdvSimd.ShiftRightLogicalAddScalar(addend, value, count);
}
// addend = <11>
// value = <11>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<ulong> ShiftRightLogicalAddScalar(Vector64<ulong> addend, Vector64<ulong> value, byte count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightlogicaladdscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftRightLogicalAddScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M23860_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M23860_IG02:
            ldr     d0, [fp,#24]
            ldr     d1, [fp,#16]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightLogicalAddScalar(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
						;; bbWeight=1    PerfScore 5.50
G_M23860_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=1c87a2cb) for method AdvSimdMethods:ShiftRightLogicalAddScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
; ============================================================


```
------------------------------------------------

### 45. ShiftRightLogicalNarrowingLower

`Vector64<byte> ShiftRightLogicalNarrowingLower(Vector128<ushort> value, byte count)`

Performs 'ShiftRightLogicalNarrowingLower' operation.

```csharp
private Vector64<byte> ShiftRightLogicalNarrowingLowerTest(Vector128<ushort> value, byte count)
{
  return AdvSimd.ShiftRightLogicalNarrowingLower(value, count);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> ShiftRightLogicalNarrowingLower(Vector128<int> value, byte count)
Vector64<int> ShiftRightLogicalNarrowingLower(Vector128<long> value, byte count)
Vector64<sbyte> ShiftRightLogicalNarrowingLower(Vector128<short> value, byte count)
Vector64<ushort> ShiftRightLogicalNarrowingLower(Vector128<uint> value, byte count)
Vector64<uint> ShiftRightLogicalNarrowingLower(Vector128<ulong> value, byte count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightlogicalnarrowinglower?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftRightLogicalNarrowingLowerTest(System.Runtime.Intrinsics.Vector128`1[UInt16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T01] (  2,  4   )  simd16  ->   d0         HFA(simd16)  "Inlining Arg"
;
; Lcl frame size = 16

G_M21911_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     q0, [fp,#16]
						;; bbWeight=1    PerfScore 2.50
G_M21911_IG02:
            ldr     q0, [fp,#16]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightLogicalNarrowingLower(System.Runtime.Intrinsics.Vector128`1[UInt16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
						;; bbWeight=1    PerfScore 3.50
G_M21911_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=da22aa68) for method AdvSimdMethods:ShiftRightLogicalNarrowingLowerTest(System.Runtime.Intrinsics.Vector128`1[UInt16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 46. ShiftRightLogicalNarrowingSaturateLower

`Vector64<byte> ShiftRightLogicalNarrowingSaturateLower(Vector128<ushort> value, byte count)`

Performs 'ShiftRightLogicalNarrowingSaturateLower' operation.

```csharp
private Vector64<byte> ShiftRightLogicalNarrowingSaturateLowerTest(Vector128<ushort> value, byte count)
{
  return AdvSimd.ShiftRightLogicalNarrowingSaturateLower(value, count);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> ShiftRightLogicalNarrowingSaturateLower(Vector128<int> value, byte count)
Vector64<int> ShiftRightLogicalNarrowingSaturateLower(Vector128<long> value, byte count)
Vector64<sbyte> ShiftRightLogicalNarrowingSaturateLower(Vector128<short> value, byte count)
Vector64<ushort> ShiftRightLogicalNarrowingSaturateLower(Vector128<uint> value, byte count)
Vector64<uint> ShiftRightLogicalNarrowingSaturateLower(Vector128<ulong> value, byte count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightlogicalnarrowingsaturatelower?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftRightLogicalNarrowingSaturateLowerTest(System.Runtime.Intrinsics.Vector128`1[UInt16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T01] (  2,  4   )  simd16  ->   d0         HFA(simd16)  "Inlining Arg"
;
; Lcl frame size = 16

G_M16550_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     q0, [fp,#16]
						;; bbWeight=1    PerfScore 2.50
G_M16550_IG02:
            ldr     q0, [fp,#16]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightLogicalNarrowingSaturateLower(System.Runtime.Intrinsics.Vector128`1[UInt16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
						;; bbWeight=1    PerfScore 3.50
G_M16550_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=fbf9bf59) for method AdvSimdMethods:ShiftRightLogicalNarrowingSaturateLowerTest(System.Runtime.Intrinsics.Vector128`1[UInt16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 47. ShiftRightLogicalNarrowingSaturateUpper

`Vector128<byte> ShiftRightLogicalNarrowingSaturateUpper(Vector64<byte> lower, Vector128<ushort> value, byte count)`

Performs 'ShiftRightLogicalNarrowingSaturateUpper' operation.

```csharp
private Vector128<byte> ShiftRightLogicalNarrowingSaturateUpperTest(Vector64<byte> lower, Vector128<ushort> value, byte count)
{
  return AdvSimd.ShiftRightLogicalNarrowingSaturateUpper(lower, value, count);
}
// lower = <11, 12, 13, 14, 15, 16, 17, 18>
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<short> ShiftRightLogicalNarrowingSaturateUpper(Vector64<short> lower, Vector128<int> value, byte count)
Vector128<int> ShiftRightLogicalNarrowingSaturateUpper(Vector64<int> lower, Vector128<long> value, byte count)
Vector128<sbyte> ShiftRightLogicalNarrowingSaturateUpper(Vector64<sbyte> lower, Vector128<short> value, byte count)
Vector128<ushort> ShiftRightLogicalNarrowingSaturateUpper(Vector64<ushort> lower, Vector128<uint> value, byte count)
Vector128<uint> ShiftRightLogicalNarrowingSaturateUpper(Vector64<uint> lower, Vector128<ulong> value, byte count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightlogicalnarrowingsaturateupper?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftRightLogicalNarrowingSaturateUpperTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[UInt16],ubyte):System.Runtime.Intrinsics.Vector128`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T02] (  2,  4   )  simd16  ->   d1         HFA(simd16)  "Inlining Arg"
;
; Lcl frame size = 32

G_M27951_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     q1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M27951_IG02:
            ldr     d0, [fp,#40]
            ldr     q1, [fp,#16]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightLogicalNarrowingSaturateUpper(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[UInt16],ubyte):System.Runtime.Intrinsics.Vector128`1[Byte]
						;; bbWeight=1    PerfScore 5.50
G_M27951_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=9e9e92d0) for method AdvSimdMethods:ShiftRightLogicalNarrowingSaturateUpperTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[UInt16],ubyte):System.Runtime.Intrinsics.Vector128`1[Byte]
; ============================================================


```
------------------------------------------------

### 48. ShiftRightLogicalNarrowingUpper

`Vector128<byte> ShiftRightLogicalNarrowingUpper(Vector64<byte> lower, Vector128<ushort> value, byte count)`

Performs 'ShiftRightLogicalNarrowingUpper' operation.

```csharp
private Vector128<byte> ShiftRightLogicalNarrowingUpperTest(Vector64<byte> lower, Vector128<ushort> value, byte count)
{
  return AdvSimd.ShiftRightLogicalNarrowingUpper(lower, value, count);
}
// lower = <11, 12, 13, 14, 15, 16, 17, 18>
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<short> ShiftRightLogicalNarrowingUpper(Vector64<short> lower, Vector128<int> value, byte count)
Vector128<int> ShiftRightLogicalNarrowingUpper(Vector64<int> lower, Vector128<long> value, byte count)
Vector128<sbyte> ShiftRightLogicalNarrowingUpper(Vector64<sbyte> lower, Vector128<short> value, byte count)
Vector128<ushort> ShiftRightLogicalNarrowingUpper(Vector64<ushort> lower, Vector128<uint> value, byte count)
Vector128<uint> ShiftRightLogicalNarrowingUpper(Vector64<uint> lower, Vector128<ulong> value, byte count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightlogicalnarrowingupper?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftRightLogicalNarrowingUpperTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[UInt16],ubyte):System.Runtime.Intrinsics.Vector128`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T02] (  2,  4   )  simd16  ->   d1         HFA(simd16)  "Inlining Arg"
;
; Lcl frame size = 32

G_M8862_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     q1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M8862_IG02:
            ldr     d0, [fp,#40]
            ldr     q1, [fp,#16]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightLogicalNarrowingUpper(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[UInt16],ubyte):System.Runtime.Intrinsics.Vector128`1[Byte]
						;; bbWeight=1    PerfScore 5.50
G_M8862_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=83a6dd61) for method AdvSimdMethods:ShiftRightLogicalNarrowingUpperTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[UInt16],ubyte):System.Runtime.Intrinsics.Vector128`1[Byte]
; ============================================================


```
------------------------------------------------

### 49. ShiftRightLogicalRounded

`Vector64<byte> ShiftRightLogicalRounded(Vector64<byte> value, byte count)`

Performs 'ShiftRightLogicalRounded' operation.

```csharp
private Vector64<byte> ShiftRightLogicalRoundedTest(Vector64<byte> value, byte count)
{
  return AdvSimd.ShiftRightLogicalRounded(value, count);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> ShiftRightLogicalRounded(Vector64<short> value, byte count)
Vector64<int> ShiftRightLogicalRounded(Vector64<int> value, byte count)
Vector64<sbyte> ShiftRightLogicalRounded(Vector64<sbyte> value, byte count)
Vector64<ushort> ShiftRightLogicalRounded(Vector64<ushort> value, byte count)
Vector64<uint> ShiftRightLogicalRounded(Vector64<uint> value, byte count)
Vector128<byte> ShiftRightLogicalRounded(Vector128<byte> value, byte count)
Vector128<short> ShiftRightLogicalRounded(Vector128<short> value, byte count)
Vector128<int> ShiftRightLogicalRounded(Vector128<int> value, byte count)
Vector128<long> ShiftRightLogicalRounded(Vector128<long> value, byte count)
Vector128<sbyte> ShiftRightLogicalRounded(Vector128<sbyte> value, byte count)
Vector128<ushort> ShiftRightLogicalRounded(Vector128<ushort> value, byte count)
Vector128<uint> ShiftRightLogicalRounded(Vector128<uint> value, byte count)
Vector128<ulong> ShiftRightLogicalRounded(Vector128<ulong> value, byte count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightlogicalrounded?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftRightLogicalRoundedTest(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M27762_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M27762_IG02:
            ldr     d0, [fp,#24]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightLogicalRounded(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
						;; bbWeight=1    PerfScore 3.50
G_M27762_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=da31938d) for method AdvSimdMethods:ShiftRightLogicalRoundedTest(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 50. ShiftRightLogicalRoundedAdd

`Vector64<byte> ShiftRightLogicalRoundedAdd(Vector64<byte> addend, Vector64<byte> value, byte count)`

Performs 'ShiftRightLogicalRoundedAdd' operation.

```csharp
private Vector64<byte> ShiftRightLogicalRoundedAddTest(Vector64<byte> addend, Vector64<byte> value, byte count)
{
  return AdvSimd.ShiftRightLogicalRoundedAdd(addend, value, count);
}
// addend = <11, 12, 13, 14, 15, 16, 17, 18>
// value = <21, 22, 23, 24, 25, 26, 27, 28>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> ShiftRightLogicalRoundedAdd(Vector64<short> addend, Vector64<short> value, byte count)
Vector64<int> ShiftRightLogicalRoundedAdd(Vector64<int> addend, Vector64<int> value, byte count)
Vector64<sbyte> ShiftRightLogicalRoundedAdd(Vector64<sbyte> addend, Vector64<sbyte> value, byte count)
Vector64<ushort> ShiftRightLogicalRoundedAdd(Vector64<ushort> addend, Vector64<ushort> value, byte count)
Vector64<uint> ShiftRightLogicalRoundedAdd(Vector64<uint> addend, Vector64<uint> value, byte count)
Vector128<byte> ShiftRightLogicalRoundedAdd(Vector128<byte> addend, Vector128<byte> value, byte count)
Vector128<short> ShiftRightLogicalRoundedAdd(Vector128<short> addend, Vector128<short> value, byte count)
Vector128<int> ShiftRightLogicalRoundedAdd(Vector128<int> addend, Vector128<int> value, byte count)
Vector128<long> ShiftRightLogicalRoundedAdd(Vector128<long> addend, Vector128<long> value, byte count)
Vector128<sbyte> ShiftRightLogicalRoundedAdd(Vector128<sbyte> addend, Vector128<sbyte> value, byte count)
Vector128<ushort> ShiftRightLogicalRoundedAdd(Vector128<ushort> addend, Vector128<ushort> value, byte count)
Vector128<uint> ShiftRightLogicalRoundedAdd(Vector128<uint> addend, Vector128<uint> value, byte count)
Vector128<ulong> ShiftRightLogicalRoundedAdd(Vector128<ulong> addend, Vector128<ulong> value, byte count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightlogicalroundedadd?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftRightLogicalRoundedAddTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M8322_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M8322_IG02:
            ldr     d0, [fp,#24]
            ldr     d1, [fp,#16]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightLogicalRoundedAdd(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
						;; bbWeight=1    PerfScore 5.50
G_M8322_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=acf2df7d) for method AdvSimdMethods:ShiftRightLogicalRoundedAddTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 51. ShiftRightLogicalRoundedAddScalar

`Vector64<long> ShiftRightLogicalRoundedAddScalar(Vector64<long> addend, Vector64<long> value, byte count)`

Performs 'ShiftRightLogicalRoundedAddScalar' operation.

```csharp
private Vector64<long> ShiftRightLogicalRoundedAddScalarTest(Vector64<long> addend, Vector64<long> value, byte count)
{
  return AdvSimd.ShiftRightLogicalRoundedAddScalar(addend, value, count);
}
// addend = <11>
// value = <11>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<ulong> ShiftRightLogicalRoundedAddScalar(Vector64<ulong> addend, Vector64<ulong> value, byte count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightlogicalroundedaddscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftRightLogicalRoundedAddScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M54391_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M54391_IG02:
            ldr     d0, [fp,#24]
            ldr     d1, [fp,#16]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightLogicalRoundedAddScalar(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
						;; bbWeight=1    PerfScore 5.50
G_M54391_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=e31d2b88) for method AdvSimdMethods:ShiftRightLogicalRoundedAddScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
; ============================================================


```
------------------------------------------------

### 52. ShiftRightLogicalRoundedNarrowingLower

`Vector64<byte> ShiftRightLogicalRoundedNarrowingLower(Vector128<ushort> value, byte count)`

Performs 'ShiftRightLogicalRoundedNarrowingLower' operation.

```csharp
private Vector64<byte> ShiftRightLogicalRoundedNarrowingLowerTest(Vector128<ushort> value, byte count)
{
  return AdvSimd.ShiftRightLogicalRoundedNarrowingLower(value, count);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> ShiftRightLogicalRoundedNarrowingLower(Vector128<int> value, byte count)
Vector64<int> ShiftRightLogicalRoundedNarrowingLower(Vector128<long> value, byte count)
Vector64<sbyte> ShiftRightLogicalRoundedNarrowingLower(Vector128<short> value, byte count)
Vector64<ushort> ShiftRightLogicalRoundedNarrowingLower(Vector128<uint> value, byte count)
Vector64<uint> ShiftRightLogicalRoundedNarrowingLower(Vector128<ulong> value, byte count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightlogicalroundednarrowinglower?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftRightLogicalRoundedNarrowingLowerTest(System.Runtime.Intrinsics.Vector128`1[UInt16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T01] (  2,  4   )  simd16  ->   d0         HFA(simd16)  "Inlining Arg"
;
; Lcl frame size = 16

G_M34516_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     q0, [fp,#16]
						;; bbWeight=1    PerfScore 2.50
G_M34516_IG02:
            ldr     q0, [fp,#16]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightLogicalRoundedNarrowingLower(System.Runtime.Intrinsics.Vector128`1[UInt16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
						;; bbWeight=1    PerfScore 3.50
G_M34516_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=276a792b) for method AdvSimdMethods:ShiftRightLogicalRoundedNarrowingLowerTest(System.Runtime.Intrinsics.Vector128`1[UInt16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 53. ShiftRightLogicalRoundedNarrowingSaturateLower

`Vector64<byte> ShiftRightLogicalRoundedNarrowingSaturateLower(Vector128<ushort> value, byte count)`

Performs 'ShiftRightLogicalRoundedNarrowingSaturateLower' operation.

```csharp
private Vector64<byte> ShiftRightLogicalRoundedNarrowingSaturateLowerTest(Vector128<ushort> value, byte count)
{
  return AdvSimd.ShiftRightLogicalRoundedNarrowingSaturateLower(value, count);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> ShiftRightLogicalRoundedNarrowingSaturateLower(Vector128<int> value, byte count)
Vector64<int> ShiftRightLogicalRoundedNarrowingSaturateLower(Vector128<long> value, byte count)
Vector64<sbyte> ShiftRightLogicalRoundedNarrowingSaturateLower(Vector128<short> value, byte count)
Vector64<ushort> ShiftRightLogicalRoundedNarrowingSaturateLower(Vector128<uint> value, byte count)
Vector64<uint> ShiftRightLogicalRoundedNarrowingSaturateLower(Vector128<ulong> value, byte count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightlogicalroundednarrowingsaturatelower?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftRightLogicalRoundedNarrowingSaturateLowerTest(System.Runtime.Intrinsics.Vector128`1[UInt16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T01] (  2,  4   )  simd16  ->   d0         HFA(simd16)  "Inlining Arg"
;
; Lcl frame size = 16

G_M40165_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     q0, [fp,#16]
						;; bbWeight=1    PerfScore 2.50
G_M40165_IG02:
            ldr     q0, [fp,#16]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightLogicalRoundedNarrowingSaturateLower(System.Runtime.Intrinsics.Vector128`1[UInt16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
						;; bbWeight=1    PerfScore 3.50
G_M40165_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=43e0631a) for method AdvSimdMethods:ShiftRightLogicalRoundedNarrowingSaturateLowerTest(System.Runtime.Intrinsics.Vector128`1[UInt16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 54. ShiftRightLogicalRoundedNarrowingSaturateUpper

`Vector128<byte> ShiftRightLogicalRoundedNarrowingSaturateUpper(Vector64<byte> lower, Vector128<ushort> value, byte count)`

Performs 'ShiftRightLogicalRoundedNarrowingSaturateUpper' operation.

```csharp
private Vector128<byte> ShiftRightLogicalRoundedNarrowingSaturateUpperTest(Vector64<byte> lower, Vector128<ushort> value, byte count)
{
  return AdvSimd.ShiftRightLogicalRoundedNarrowingSaturateUpper(lower, value, count);
}
// lower = <11, 12, 13, 14, 15, 16, 17, 18>
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<short> ShiftRightLogicalRoundedNarrowingSaturateUpper(Vector64<short> lower, Vector128<int> value, byte count)
Vector128<int> ShiftRightLogicalRoundedNarrowingSaturateUpper(Vector64<int> lower, Vector128<long> value, byte count)
Vector128<sbyte> ShiftRightLogicalRoundedNarrowingSaturateUpper(Vector64<sbyte> lower, Vector128<short> value, byte count)
Vector128<ushort> ShiftRightLogicalRoundedNarrowingSaturateUpper(Vector64<ushort> lower, Vector128<uint> value, byte count)
Vector128<uint> ShiftRightLogicalRoundedNarrowingSaturateUpper(Vector64<uint> lower, Vector128<ulong> value, byte count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightlogicalroundednarrowingsaturateupper?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftRightLogicalRoundedNarrowingSaturateUpperTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[UInt16],ubyte):System.Runtime.Intrinsics.Vector128`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T02] (  2,  4   )  simd16  ->   d1         HFA(simd16)  "Inlining Arg"
;
; Lcl frame size = 32

G_M26796_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     q1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M26796_IG02:
            ldr     d0, [fp,#40]
            ldr     q1, [fp,#16]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightLogicalRoundedNarrowingSaturateUpper(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[UInt16],ubyte):System.Runtime.Intrinsics.Vector128`1[Byte]
						;; bbWeight=1    PerfScore 5.50
G_M26796_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=34b19753) for method AdvSimdMethods:ShiftRightLogicalRoundedNarrowingSaturateUpperTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[UInt16],ubyte):System.Runtime.Intrinsics.Vector128`1[Byte]
; ============================================================


```
------------------------------------------------

### 55. ShiftRightLogicalRoundedNarrowingUpper

`Vector128<byte> ShiftRightLogicalRoundedNarrowingUpper(Vector64<byte> lower, Vector128<ushort> value, byte count)`

Performs 'ShiftRightLogicalRoundedNarrowingUpper' operation.

```csharp
private Vector128<byte> ShiftRightLogicalRoundedNarrowingUpperTest(Vector64<byte> lower, Vector128<ushort> value, byte count)
{
  return AdvSimd.ShiftRightLogicalRoundedNarrowingUpper(lower, value, count);
}
// lower = <11, 12, 13, 14, 15, 16, 17, 18>
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<short> ShiftRightLogicalRoundedNarrowingUpper(Vector64<short> lower, Vector128<int> value, byte count)
Vector128<int> ShiftRightLogicalRoundedNarrowingUpper(Vector64<int> lower, Vector128<long> value, byte count)
Vector128<sbyte> ShiftRightLogicalRoundedNarrowingUpper(Vector64<sbyte> lower, Vector128<short> value, byte count)
Vector128<ushort> ShiftRightLogicalRoundedNarrowingUpper(Vector64<ushort> lower, Vector128<uint> value, byte count)
Vector128<uint> ShiftRightLogicalRoundedNarrowingUpper(Vector64<uint> lower, Vector128<ulong> value, byte count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightlogicalroundednarrowingupper?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftRightLogicalRoundedNarrowingUpperTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[UInt16],ubyte):System.Runtime.Intrinsics.Vector128`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T02] (  2,  4   )  simd16  ->   d1         HFA(simd16)  "Inlining Arg"
;
; Lcl frame size = 32

G_M23453_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     q1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M23453_IG02:
            ldr     d0, [fp,#40]
            ldr     q1, [fp,#16]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightLogicalRoundedNarrowingUpper(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[UInt16],ubyte):System.Runtime.Intrinsics.Vector128`1[Byte]
						;; bbWeight=1    PerfScore 5.50
G_M23453_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=7532a462) for method AdvSimdMethods:ShiftRightLogicalRoundedNarrowingUpperTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[UInt16],ubyte):System.Runtime.Intrinsics.Vector128`1[Byte]
; ============================================================


```
------------------------------------------------

### 56. ShiftRightLogicalRoundedScalar

`Vector64<long> ShiftRightLogicalRoundedScalar(Vector64<long> value, byte count)`

Performs 'ShiftRightLogicalRoundedScalar' operation.

```csharp
private Vector64<long> ShiftRightLogicalRoundedScalarTest(Vector64<long> value, byte count)
{
  return AdvSimd.ShiftRightLogicalRoundedScalar(value, count);
}
// value = <11>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<ulong> ShiftRightLogicalRoundedScalar(Vector64<ulong> value, byte count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightlogicalroundedscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftRightLogicalRoundedScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M51260_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M51260_IG02:
            ldr     d0, [fp,#24]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightLogicalRoundedScalar(System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
						;; bbWeight=1    PerfScore 3.50
G_M51260_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=b33e37c3) for method AdvSimdMethods:ShiftRightLogicalRoundedScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
; ============================================================


```
------------------------------------------------

### 57. ShiftRightLogicalScalar

`Vector64<long> ShiftRightLogicalScalar(Vector64<long> value, byte count)`

Performs 'ShiftRightLogicalScalar' operation.

```csharp
private Vector64<long> ShiftRightLogicalScalarTest(Vector64<long> value, byte count)
{
  return AdvSimd.ShiftRightLogicalScalar(value, count);
}
// value = <11>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<ulong> ShiftRightLogicalScalar(Vector64<ulong> value, byte count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.shiftrightlogicalscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftRightLogicalScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M55519_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M55519_IG02:
            ldr     d0, [fp,#24]
            uxtb    w0, w0
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:ShiftRightLogicalScalar(System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
						;; bbWeight=1    PerfScore 3.50
G_M55519_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=98fc2720) for method AdvSimdMethods:ShiftRightLogicalScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],ubyte):System.Runtime.Intrinsics.Vector64`1[Int64]
; ============================================================


```
------------------------------------------------

### 58. SignExtendWideningLower

`Vector128<int> SignExtendWideningLower(Vector64<short> value)`

Performs 'SignExtendWideningLower' operation.

```csharp
private Vector128<int> SignExtendWideningLowerTest(Vector64<short> value)
{
  return AdvSimd.SignExtendWideningLower(value);
}
// value = <11, 12, 13, 14>
// Result = <11, 12, 13, 14>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<long> SignExtendWideningLower(Vector64<int> value)
Vector128<short> SignExtendWideningLower(Vector64<sbyte> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.signextendwideninglower?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:SignExtendWideningLowerTest(System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector128`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M43129_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M43129_IG02:
            ldr     d16, [fp,#24]
            sxtl    v16.4s, v16.4h
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 3.50
G_M43129_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=671a5786) for method AdvSimdMethods:SignExtendWideningLowerTest(System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector128`1[Int32]
; ============================================================


```
------------------------------------------------

### 59. SignExtendWideningUpper

`Vector128<int> SignExtendWideningUpper(Vector128<short> value)`

Performs 'SignExtendWideningUpper' operation.

```csharp
private Vector128<int> SignExtendWideningUpperTest(Vector128<short> value)
{
  return AdvSimd.SignExtendWideningUpper(value);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// Result = <15, 16, 17, 18>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<long> SignExtendWideningUpper(Vector128<int> value)
Vector128<short> SignExtendWideningUpper(Vector128<sbyte> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.signextendwideningupper?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:SignExtendWideningUpperTest(System.Runtime.Intrinsics.Vector128`1[Int16]):System.Runtime.Intrinsics.Vector128`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M27105_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     q0, [fp,#16]
						;; bbWeight=1    PerfScore 2.50
G_M27105_IG02:
            ldr     q16, [fp,#16]
            sxtl2   v16.4s, v16.8h
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 3.50
G_M27105_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=7ee8961e) for method AdvSimdMethods:SignExtendWideningUpperTest(System.Runtime.Intrinsics.Vector128`1[Int16]):System.Runtime.Intrinsics.Vector128`1[Int32]
; ============================================================


```
------------------------------------------------

### 60. SqrtScalar

`Vector64<double> SqrtScalar(Vector64<double> value)`

Performs 'SqrtScalar' operation.

```csharp
private Vector64<double> SqrtScalarTest(Vector64<double> value)
{
  return AdvSimd.SqrtScalar(value);
}
// value = <11.5>
// Result = <3.391164991562634>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<float> SqrtScalar(Vector64<float> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.sqrtscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:SqrtScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M20939_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M20939_IG02:
            ldr     d16, [fp,#24]
            fsqrt   d16, d16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 23.50
G_M20939_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 31.20, (MethodHash=0b33ae34) for method AdvSimdMethods:SqrtScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================

```

---
STARTlayout:post
title: Hardware Intrinsics APIs for ARM64 - Part 5
subtitle: With examples
tags: [work, arm64, intrinsics]
---

### Introduction

In my [last post](../2019-01-01-Vectorization-APIs), I describe SIMD datatypes `Vector64<T>` and `Vector128<T>` that operates on 'hardware intrisic' APIs. In this post I will describe the intrinsic APIs for ARM64 and how you can use them to optimize your code if you are writing a .NET API targetting ARM64. This is 3 post series TODO.


### API list

[Store](#1-store), [StoreSelectedScalar](#2-storeselectedscalar), [Subtract](#3-subtract), [SubtractHighNarrowingLower](#4-subtracthighnarrowinglower), [SubtractHighNarrowingUpper](#5-subtracthighnarrowingupper), [SubtractRoundedHighNarrowingLower](#6-subtractroundedhighnarrowinglower), [SubtractRoundedHighNarrowingUpper](#7-subtractroundedhighnarrowingupper), [SubtractSaturate](#8-subtractsaturate), [SubtractSaturateScalar](#9-subtractsaturatescalar), [SubtractScalar](#10-subtractscalar), [SubtractWideningLower](#11-subtractwideninglower), [SubtractWideningUpper](#12-subtractwideningupper), [VectorTableLookup](#13-vectortablelookup), [VectorTableLookupExtension](#14-vectortablelookupextension), [Xor](#15-xor), [ZeroExtendWideningLower](#16-zeroextendwideninglower), [ZeroExtendWideningUpper](#17-zeroextendwideningupper), [AbsSaturateScalar](#18-abssaturatescalar), [AbsoluteCompareGreaterThanScalar](#19-absolutecomparegreaterthanscalar), [AbsoluteCompareGreaterThanOrEqualScalar](#20-absolutecomparegreaterthanorequalscalar), [AbsoluteCompareLessThanScalar](#21-absolutecomparelessthanscalar), [AbsoluteCompareLessThanOrEqualScalar](#22-absolutecomparelessthanorequalscalar), [AbsoluteDifferenceScalar](#23-absolutedifferencescalar), [AddAcross](#24-addacross), [AddAcrossWidening](#25-addacrosswidening), [AddPairwiseScalar](#26-addpairwisescalar), [CompareEqualScalar](#27-compareequalscalar), [CompareGreaterThanScalar](#28-comparegreaterthanscalar), [CompareGreaterThanOrEqualScalar](#29-comparegreaterthanorequalscalar), [CompareLessThanScalar](#30-comparelessthanscalar), [CompareLessThanOrEqualScalar](#31-comparelessthanorequalscalar), [CompareTestScalar](#32-comparetestscalar), [ConvertToDouble](#33-converttodouble), [ConvertToDoubleScalar](#34-converttodoublescalar), [ConvertToDoubleUpper](#35-converttodoubleupper), [ConvertToInt64RoundAwayFromZero](#36-converttoint64roundawayfromzero), [ConvertToInt64RoundAwayFromZeroScalar](#37-converttoint64roundawayfromzeroscalar), [ConvertToInt64RoundToEven](#38-converttoint64roundtoeven), [ConvertToInt64RoundToEvenScalar](#39-converttoint64roundtoevenscalar), [ConvertToInt64RoundToNegativeInfinity](#40-converttoint64roundtonegativeinfinity), [ConvertToInt64RoundToNegativeInfinityScalar](#41-converttoint64roundtonegativeinfinityscalar), [ConvertToInt64RoundToPositiveInfinity](#42-converttoint64roundtopositiveinfinity), [ConvertToInt64RoundToPositiveInfinityScalar](#43-converttoint64roundtopositiveinfinityscalar), [ConvertToInt64RoundToZero](#44-converttoint64roundtozero), [ConvertToInt64RoundToZeroScalar](#45-converttoint64roundtozeroscalar), [ConvertToSingleLower](#46-converttosinglelower), [ConvertToSingleRoundToOddLower](#47-converttosingleroundtooddlower), [ConvertToSingleRoundToOddUpper](#48-converttosingleroundtooddupper), [ConvertToSingleUpper](#49-converttosingleupper), [ConvertToUInt64RoundAwayFromZero](#50-converttouint64roundawayfromzero), [ConvertToUInt64RoundAwayFromZeroScalar](#51-converttouint64roundawayfromzeroscalar), [ConvertToUInt64RoundToEven](#52-converttouint64roundtoeven), [ConvertToUInt64RoundToEvenScalar](#53-converttouint64roundtoevenscalar), [ConvertToUInt64RoundToNegativeInfinity](#54-converttouint64roundtonegativeinfinity), [ConvertToUInt64RoundToNegativeInfinityScalar](#55-converttouint64roundtonegativeinfinityscalar), [ConvertToUInt64RoundToPositiveInfinity](#56-converttouint64roundtopositiveinfinity), [ConvertToUInt64RoundToPositiveInfinityScalar](#57-converttouint64roundtopositiveinfinityscalar), [ConvertToUInt64RoundToZero](#58-converttouint64roundtozero), [ConvertToUInt64RoundToZeroScalar](#59-converttouint64roundtozeroscalar), [Divide](#60-divide),[...](Part5.md)



; Assembly listing for method AdvSimdMethods:StoreTest(long,System.Runtime.Intrinsics.Vector64`1[Byte])
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00,T00] (  3,  3   )    long  ->   x0        
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M62783_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M62783_IG02:
            ldr     d16, [fp,#24]
            st1     {v16.8b}, [x0]
						;; bbWeight=1    PerfScore 3.00
G_M62783_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 28, prolog size 8, PerfScore 10.30, (MethodHash=e2ee0ac0) for method AdvSimdMethods:StoreTest(long,System.Runtime.Intrinsics.Vector64`1[Byte])
; ============================================================




### 1. Store

`void Store(byte* address, Vector64<byte> source)`

Performs 'Store' operation.

```csharp
private void StoreTest(byte* address, Vector64<byte> source)
{
  AdvSimd.Store(address, source);
}
// address = <address>
// source = <11, 12, 13, 14, 15, 16, 17, 18>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
void Store(double* address, Vector64<double> source)
void Store(short* address, Vector64<short> source)
void Store(int* address, Vector64<int> source)
void Store(long* address, Vector64<long> source)
void Store(sbyte* address, Vector64<sbyte> source)
void Store(float* address, Vector64<float> source)
void Store(ushort* address, Vector64<ushort> source)
void Store(uint* address, Vector64<uint> source)
void Store(ulong* address, Vector64<ulong> source)
void Store(byte* address, Vector128<byte> source)
void Store(double* address, Vector128<double> source)
void Store(short* address, Vector128<short> source)
void Store(int* address, Vector128<int> source)
void Store(long* address, Vector128<long> source)
void Store(sbyte* address, Vector128<sbyte> source)
void Store(float* address, Vector128<float> source)
void Store(ushort* address, Vector128<ushort> source)
void Store(uint* address, Vector128<uint> source)
void Store(ulong* address, Vector128<ulong> source)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.store?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:StoreSelectedScalarTest(long,System.Runtime.Intrinsics.Vector64`1[Byte],ubyte)
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00,T00] (  3,  3   )    long  ->   x0        
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02,T01] (  3,  3   )   ubyte  ->   x1        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T02] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M29099_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M29099_IG02:
            ldr     d0, [fp,#24]
            uxtb    w1, w1
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:StoreSelectedScalar(long,System.Runtime.Intrinsics.Vector64`1[Byte],ubyte)
						;; bbWeight=1    PerfScore 3.50
G_M29099_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=3e348e54) for method AdvSimdMethods:StoreSelectedScalarTest(long,System.Runtime.Intrinsics.Vector64`1[Byte],ubyte)
; ============================================================


```
------------------------------------------------

### 2. StoreSelectedScalar

`void StoreSelectedScalar(byte* address, Vector64<byte> value, byte index)`

Performs 'StoreSelectedScalar' operation.

```csharp
private void StoreSelectedScalarTest(byte* address, Vector64<byte> value, byte index)
{
  AdvSimd.StoreSelectedScalar(address, value, index);
}
// address = <address>
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// index = 0

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
void StoreSelectedScalar(short* address, Vector64<short> value, byte index)
void StoreSelectedScalar(int* address, Vector64<int> value, byte index)
void StoreSelectedScalar(sbyte* address, Vector64<sbyte> value, byte index)
void StoreSelectedScalar(float* address, Vector64<float> value, byte index)
void StoreSelectedScalar(ushort* address, Vector64<ushort> value, byte index)
void StoreSelectedScalar(uint* address, Vector64<uint> value, byte index)
void StoreSelectedScalar(byte* address, Vector128<byte> value, byte index)
void StoreSelectedScalar(double* address, Vector128<double> value, byte index)
void StoreSelectedScalar(short* address, Vector128<short> value, byte index)
void StoreSelectedScalar(int* address, Vector128<int> value, byte index)
void StoreSelectedScalar(long* address, Vector128<long> value, byte index)
void StoreSelectedScalar(sbyte* address, Vector128<sbyte> value, byte index)
void StoreSelectedScalar(float* address, Vector128<float> value, byte index)
void StoreSelectedScalar(ushort* address, Vector128<ushort> value, byte index)
void StoreSelectedScalar(uint* address, Vector128<uint> value, byte index)
void StoreSelectedScalar(ulong* address, Vector128<ulong> value, byte index)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.storeselectedscalar?view=net-5.0).

Assembly generated:

```



```
------------------------------------------------

### 3. Subtract

`Vector64<byte> Subtract(Vector64<byte> left, Vector64<byte> right)`

Performs 'Subtract' operation.

```csharp
private Vector64<byte> SubtractTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.Subtract(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <246, 246, 246, 246, 246, 246, 246, 246>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> Subtract(Vector64<short> left, Vector64<short> right)
Vector64<int> Subtract(Vector64<int> left, Vector64<int> right)
Vector64<sbyte> Subtract(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<float> Subtract(Vector64<float> left, Vector64<float> right)
Vector64<ushort> Subtract(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> Subtract(Vector64<uint> left, Vector64<uint> right)
Vector128<byte> Subtract(Vector128<byte> left, Vector128<byte> right)
Vector128<short> Subtract(Vector128<short> left, Vector128<short> right)
Vector128<int> Subtract(Vector128<int> left, Vector128<int> right)
Vector128<long> Subtract(Vector128<long> left, Vector128<long> right)
Vector128<sbyte> Subtract(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<float> Subtract(Vector128<float> left, Vector128<float> right)
Vector128<ushort> Subtract(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> Subtract(Vector128<uint> left, Vector128<uint> right)
Vector128<ulong> Subtract(Vector128<ulong> left, Vector128<ulong> right)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> Subtract(Vector128<double> left, Vector128<double> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.subtract?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.subtract?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:SubtractTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M12068_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M12068_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            sub     v16.8b, v16.8b, v17.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M12068_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=88cbd0db) for method AdvSimdMethods:SubtractTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 4. SubtractHighNarrowingLower

`Vector64<byte> SubtractHighNarrowingLower(Vector128<ushort> left, Vector128<ushort> right)`

Performs 'SubtractHighNarrowingLower' operation.

```csharp
private Vector64<byte> SubtractHighNarrowingLowerTest(Vector128<ushort> left, Vector128<ushort> right)
{
  return AdvSimd.SubtractHighNarrowingLower(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <11, 12, 13, 14, 15, 16, 17, 18>
// Result = <0, 0, 0, 0, 0, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> SubtractHighNarrowingLower(Vector128<int> left, Vector128<int> right)
Vector64<int> SubtractHighNarrowingLower(Vector128<long> left, Vector128<long> right)
Vector64<sbyte> SubtractHighNarrowingLower(Vector128<short> left, Vector128<short> right)
Vector64<ushort> SubtractHighNarrowingLower(Vector128<uint> left, Vector128<uint> right)
Vector64<uint> SubtractHighNarrowingLower(Vector128<ulong> left, Vector128<ulong> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.subtracthighnarrowinglower?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:SubtractHighNarrowingLowerTest(System.Runtime.Intrinsics.Vector128`1[UInt16],System.Runtime.Intrinsics.Vector128`1[UInt16]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M37822_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     q0, [fp,#32]
            str     q1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M37822_IG02:
            ldr     q16, [fp,#32]
            ldr     q17, [fp,#16]
            subhn   v16.8b, v16.8h, v17.8h
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 6.50
G_M37822_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 16.00, (MethodHash=125e6c41) for method AdvSimdMethods:SubtractHighNarrowingLowerTest(System.Runtime.Intrinsics.Vector128`1[UInt16],System.Runtime.Intrinsics.Vector128`1[UInt16]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 5. SubtractHighNarrowingUpper

`Vector128<byte> SubtractHighNarrowingUpper(Vector64<byte> lower, Vector128<ushort> left, Vector128<ushort> right)`

Performs 'SubtractHighNarrowingUpper' operation.

```csharp
private Vector128<byte> SubtractHighNarrowingUpperTest(Vector64<byte> lower, Vector128<ushort> left, Vector128<ushort> right)
{
  return AdvSimd.SubtractHighNarrowingUpper(lower, left, right);
}
// lower = <11, 12, 13, 14, 15, 16, 17, 18>
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <11, 12, 13, 14, 15, 16, 17, 18>
// Result = <11, 12, 13, 14, 15, 16, 17, 18, 0, 0, 0, 0, 0, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<short> SubtractHighNarrowingUpper(Vector64<short> lower, Vector128<int> left, Vector128<int> right)
Vector128<int> SubtractHighNarrowingUpper(Vector64<int> lower, Vector128<long> left, Vector128<long> right)
Vector128<sbyte> SubtractHighNarrowingUpper(Vector64<sbyte> lower, Vector128<short> left, Vector128<short> right)
Vector128<ushort> SubtractHighNarrowingUpper(Vector64<ushort> lower, Vector128<uint> left, Vector128<uint> right)
Vector128<uint> SubtractHighNarrowingUpper(Vector64<uint> lower, Vector128<ulong> left, Vector128<ulong> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.subtracthighnarrowingupper?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:SubtractHighNarrowingUpperTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[UInt16],System.Runtime.Intrinsics.Vector128`1[UInt16]):System.Runtime.Intrinsics.Vector128`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x38]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 48

G_M40375_IG01:
            stp     fp, lr, [sp,#-64]!
            mov     fp, sp
            str     d0, [fp,#56]
            str     q1, [fp,#32]
            str     q2, [fp,#16]
						;; bbWeight=1    PerfScore 4.50
G_M40375_IG02:
            ldr     d16, [fp,#56]
            ldr     q17, [fp,#32]
            ldr     q18, [fp,#16]
            subhn2  v16.16b, v17.8h, v18.8h
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 8.50
G_M40375_IG03:
            ldp     fp, lr, [sp],#64
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 19.80, (MethodHash=bc616248) for method AdvSimdMethods:SubtractHighNarrowingUpperTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[UInt16],System.Runtime.Intrinsics.Vector128`1[UInt16]):System.Runtime.Intrinsics.Vector128`1[Byte]
; ============================================================


```
------------------------------------------------

### 6. SubtractRoundedHighNarrowingLower

`Vector64<byte> SubtractRoundedHighNarrowingLower(Vector128<ushort> left, Vector128<ushort> right)`

Performs 'SubtractRoundedHighNarrowingLower' operation.

```csharp
private Vector64<byte> SubtractRoundedHighNarrowingLowerTest(Vector128<ushort> left, Vector128<ushort> right)
{
  return AdvSimd.SubtractRoundedHighNarrowingLower(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <11, 12, 13, 14, 15, 16, 17, 18>
// Result = <0, 0, 0, 0, 0, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> SubtractRoundedHighNarrowingLower(Vector128<int> left, Vector128<int> right)
Vector64<int> SubtractRoundedHighNarrowingLower(Vector128<long> left, Vector128<long> right)
Vector64<sbyte> SubtractRoundedHighNarrowingLower(Vector128<short> left, Vector128<short> right)
Vector64<ushort> SubtractRoundedHighNarrowingLower(Vector128<uint> left, Vector128<uint> right)
Vector64<uint> SubtractRoundedHighNarrowingLower(Vector128<ulong> left, Vector128<ulong> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.subtractroundedhighnarrowinglower?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:SubtractRoundedHighNarrowingLowerTest(System.Runtime.Intrinsics.Vector128`1[UInt16],System.Runtime.Intrinsics.Vector128`1[UInt16]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M60829_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     q0, [fp,#32]
            str     q1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M60829_IG02:
            ldr     q16, [fp,#32]
            ldr     q17, [fp,#16]
            rsubhn  v16.8b, v16.8h, v17.8h
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M60829_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=16161262) for method AdvSimdMethods:SubtractRoundedHighNarrowingLowerTest(System.Runtime.Intrinsics.Vector128`1[UInt16],System.Runtime.Intrinsics.Vector128`1[UInt16]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 7. SubtractRoundedHighNarrowingUpper

`Vector128<byte> SubtractRoundedHighNarrowingUpper(Vector64<byte> lower, Vector128<ushort> left, Vector128<ushort> right)`

Performs 'SubtractRoundedHighNarrowingUpper' operation.

```csharp
private Vector128<byte> SubtractRoundedHighNarrowingUpperTest(Vector64<byte> lower, Vector128<ushort> left, Vector128<ushort> right)
{
  return AdvSimd.SubtractRoundedHighNarrowingUpper(lower, left, right);
}
// lower = <11, 12, 13, 14, 15, 16, 17, 18>
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <11, 12, 13, 14, 15, 16, 17, 18>
// Result = <11, 12, 13, 14, 15, 16, 17, 18, 0, 0, 0, 0, 0, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<short> SubtractRoundedHighNarrowingUpper(Vector64<short> lower, Vector128<int> left, Vector128<int> right)
Vector128<int> SubtractRoundedHighNarrowingUpper(Vector64<int> lower, Vector128<long> left, Vector128<long> right)
Vector128<sbyte> SubtractRoundedHighNarrowingUpper(Vector64<sbyte> lower, Vector128<short> left, Vector128<short> right)
Vector128<ushort> SubtractRoundedHighNarrowingUpper(Vector64<ushort> lower, Vector128<uint> left, Vector128<uint> right)
Vector128<uint> SubtractRoundedHighNarrowingUpper(Vector64<uint> lower, Vector128<ulong> left, Vector128<ulong> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.subtractroundedhighnarrowingupper?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:SubtractRoundedHighNarrowingUpperTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[UInt16],System.Runtime.Intrinsics.Vector128`1[UInt16]):System.Runtime.Intrinsics.Vector128`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x38]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 48

G_M54804_IG01:
            stp     fp, lr, [sp,#-64]!
            mov     fp, sp
            str     d0, [fp,#56]
            str     q1, [fp,#32]
            str     q2, [fp,#16]
						;; bbWeight=1    PerfScore 4.50
G_M54804_IG02:
            ldr     d16, [fp,#56]
            ldr     q17, [fp,#32]
            ldr     q18, [fp,#16]
            rsubhn2 v16.16b, v17.8h, v18.8h
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 9.50
G_M54804_IG03:
            ldp     fp, lr, [sp],#64
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 20.80, (MethodHash=f9a929eb) for method AdvSimdMethods:SubtractRoundedHighNarrowingUpperTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[UInt16],System.Runtime.Intrinsics.Vector128`1[UInt16]):System.Runtime.Intrinsics.Vector128`1[Byte]
; ============================================================


```
------------------------------------------------

### 8. SubtractSaturate

`Vector64<byte> SubtractSaturate(Vector64<byte> left, Vector64<byte> right)`

Performs 'SubtractSaturate' operation.

```csharp
private Vector64<byte> SubtractSaturateTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.SubtractSaturate(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <0, 0, 0, 0, 0, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<short> SubtractSaturate(Vector64<short> left, Vector64<short> right)
Vector64<int> SubtractSaturate(Vector64<int> left, Vector64<int> right)
Vector64<sbyte> SubtractSaturate(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<ushort> SubtractSaturate(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> SubtractSaturate(Vector64<uint> left, Vector64<uint> right)
Vector128<byte> SubtractSaturate(Vector128<byte> left, Vector128<byte> right)
Vector128<short> SubtractSaturate(Vector128<short> left, Vector128<short> right)
Vector128<int> SubtractSaturate(Vector128<int> left, Vector128<int> right)
Vector128<long> SubtractSaturate(Vector128<long> left, Vector128<long> right)
Vector128<sbyte> SubtractSaturate(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<ushort> SubtractSaturate(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> SubtractSaturate(Vector128<uint> left, Vector128<uint> right)
Vector128<ulong> SubtractSaturate(Vector128<ulong> left, Vector128<ulong> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.subtractsaturate?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:SubtractSaturateTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M13941_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M13941_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            uqsub   v16.8b, v16.8b, v17.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 6.50
G_M13941_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 16.00, (MethodHash=a331c98a) for method AdvSimdMethods:SubtractSaturateTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 9. SubtractSaturateScalar

`Vector64<long> SubtractSaturateScalar(Vector64<long> left, Vector64<long> right)`

Performs 'SubtractSaturateScalar' operation.

```csharp
private Vector64<long> SubtractSaturateScalarTest(Vector64<long> left, Vector64<long> right)
{
  return AdvSimd.SubtractSaturateScalar(left, right);
}
// left = <11>
// right = <11>
// Result = <0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<ulong> SubtractSaturateScalar(Vector64<ulong> left, Vector64<ulong> right)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<byte> SubtractSaturateScalar(Vector64<byte> left, Vector64<byte> right)
Vector64<short> SubtractSaturateScalar(Vector64<short> left, Vector64<short> right)
Vector64<int> SubtractSaturateScalar(Vector64<int> left, Vector64<int> right)
Vector64<sbyte> SubtractSaturateScalar(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<ushort> SubtractSaturateScalar(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> SubtractSaturateScalar(Vector64<uint> left, Vector64<uint> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.subtractsaturatescalar?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.subtractsaturatescalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:SubtractSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64]):System.Runtime.Intrinsics.Vector64`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M50336_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M50336_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            sqsub   d16, d16, d17
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M50336_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=00b63b5f) for method AdvSimdMethods:SubtractSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64],System.Runtime.Intrinsics.Vector64`1[Int64]):System.Runtime.Intrinsics.Vector64`1[Int64]
; ============================================================


```
------------------------------------------------

### 10. SubtractScalar

`Vector64<double> SubtractScalar(Vector64<double> left, Vector64<double> right)`

Performs 'SubtractScalar' operation.

```csharp
private Vector64<double> SubtractScalarTest(Vector64<double> left, Vector64<double> right)
{
  return AdvSimd.SubtractScalar(left, right);
}
// left = <11.5>
// right = <11.5>
// Result = <0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<long> SubtractScalar(Vector64<long> left, Vector64<long> right)
Vector64<float> SubtractScalar(Vector64<float> left, Vector64<float> right)
Vector64<ulong> SubtractScalar(Vector64<ulong> left, Vector64<ulong> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.subtractscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:SubtractScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M42133_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M42133_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            fsub    d16, d16, d17
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M42133_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=a75e5b6a) for method AdvSimdMethods:SubtractScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 11. SubtractWideningLower

`Vector128<ushort> SubtractWideningLower(Vector64<byte> left, Vector64<byte> right)`

Performs 'SubtractWideningLower' operation.

```csharp
private Vector128<ushort> SubtractWideningLowerTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.SubtractWideningLower(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <65526, 65526, 65526, 65526, 65526, 65526, 65526, 65526>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<int> SubtractWideningLower(Vector64<short> left, Vector64<short> right)
Vector128<long> SubtractWideningLower(Vector64<int> left, Vector64<int> right)
Vector128<short> SubtractWideningLower(Vector64<sbyte> left, Vector64<sbyte> right)
Vector128<uint> SubtractWideningLower(Vector64<ushort> left, Vector64<ushort> right)
Vector128<ulong> SubtractWideningLower(Vector64<uint> left, Vector64<uint> right)
Vector128<short> SubtractWideningLower(Vector128<short> left, Vector64<sbyte> right)
Vector128<int> SubtractWideningLower(Vector128<int> left, Vector64<short> right)
Vector128<long> SubtractWideningLower(Vector128<long> left, Vector64<int> right)
Vector128<ushort> SubtractWideningLower(Vector128<ushort> left, Vector64<byte> right)
Vector128<uint> SubtractWideningLower(Vector128<uint> left, Vector64<ushort> right)
Vector128<ulong> SubtractWideningLower(Vector128<ulong> left, Vector64<uint> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.subtractwideninglower?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:SubtractWideningLowerTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector128`1[UInt16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M35012_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M35012_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            usubl   v16.8h, v16.8b, v17.8b
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 6.50
G_M35012_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 16.00, (MethodHash=21e0773b) for method AdvSimdMethods:SubtractWideningLowerTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector128`1[UInt16]
; ============================================================


```
------------------------------------------------

### 12. SubtractWideningUpper

`Vector128<ushort> SubtractWideningUpper(Vector128<byte> left, Vector128<byte> right)`

Performs 'SubtractWideningUpper' operation.

```csharp
private Vector128<ushort> SubtractWideningUpperTest(Vector128<byte> left, Vector128<byte> right)
{
  return AdvSimd.SubtractWideningUpper(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26>
// right = <21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36>
// Result = <65526, 65526, 65526, 65526, 65526, 65526, 65526, 65526>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<int> SubtractWideningUpper(Vector128<short> left, Vector128<short> right)
Vector128<short> SubtractWideningUpper(Vector128<short> left, Vector128<sbyte> right)
Vector128<int> SubtractWideningUpper(Vector128<int> left, Vector128<short> right)
Vector128<long> SubtractWideningUpper(Vector128<int> left, Vector128<int> right)
Vector128<long> SubtractWideningUpper(Vector128<long> left, Vector128<int> right)
Vector128<short> SubtractWideningUpper(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<ushort> SubtractWideningUpper(Vector128<ushort> left, Vector128<byte> right)
Vector128<uint> SubtractWideningUpper(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> SubtractWideningUpper(Vector128<uint> left, Vector128<ushort> right)
Vector128<ulong> SubtractWideningUpper(Vector128<uint> left, Vector128<uint> right)
Vector128<ulong> SubtractWideningUpper(Vector128<ulong> left, Vector128<uint> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.subtractwideningupper?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:SubtractWideningUpperTest(System.Runtime.Intrinsics.Vector128`1[Byte],System.Runtime.Intrinsics.Vector128`1[Byte]):System.Runtime.Intrinsics.Vector128`1[UInt16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M55653_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     q0, [fp,#32]
            str     q1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M55653_IG02:
            ldr     q16, [fp,#32]
            ldr     q17, [fp,#16]
            usubl2  v16.8h, v16.16b, v17.16b
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 6.50
G_M55653_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 16.00, (MethodHash=d8f5269a) for method AdvSimdMethods:SubtractWideningUpperTest(System.Runtime.Intrinsics.Vector128`1[Byte],System.Runtime.Intrinsics.Vector128`1[Byte]):System.Runtime.Intrinsics.Vector128`1[UInt16]
; ============================================================


```
------------------------------------------------

### 13. VectorTableLookup

`Vector64<byte> VectorTableLookup(Vector128<byte> table, Vector64<byte> byteIndexes)`

Performs 'VectorTableLookup' operation.

```csharp
private Vector64<byte> VectorTableLookupTest(Vector128<byte> table, Vector64<byte> byteIndexes)
{
  return AdvSimd.VectorTableLookup(table, byteIndexes);
}
// table = <11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26>
// byteIndexes = <11, 12, 13, 14, 15, 16, 17, 18>
// Result = <22, 23, 24, 25, 26, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<sbyte> VectorTableLookup(Vector128<sbyte> table, Vector64<sbyte> byteIndexes)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<byte> VectorTableLookup(Vector128<byte> table, Vector128<byte> byteIndexes)
Vector128<sbyte> VectorTableLookup(Vector128<sbyte> table, Vector128<sbyte> byteIndexes)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.vectortablelookup?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.vectortablelookup?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:VectorTableLookupTest(System.Runtime.Intrinsics.Vector128`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M21228_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     q0, [fp,#32]
            str     d1, [fp,#24]
						;; bbWeight=1    PerfScore 3.50
G_M21228_IG02:
            ldr     q16, [fp,#32]
            ldr     d17, [fp,#24]
            tbl     v16.8b, {v16.16b}, v17.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.00
G_M21228_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 14.50, (MethodHash=881cad13) for method AdvSimdMethods:VectorTableLookupTest(System.Runtime.Intrinsics.Vector128`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 14. VectorTableLookupExtension

`Vector64<byte> VectorTableLookupExtension(Vector64<byte> defaultValues, Vector128<byte> table, Vector64<byte> byteIndexes)`

Performs 'VectorTableLookupExtension' operation.

```csharp
private Vector64<byte> VectorTableLookupExtensionTest(Vector64<byte> defaultValues, Vector128<byte> table, Vector64<byte> byteIndexes)
{
  return AdvSimd.VectorTableLookupExtension(defaultValues, table, byteIndexes);
}
// defaultValues = <11, 12, 13, 14, 15, 16, 17, 18>
// table = <11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26>
// byteIndexes = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <11, 12, 13, 14, 15, 16, 17, 18>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<sbyte> VectorTableLookupExtension(Vector64<sbyte> defaultValues, Vector128<sbyte> table, Vector64<sbyte> byteIndexes)

// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<byte> VectorTableLookupExtension(Vector128<byte> defaultValues, Vector128<byte> table, Vector128<byte> byteIndexes)
Vector128<sbyte> VectorTableLookupExtension(Vector128<sbyte> defaultValues, Vector128<sbyte> table, Vector128<sbyte> byteIndexes)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.vectortablelookupextension?view=net-5.0) and [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.vectortablelookupextension?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:VectorTableLookupExtensionTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x38]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 48

G_M48420_IG01:
            stp     fp, lr, [sp,#-64]!
            mov     fp, sp
            str     d0, [fp,#56]
            str     q1, [fp,#32]
            str     d2, [fp,#24]
						;; bbWeight=1    PerfScore 4.50
G_M48420_IG02:
            ldr     d16, [fp,#56]
            ldr     q17, [fp,#32]
            ldr     d18, [fp,#24]
            tbx     v16.8b, {v17.16b}, v18.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M48420_IG03:
            ldp     fp, lr, [sp],#64
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 18.80, (MethodHash=430b42db) for method AdvSimdMethods:VectorTableLookupExtensionTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector128`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 15. Xor

`Vector64<byte> Xor(Vector64<byte> left, Vector64<byte> right)`

Performs 'Xor' operation.

```csharp
private Vector64<byte> XorTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.Xor(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <30, 26, 26, 22, 22, 10, 10, 14>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector64<double> Xor(Vector64<double> left, Vector64<double> right)
Vector64<short> Xor(Vector64<short> left, Vector64<short> right)
Vector64<int> Xor(Vector64<int> left, Vector64<int> right)
Vector64<long> Xor(Vector64<long> left, Vector64<long> right)
Vector64<sbyte> Xor(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<float> Xor(Vector64<float> left, Vector64<float> right)
Vector64<ushort> Xor(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> Xor(Vector64<uint> left, Vector64<uint> right)
Vector64<ulong> Xor(Vector64<ulong> left, Vector64<ulong> right)
Vector128<byte> Xor(Vector128<byte> left, Vector128<byte> right)
Vector128<double> Xor(Vector128<double> left, Vector128<double> right)
Vector128<short> Xor(Vector128<short> left, Vector128<short> right)
Vector128<int> Xor(Vector128<int> left, Vector128<int> right)
Vector128<long> Xor(Vector128<long> left, Vector128<long> right)
Vector128<sbyte> Xor(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<float> Xor(Vector128<float> left, Vector128<float> right)
Vector128<ushort> Xor(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> Xor(Vector128<uint> left, Vector128<uint> right)
Vector128<ulong> Xor(Vector128<ulong> left, Vector128<ulong> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.xor?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:XorTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M6805_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M6805_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            eor     v16.8b, v16.8b, v17.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.00
G_M6805_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 14.50, (MethodHash=13f8e56a) for method AdvSimdMethods:XorTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 16. ZeroExtendWideningLower

`Vector128<ushort> ZeroExtendWideningLower(Vector64<byte> value)`

Performs 'ZeroExtendWideningLower' operation.

```csharp
private Vector128<ushort> ZeroExtendWideningLowerTest(Vector64<byte> value)
{
  return AdvSimd.ZeroExtendWideningLower(value);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// Result = <11, 12, 13, 14, 15, 16, 17, 18>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<int> ZeroExtendWideningLower(Vector64<short> value)
Vector128<long> ZeroExtendWideningLower(Vector64<int> value)
Vector128<short> ZeroExtendWideningLower(Vector64<sbyte> value)
Vector128<uint> ZeroExtendWideningLower(Vector64<ushort> value)
Vector128<ulong> ZeroExtendWideningLower(Vector64<uint> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.zeroextendwideninglower?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ZeroExtendWideningLowerTest(System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector128`1[UInt16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M42213_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M42213_IG02:
            ldr     d16, [fp,#24]
            uxtl    v16.8h, v16.8b
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 3.50
G_M42213_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=7f955b1a) for method AdvSimdMethods:ZeroExtendWideningLowerTest(System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector128`1[UInt16]
; ============================================================


```
------------------------------------------------

### 17. ZeroExtendWideningUpper

`Vector128<ushort> ZeroExtendWideningUpper(Vector128<byte> value)`

Performs 'ZeroExtendWideningUpper' operation.

```csharp
private Vector128<ushort> ZeroExtendWideningUpperTest(Vector128<byte> value)
{
  return AdvSimd.ZeroExtendWideningUpper(value);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26>
// Result = <19, 20, 21, 22, 23, 24, 25, 26>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd
Vector128<int> ZeroExtendWideningUpper(Vector128<short> value)
Vector128<long> ZeroExtendWideningUpper(Vector128<int> value)
Vector128<short> ZeroExtendWideningUpper(Vector128<sbyte> value)
Vector128<uint> ZeroExtendWideningUpper(Vector128<ushort> value)
Vector128<ulong> ZeroExtendWideningUpper(Vector128<uint> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.zeroextendwideningupper?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ZeroExtendWideningUpperTest(System.Runtime.Intrinsics.Vector128`1[Byte]):System.Runtime.Intrinsics.Vector128`1[UInt16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M6365_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     q0, [fp,#16]
						;; bbWeight=1    PerfScore 2.50
G_M6365_IG02:
            ldr     q16, [fp,#16]
            uxtl2   v16.8h, v16.16b
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 3.50
G_M6365_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=c275e722) for method AdvSimdMethods:ZeroExtendWideningUpperTest(System.Runtime.Intrinsics.Vector128`1[Byte]):System.Runtime.Intrinsics.Vector128`1[UInt16]
; ============================================================


```
------------------------------------------------

### 18. AbsSaturateScalar

`Vector64<short> AbsSaturateScalar(Vector64<short> value)`

Performs 'AbsSaturateScalar' operation.

```csharp
private Vector64<short> AbsSaturateScalarTest(Vector64<short> value)
{
  return AdvSimd.Arm64.AbsSaturateScalar(value);
}
// value = <11, 12, 13, 14>
// Result = <11, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<int> AbsSaturateScalar(Vector64<int> value)
Vector64<long> AbsSaturateScalar(Vector64<long> value)
Vector64<sbyte> AbsSaturateScalar(Vector64<sbyte> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.abssaturatescalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:AbsSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M26126_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M26126_IG02:
            ldr     d16, [fp,#24]
            sqabs   h16, h16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M26126_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=1b6e99f1) for method AdvSimdMethods:AbsSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 19. AbsoluteCompareGreaterThanScalar

`Vector64<double> AbsoluteCompareGreaterThanScalar(Vector64<double> left, Vector64<double> right)`

Performs 'AbsoluteCompareGreaterThanScalar' operation.

```csharp
private Vector64<double> AbsoluteCompareGreaterThanScalarTest(Vector64<double> left, Vector64<double> right)
{
  return AdvSimd.Arm64.AbsoluteCompareGreaterThanScalar(left, right);
}
// left = <11.5>
// right = <11.5>
// Result = <0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<float> AbsoluteCompareGreaterThanScalar(Vector64<float> left, Vector64<float> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.absolutecomparegreaterthanscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:AbsoluteCompareGreaterThanScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M272_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M272_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            facgt   d16, d16, d17
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M272_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=20d6feef) for method AdvSimdMethods:AbsoluteCompareGreaterThanScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 20. AbsoluteCompareGreaterThanOrEqualScalar

`Vector64<double> AbsoluteCompareGreaterThanOrEqualScalar(Vector64<double> left, Vector64<double> right)`

Performs 'AbsoluteCompareGreaterThanOrEqualScalar' operation.

```csharp
private Vector64<double> AbsoluteCompareGreaterThanOrEqualScalarTest(Vector64<double> left, Vector64<double> right)
{
  return AdvSimd.Arm64.AbsoluteCompareGreaterThanOrEqualScalar(left, right);
}
// left = <11.5>
// right = <11.5>
// Result = <NaN>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<float> AbsoluteCompareGreaterThanOrEqualScalar(Vector64<float> left, Vector64<float> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.absolutecomparegreaterthanorequalscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:AbsoluteCompareGreaterThanOrEqualScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M9889_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M9889_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            facge   d16, d16, d17
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M9889_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=7beed95e) for method AdvSimdMethods:AbsoluteCompareGreaterThanOrEqualScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 21. AbsoluteCompareLessThanScalar

`Vector64<double> AbsoluteCompareLessThanScalar(Vector64<double> left, Vector64<double> right)`

Performs 'AbsoluteCompareLessThanScalar' operation.

```csharp
private Vector64<double> AbsoluteCompareLessThanScalarTest(Vector64<double> left, Vector64<double> right)
{
  return AdvSimd.Arm64.AbsoluteCompareLessThanScalar(left, right);
}
// left = <11.5>
// right = <11.5>
// Result = <0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<float> AbsoluteCompareLessThanScalar(Vector64<float> left, Vector64<float> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.absolutecomparelessthanscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:AbsoluteCompareLessThanScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M15787_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M15787_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            facgt   d16, d17, d16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M15787_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=3c45c254) for method AdvSimdMethods:AbsoluteCompareLessThanScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 22. AbsoluteCompareLessThanOrEqualScalar

`Vector64<double> AbsoluteCompareLessThanOrEqualScalar(Vector64<double> left, Vector64<double> right)`

Performs 'AbsoluteCompareLessThanOrEqualScalar' operation.

```csharp
private Vector64<double> AbsoluteCompareLessThanOrEqualScalarTest(Vector64<double> left, Vector64<double> right)
{
  return AdvSimd.Arm64.AbsoluteCompareLessThanOrEqualScalar(left, right);
}
// left = <11.5>
// right = <11.5>
// Result = <NaN>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<float> AbsoluteCompareLessThanOrEqualScalar(Vector64<float> left, Vector64<float> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.absolutecomparelessthanorequalscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:AbsoluteCompareLessThanOrEqualScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M51258_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M51258_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            facge   d16, d17, d16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M51258_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=8c1737c5) for method AdvSimdMethods:AbsoluteCompareLessThanOrEqualScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 23. AbsoluteDifferenceScalar

`Vector64<double> AbsoluteDifferenceScalar(Vector64<double> left, Vector64<double> right)`

Performs 'AbsoluteDifferenceScalar' operation.

```csharp
private Vector64<double> AbsoluteDifferenceScalarTest(Vector64<double> left, Vector64<double> right)
{
  return AdvSimd.Arm64.AbsoluteDifferenceScalar(left, right);
}
// left = <11.5>
// right = <11.5>
// Result = <0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<float> AbsoluteDifferenceScalar(Vector64<float> left, Vector64<float> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.absolutedifferencescalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:AbsoluteDifferenceScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M577_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M577_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            fabd    d16, d16, d17
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M577_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=1291fdbe) for method AdvSimdMethods:AbsoluteDifferenceScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 24. AddAcross

`Vector64<byte> AddAcross(Vector64<byte> value)`

Performs 'AddAcross' operation.

```csharp
private Vector64<byte> AddAcrossTest(Vector64<byte> value)
{
  return AdvSimd.Arm64.AddAcross(value);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// Result = <116, 0, 0, 0, 0, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<short> AddAcross(Vector64<short> value)
Vector64<sbyte> AddAcross(Vector64<sbyte> value)
Vector64<ushort> AddAcross(Vector64<ushort> value)
Vector64<byte> AddAcross(Vector128<byte> value)
Vector64<short> AddAcross(Vector128<short> value)
Vector64<int> AddAcross(Vector128<int> value)
Vector64<sbyte> AddAcross(Vector128<sbyte> value)
Vector64<ushort> AddAcross(Vector128<ushort> value)
Vector64<uint> AddAcross(Vector128<uint> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.addacross?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:AddAcrossTest(System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M21535_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M21535_IG02:
            ldr     d16, [fp,#24]
            addv    b16, v16.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 4.50
G_M21535_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 12.20, (MethodHash=419aabe0) for method AdvSimdMethods:AddAcrossTest(System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 25. AddAcrossWidening

`Vector64<ushort> AddAcrossWidening(Vector64<byte> value)`

Performs 'AddAcrossWidening' operation.

```csharp
private Vector64<ushort> AddAcrossWideningTest(Vector64<byte> value)
{
  return AdvSimd.Arm64.AddAcrossWidening(value);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// Result = <116, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<int> AddAcrossWidening(Vector64<short> value)
Vector64<short> AddAcrossWidening(Vector64<sbyte> value)
Vector64<uint> AddAcrossWidening(Vector64<ushort> value)
Vector64<ushort> AddAcrossWidening(Vector128<byte> value)
Vector64<int> AddAcrossWidening(Vector128<short> value)
Vector64<long> AddAcrossWidening(Vector128<int> value)
Vector64<short> AddAcrossWidening(Vector128<sbyte> value)
Vector64<uint> AddAcrossWidening(Vector128<ushort> value)
Vector64<ulong> AddAcrossWidening(Vector128<uint> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.addacrosswidening?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:AddAcrossWideningTest(System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[UInt16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M45669_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M45669_IG02:
            ldr     d16, [fp,#24]
            uaddlv  h16, v16.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 4.50
G_M45669_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 12.20, (MethodHash=55d74d9a) for method AdvSimdMethods:AddAcrossWideningTest(System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[UInt16]
; ============================================================


```
------------------------------------------------

### 26. AddPairwiseScalar

`Vector64<float> AddPairwiseScalar(Vector64<float> value)`

Performs 'AddPairwiseScalar' operation.

```csharp
private Vector64<float> AddPairwiseScalarTest(Vector64<float> value)
{
  return AdvSimd.Arm64.AddPairwiseScalar(value);
}
// value = <11.5, 12.5>
// Result = <24, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<double> AddPairwiseScalar(Vector128<double> value)
Vector64<long> AddPairwiseScalar(Vector128<long> value)
Vector64<ulong> AddPairwiseScalar(Vector128<ulong> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.addpairwisescalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:AddPairwiseScalarTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M40460_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M40460_IG02:
            ldr     d16, [fp,#24]
            faddp   s16, v16.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M40460_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=481d61f3) for method AdvSimdMethods:AddPairwiseScalarTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 27. CompareEqualScalar

`Vector64<double> CompareEqualScalar(Vector64<double> left, Vector64<double> right)`

Performs 'CompareEqualScalar' operation.

```csharp
private Vector64<double> CompareEqualScalarTest(Vector64<double> left, Vector64<double> right)
{
  return AdvSimd.Arm64.CompareEqualScalar(left, right);
}
// left = <11.5>
// right = <11.5>
// Result = <NaN>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<long> CompareEqualScalar(Vector64<long> left, Vector64<long> right)
Vector64<float> CompareEqualScalar(Vector64<float> left, Vector64<float> right)
Vector64<ulong> CompareEqualScalar(Vector64<ulong> left, Vector64<ulong> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.compareequalscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:CompareEqualScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M34922_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M34922_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            fcmeq   d16, d16, d17
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M34922_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=10297795) for method AdvSimdMethods:CompareEqualScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 28. CompareGreaterThanScalar

`Vector64<double> CompareGreaterThanScalar(Vector64<double> left, Vector64<double> right)`

Performs 'CompareGreaterThanScalar' operation.

```csharp
private Vector64<double> CompareGreaterThanScalarTest(Vector64<double> left, Vector64<double> right)
{
  return AdvSimd.Arm64.CompareGreaterThanScalar(left, right);
}
// left = <11.5>
// right = <11.5>
// Result = <0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<long> CompareGreaterThanScalar(Vector64<long> left, Vector64<long> right)
Vector64<float> CompareGreaterThanScalar(Vector64<float> left, Vector64<float> right)
Vector64<ulong> CompareGreaterThanScalar(Vector64<ulong> left, Vector64<ulong> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.comparegreaterthanscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:CompareGreaterThanScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M21031_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M21031_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            fcmgt   d16, d16, d17
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M21031_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=4436add8) for method AdvSimdMethods:CompareGreaterThanScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 29. CompareGreaterThanOrEqualScalar

`Vector64<double> CompareGreaterThanOrEqualScalar(Vector64<double> left, Vector64<double> right)`

Performs 'CompareGreaterThanOrEqualScalar' operation.

```csharp
private Vector64<double> CompareGreaterThanOrEqualScalarTest(Vector64<double> left, Vector64<double> right)
{
  return AdvSimd.Arm64.CompareGreaterThanOrEqualScalar(left, right);
}
// left = <11.5>
// right = <11.5>
// Result = <NaN>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<long> CompareGreaterThanOrEqualScalar(Vector64<long> left, Vector64<long> right)
Vector64<float> CompareGreaterThanOrEqualScalar(Vector64<float> left, Vector64<float> right)
Vector64<ulong> CompareGreaterThanOrEqualScalar(Vector64<ulong> left, Vector64<ulong> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.comparegreaterthanorequalscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:CompareGreaterThanOrEqualScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M55350_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M55350_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            fcmge   d16, d16, d17
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M55350_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=160c27c9) for method AdvSimdMethods:CompareGreaterThanOrEqualScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 30. CompareLessThanScalar

`Vector64<double> CompareLessThanScalar(Vector64<double> left, Vector64<double> right)`

Performs 'CompareLessThanScalar' operation.

```csharp
private Vector64<double> CompareLessThanScalarTest(Vector64<double> left, Vector64<double> right)
{
  return AdvSimd.Arm64.CompareLessThanScalar(left, right);
}
// left = <11.5>
// right = <11.5>
// Result = <0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<long> CompareLessThanScalar(Vector64<long> left, Vector64<long> right)
Vector64<float> CompareLessThanScalar(Vector64<float> left, Vector64<float> right)
Vector64<ulong> CompareLessThanScalar(Vector64<ulong> left, Vector64<ulong> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.comparelessthanscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:CompareLessThanScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M22780_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M22780_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            fcmgt   d16, d17, d16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M22780_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=e690a703) for method AdvSimdMethods:CompareLessThanScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 31. CompareLessThanOrEqualScalar

`Vector64<double> CompareLessThanOrEqualScalar(Vector64<double> left, Vector64<double> right)`

Performs 'CompareLessThanOrEqualScalar' operation.

```csharp
private Vector64<double> CompareLessThanOrEqualScalarTest(Vector64<double> left, Vector64<double> right)
{
  return AdvSimd.Arm64.CompareLessThanOrEqualScalar(left, right);
}
// left = <11.5>
// right = <11.5>
// Result = <NaN>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<long> CompareLessThanOrEqualScalar(Vector64<long> left, Vector64<long> right)
Vector64<float> CompareLessThanOrEqualScalar(Vector64<float> left, Vector64<float> right)
Vector64<ulong> CompareLessThanOrEqualScalar(Vector64<ulong> left, Vector64<ulong> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.comparelessthanorequalscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:CompareLessThanOrEqualScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M54221_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M54221_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            fcmge   d16, d17, d16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M54221_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=b9eb2c32) for method AdvSimdMethods:CompareLessThanOrEqualScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 32. CompareTestScalar

`Vector64<double> CompareTestScalar(Vector64<double> left, Vector64<double> right)`

Performs 'CompareTestScalar' operation.

```csharp
private Vector64<double> CompareTestScalarTest(Vector64<double> left, Vector64<double> right)
{
  return AdvSimd.Arm64.CompareTestScalar(left, right);
}
// left = <11.5>
// right = <11.5>
// Result = <NaN>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<long> CompareTestScalar(Vector64<long> left, Vector64<long> right)
Vector64<ulong> CompareTestScalar(Vector64<ulong> left, Vector64<ulong> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.comparetestscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:CompareTestScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M62576_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M62576_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            cmtst   d16, d16, d17
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M62576_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=e75e0b8f) for method AdvSimdMethods:CompareTestScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 33. ConvertToDouble

`Vector128<double> ConvertToDouble(Vector64<float> value)`

Performs 'ConvertToDouble' operation.

```csharp
private Vector128<double> ConvertToDoubleTest(Vector64<float> value)
{
  return AdvSimd.Arm64.ConvertToDouble(value);
}
// value = <11.5, 12.5>
// Result = <11.5, 12.5>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> ConvertToDouble(Vector128<long> value)
Vector128<double> ConvertToDouble(Vector128<ulong> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.converttodouble?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ConvertToDoubleTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector128`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M54030_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M54030_IG02:
            ldr     d16, [fp,#24]
            fcvtl   v16.2d, v16.2s
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 5.50
G_M54030_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=6e162cf1) for method AdvSimdMethods:ConvertToDoubleTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector128`1[Double]
; ============================================================


```
------------------------------------------------

### 34. ConvertToDoubleScalar

`Vector64<double> ConvertToDoubleScalar(Vector64<long> value)`

Performs 'ConvertToDoubleScalar' operation.

```csharp
private Vector64<double> ConvertToDoubleScalarTest(Vector64<long> value)
{
  return AdvSimd.Arm64.ConvertToDoubleScalar(value);
}
// value = <11>
// Result = <11>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<double> ConvertToDoubleScalar(Vector64<ulong> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.converttodoublescalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ConvertToDoubleScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M20306_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M20306_IG02:
            ldr     d16, [fp,#24]
            scvtf   d16, d16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 4.50
G_M20306_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 12.20, (MethodHash=4fc6b0ad) for method AdvSimdMethods:ConvertToDoubleScalarTest(System.Runtime.Intrinsics.Vector64`1[Int64]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 35. ConvertToDoubleUpper

`Vector128<double> ConvertToDoubleUpper(Vector128<float> value)`

Performs 'ConvertToDoubleUpper' operation.

```csharp
private Vector128<double> ConvertToDoubleUpperTest(Vector128<float> value)
{
  return AdvSimd.Arm64.ConvertToDoubleUpper(value);
}
// value = <11.5, 12.5, 13.5, 14.5>
// Result = <13.5, 14.5>

```



See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.converttodoubleupper?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ConvertToDoubleUpperTest(System.Runtime.Intrinsics.Vector128`1[Single]):System.Runtime.Intrinsics.Vector128`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M25717_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     q0, [fp,#16]
						;; bbWeight=1    PerfScore 2.50
G_M25717_IG02:
            ldr     q16, [fp,#16]
            fcvtl2  v16.2d, v16.4s
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 5.50
G_M25717_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=445a9b8a) for method AdvSimdMethods:ConvertToDoubleUpperTest(System.Runtime.Intrinsics.Vector128`1[Single]):System.Runtime.Intrinsics.Vector128`1[Double]
; ============================================================


```
------------------------------------------------

### 36. ConvertToInt64RoundAwayFromZero

`Vector128<long> ConvertToInt64RoundAwayFromZero(Vector128<double> value)`

Performs 'ConvertToInt64RoundAwayFromZero' operation.

```csharp
private Vector128<long> ConvertToInt64RoundAwayFromZeroTest(Vector128<double> value)
{
  return AdvSimd.Arm64.ConvertToInt64RoundAwayFromZero(value);
}
// value = <11.5, 12.5>
// Result = <12, 13>

```



See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.converttoint64roundawayfromzero?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ConvertToInt64RoundAwayFromZeroTest(System.Runtime.Intrinsics.Vector128`1[Double]):System.Runtime.Intrinsics.Vector128`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M48608_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     q0, [fp,#16]
						;; bbWeight=1    PerfScore 2.50
G_M48608_IG02:
            ldr     q16, [fp,#16]
            fcvtas  v16.2d, v16.2d
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 5.50
G_M48608_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=93cb421f) for method AdvSimdMethods:ConvertToInt64RoundAwayFromZeroTest(System.Runtime.Intrinsics.Vector128`1[Double]):System.Runtime.Intrinsics.Vector128`1[Int64]
; ============================================================


```
------------------------------------------------

### 37. ConvertToInt64RoundAwayFromZeroScalar

`Vector64<long> ConvertToInt64RoundAwayFromZeroScalar(Vector64<double> value)`

Performs 'ConvertToInt64RoundAwayFromZeroScalar' operation.

```csharp
private Vector64<long> ConvertToInt64RoundAwayFromZeroScalarTest(Vector64<double> value)
{
  return AdvSimd.Arm64.ConvertToInt64RoundAwayFromZeroScalar(value);
}
// value = <11.5>
// Result = <12>

```



See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.converttoint64roundawayfromzeroscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ConvertToInt64RoundAwayFromZeroScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M39342_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M39342_IG02:
            ldr     d16, [fp,#24]
            fcvtas  d16, d16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 4.50
G_M39342_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 12.20, (MethodHash=34f96651) for method AdvSimdMethods:ConvertToInt64RoundAwayFromZeroScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Int64]
; ============================================================


```
------------------------------------------------

### 38. ConvertToInt64RoundToEven

`Vector128<long> ConvertToInt64RoundToEven(Vector128<double> value)`

Performs 'ConvertToInt64RoundToEven' operation.

```csharp
private Vector128<long> ConvertToInt64RoundToEvenTest(Vector128<double> value)
{
  return AdvSimd.Arm64.ConvertToInt64RoundToEven(value);
}
// value = <11.5, 12.5>
// Result = <12, 12>

```



See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.converttoint64roundtoeven?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ConvertToInt64RoundToEvenTest(System.Runtime.Intrinsics.Vector128`1[Double]):System.Runtime.Intrinsics.Vector128`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M22841_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     q0, [fp,#16]
						;; bbWeight=1    PerfScore 2.50
G_M22841_IG02:
            ldr     q16, [fp,#16]
            fcvtns  v16.2d, v16.2d
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 5.50
G_M22841_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=2fbda6c6) for method AdvSimdMethods:ConvertToInt64RoundToEvenTest(System.Runtime.Intrinsics.Vector128`1[Double]):System.Runtime.Intrinsics.Vector128`1[Int64]
; ============================================================


```
------------------------------------------------

### 39. ConvertToInt64RoundToEvenScalar

`Vector64<long> ConvertToInt64RoundToEvenScalar(Vector64<double> value)`

Performs 'ConvertToInt64RoundToEvenScalar' operation.

```csharp
private Vector64<long> ConvertToInt64RoundToEvenScalarTest(Vector64<double> value)
{
  return AdvSimd.Arm64.ConvertToInt64RoundToEvenScalar(value);
}
// value = <11.5>
// Result = <12>

```



See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.converttoint64roundtoevenscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ConvertToInt64RoundToEvenScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M25271_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M25271_IG02:
            ldr     d16, [fp,#24]
            fcvtns  d16, d16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 4.50
G_M25271_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 12.20, (MethodHash=de6e9d48) for method AdvSimdMethods:ConvertToInt64RoundToEvenScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Int64]
; ============================================================


```
------------------------------------------------

### 40. ConvertToInt64RoundToNegativeInfinity

`Vector128<long> ConvertToInt64RoundToNegativeInfinity(Vector128<double> value)`

Performs 'ConvertToInt64RoundToNegativeInfinity' operation.

```csharp
private Vector128<long> ConvertToInt64RoundToNegativeInfinityTest(Vector128<double> value)
{
  return AdvSimd.Arm64.ConvertToInt64RoundToNegativeInfinity(value);
}
// value = <11.5, 12.5>
// Result = <11, 12>

```



See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.converttoint64roundtonegativeinfinity?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ConvertToInt64RoundToNegativeInfinityTest(System.Runtime.Intrinsics.Vector128`1[Double]):System.Runtime.Intrinsics.Vector128`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M256_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     q0, [fp,#16]
						;; bbWeight=1    PerfScore 2.50
G_M256_IG02:
            ldr     q16, [fp,#16]
            fcvtms  v16.2d, v16.2d
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 5.50
G_M256_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=c9a0feff) for method AdvSimdMethods:ConvertToInt64RoundToNegativeInfinityTest(System.Runtime.Intrinsics.Vector128`1[Double]):System.Runtime.Intrinsics.Vector128`1[Int64]
; ============================================================


```
------------------------------------------------

### 41. ConvertToInt64RoundToNegativeInfinityScalar

`Vector64<long> ConvertToInt64RoundToNegativeInfinityScalar(Vector64<double> value)`

Performs 'ConvertToInt64RoundToNegativeInfinityScalar' operation.

```csharp
private Vector64<long> ConvertToInt64RoundToNegativeInfinityScalarTest(Vector64<double> value)
{
  return AdvSimd.Arm64.ConvertToInt64RoundToNegativeInfinityScalar(value);
}
// value = <11.5>
// Result = <11>

```



See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.converttoint64roundtonegativeinfinityscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ConvertToInt64RoundToNegativeInfinityScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M65038_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M65038_IG02:
            ldr     d16, [fp,#24]
            fcvtms  d16, d16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 4.50
G_M65038_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 12.20, (MethodHash=8f3f01f1) for method AdvSimdMethods:ConvertToInt64RoundToNegativeInfinityScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Int64]
; ============================================================


```
------------------------------------------------

### 42. ConvertToInt64RoundToPositiveInfinity

`Vector128<long> ConvertToInt64RoundToPositiveInfinity(Vector128<double> value)`

Performs 'ConvertToInt64RoundToPositiveInfinity' operation.

```csharp
private Vector128<long> ConvertToInt64RoundToPositiveInfinityTest(Vector128<double> value)
{
  return AdvSimd.Arm64.ConvertToInt64RoundToPositiveInfinity(value);
}
// value = <11.5, 12.5>
// Result = <12, 13>

```



See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.converttoint64roundtopositiveinfinity?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ConvertToInt64RoundToPositiveInfinityTest(System.Runtime.Intrinsics.Vector128`1[Double]):System.Runtime.Intrinsics.Vector128`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M21448_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     q0, [fp,#16]
						;; bbWeight=1    PerfScore 2.50
G_M21448_IG02:
            ldr     q16, [fp,#16]
            fcvtps  v16.2d, v16.2d
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 5.50
G_M21448_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=ff90ac37) for method AdvSimdMethods:ConvertToInt64RoundToPositiveInfinityTest(System.Runtime.Intrinsics.Vector128`1[Double]):System.Runtime.Intrinsics.Vector128`1[Int64]
; ============================================================


```
------------------------------------------------

### 43. ConvertToInt64RoundToPositiveInfinityScalar

`Vector64<long> ConvertToInt64RoundToPositiveInfinityScalar(Vector64<double> value)`

Performs 'ConvertToInt64RoundToPositiveInfinityScalar' operation.

```csharp
private Vector64<long> ConvertToInt64RoundToPositiveInfinityScalarTest(Vector64<double> value)
{
  return AdvSimd.Arm64.ConvertToInt64RoundToPositiveInfinityScalar(value);
}
// value = <11.5>
// Result = <12>

```



See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.converttoint64roundtopositiveinfinityscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ConvertToInt64RoundToPositiveInfinityScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M11974_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M11974_IG02:
            ldr     d16, [fp,#24]
            fcvtps  d16, d16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 4.50
G_M11974_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 12.20, (MethodHash=a695d139) for method AdvSimdMethods:ConvertToInt64RoundToPositiveInfinityScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Int64]
; ============================================================


```
------------------------------------------------

### 44. ConvertToInt64RoundToZero

`Vector128<long> ConvertToInt64RoundToZero(Vector128<double> value)`

Performs 'ConvertToInt64RoundToZero' operation.

```csharp
private Vector128<long> ConvertToInt64RoundToZeroTest(Vector128<double> value)
{
  return AdvSimd.Arm64.ConvertToInt64RoundToZero(value);
}
// value = <11.5, 12.5>
// Result = <11, 12>

```



See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.converttoint64roundtozero?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ConvertToInt64RoundToZeroTest(System.Runtime.Intrinsics.Vector128`1[Double]):System.Runtime.Intrinsics.Vector128`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M34083_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     q0, [fp,#16]
						;; bbWeight=1    PerfScore 2.50
G_M34083_IG02:
            ldr     q16, [fp,#16]
            fcvtzs  v16.2d, v16.2d
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 5.50
G_M34083_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=72637adc) for method AdvSimdMethods:ConvertToInt64RoundToZeroTest(System.Runtime.Intrinsics.Vector128`1[Double]):System.Runtime.Intrinsics.Vector128`1[Int64]
; ============================================================


```
------------------------------------------------

### 45. ConvertToInt64RoundToZeroScalar

`Vector64<long> ConvertToInt64RoundToZeroScalar(Vector64<double> value)`

Performs 'ConvertToInt64RoundToZeroScalar' operation.

```csharp
private Vector64<long> ConvertToInt64RoundToZeroScalarTest(Vector64<double> value)
{
  return AdvSimd.Arm64.ConvertToInt64RoundToZeroScalar(value);
}
// value = <11.5>
// Result = <11>

```



See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.converttoint64roundtozeroscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ConvertToInt64RoundToZeroScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Int64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M53677_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M53677_IG02:
            ldr     d16, [fp,#24]
            fcvtzs  d16, d16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 4.50
G_M53677_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 12.20, (MethodHash=b3b72e52) for method AdvSimdMethods:ConvertToInt64RoundToZeroScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Int64]
; ============================================================


```
------------------------------------------------

### 46. ConvertToSingleLower

`Vector64<float> ConvertToSingleLower(Vector128<double> value)`

Performs 'ConvertToSingleLower' operation.

```csharp
private Vector64<float> ConvertToSingleLowerTest(Vector128<double> value)
{
  return AdvSimd.Arm64.ConvertToSingleLower(value);
}
// value = <11.5, 12.5>
// Result = <11.5, 12.5>

```



See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.converttosinglelower?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ConvertToSingleLowerTest(System.Runtime.Intrinsics.Vector128`1[Double]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M47778_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     q0, [fp,#16]
						;; bbWeight=1    PerfScore 2.50
G_M47778_IG02:
            ldr     q16, [fp,#16]
            fcvtn   v16.2s, v16.2d
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M47778_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=fd84455d) for method AdvSimdMethods:ConvertToSingleLowerTest(System.Runtime.Intrinsics.Vector128`1[Double]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 47. ConvertToSingleRoundToOddLower

`Vector64<float> ConvertToSingleRoundToOddLower(Vector128<double> value)`

Performs 'ConvertToSingleRoundToOddLower' operation.

```csharp
private Vector64<float> ConvertToSingleRoundToOddLowerTest(Vector128<double> value)
{
  return AdvSimd.Arm64.ConvertToSingleRoundToOddLower(value);
}
// value = <11.5, 12.5>
// Result = <11.5, 12.5>

```



See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.converttosingleroundtooddlower?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ConvertToSingleRoundToOddLowerTest(System.Runtime.Intrinsics.Vector128`1[Double]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M9300_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     q0, [fp,#16]
						;; bbWeight=1    PerfScore 2.50
G_M9300_IG02:
            ldr     q16, [fp,#16]
            fcvtxn  v16.2s, v16.2d
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M9300_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=cbc2dbab) for method AdvSimdMethods:ConvertToSingleRoundToOddLowerTest(System.Runtime.Intrinsics.Vector128`1[Double]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 48. ConvertToSingleRoundToOddUpper

`Vector128<float> ConvertToSingleRoundToOddUpper(Vector64<float> lower, Vector128<double> value)`

Performs 'ConvertToSingleRoundToOddUpper' operation.

```csharp
private Vector128<float> ConvertToSingleRoundToOddUpperTest(Vector64<float> lower, Vector128<double> value)
{
  return AdvSimd.Arm64.ConvertToSingleRoundToOddUpper(lower, value);
}
// lower = <11.5, 12.5>
// value = <11.5, 12.5>
// Result = <11.5, 12.5, 11.5, 12.5>

```



See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.converttosingleroundtooddupper?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ConvertToSingleRoundToOddUpperTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector128`1[Double]):System.Runtime.Intrinsics.Vector128`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M32525_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     q1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M32525_IG02:
            ldr     d16, [fp,#40]
            ldr     q17, [fp,#16]
            fcvtxn2 v16.4s, v17.2d
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 7.50
G_M32525_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=757680f2) for method AdvSimdMethods:ConvertToSingleRoundToOddUpperTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector128`1[Double]):System.Runtime.Intrinsics.Vector128`1[Single]
; ============================================================


```
------------------------------------------------

### 49. ConvertToSingleUpper

`Vector128<float> ConvertToSingleUpper(Vector64<float> lower, Vector128<double> value)`

Performs 'ConvertToSingleUpper' operation.

```csharp
private Vector128<float> ConvertToSingleUpperTest(Vector64<float> lower, Vector128<double> value)
{
  return AdvSimd.Arm64.ConvertToSingleUpper(lower, value);
}
// lower = <11.5, 12.5>
// value = <11.5, 12.5>
// Result = <11.5, 12.5, 11.5, 12.5>

```



See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.converttosingleupper?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ConvertToSingleUpperTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector128`1[Double]):System.Runtime.Intrinsics.Vector128`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M32699_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     q1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M32699_IG02:
            ldr     d16, [fp,#40]
            ldr     q17, [fp,#16]
            fcvtn2  v16.4s, v17.2d
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 7.50
G_M32699_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=09b18044) for method AdvSimdMethods:ConvertToSingleUpperTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector128`1[Double]):System.Runtime.Intrinsics.Vector128`1[Single]
; ============================================================


```
------------------------------------------------

### 50. ConvertToUInt64RoundAwayFromZero

`Vector128<ulong> ConvertToUInt64RoundAwayFromZero(Vector128<double> value)`

Performs 'ConvertToUInt64RoundAwayFromZero' operation.

```csharp
private Vector128<ulong> ConvertToUInt64RoundAwayFromZeroTest(Vector128<double> value)
{
  return AdvSimd.Arm64.ConvertToUInt64RoundAwayFromZero(value);
}
// value = <11.5, 12.5>
// Result = <12, 13>

```



See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.converttouint64roundawayfromzero?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ConvertToUInt64RoundAwayFromZeroTest(System.Runtime.Intrinsics.Vector128`1[Double]):System.Runtime.Intrinsics.Vector128`1[UInt64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M63808_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     q0, [fp,#16]
						;; bbWeight=1    PerfScore 2.50
G_M63808_IG02:
            ldr     q16, [fp,#16]
            fcvtau  v16.2d, v16.2d
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 5.50
G_M63808_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=e3b206bf) for method AdvSimdMethods:ConvertToUInt64RoundAwayFromZeroTest(System.Runtime.Intrinsics.Vector128`1[Double]):System.Runtime.Intrinsics.Vector128`1[UInt64]
; ============================================================


```
------------------------------------------------

### 51. ConvertToUInt64RoundAwayFromZeroScalar

`Vector64<ulong> ConvertToUInt64RoundAwayFromZeroScalar(Vector64<double> value)`

Performs 'ConvertToUInt64RoundAwayFromZeroScalar' operation.

```csharp
private Vector64<ulong> ConvertToUInt64RoundAwayFromZeroScalarTest(Vector64<double> value)
{
  return AdvSimd.Arm64.ConvertToUInt64RoundAwayFromZeroScalar(value);
}
// value = <11.5>
// Result = <12>

```



See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.converttouint64roundawayfromzeroscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ConvertToUInt64RoundAwayFromZeroScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[UInt64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M46670_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M46670_IG02:
            ldr     d16, [fp,#24]
            fcvtau  d16, d16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 4.50
G_M46670_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 12.20, (MethodHash=985c49b1) for method AdvSimdMethods:ConvertToUInt64RoundAwayFromZeroScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[UInt64]
; ============================================================


```
------------------------------------------------

### 52. ConvertToUInt64RoundToEven

`Vector128<ulong> ConvertToUInt64RoundToEven(Vector128<double> value)`

Performs 'ConvertToUInt64RoundToEven' operation.

```csharp
private Vector128<ulong> ConvertToUInt64RoundToEvenTest(Vector128<double> value)
{
  return AdvSimd.Arm64.ConvertToUInt64RoundToEven(value);
}
// value = <11.5, 12.5>
// Result = <12, 12>

```



See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.converttouint64roundtoeven?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ConvertToUInt64RoundToEvenTest(System.Runtime.Intrinsics.Vector128`1[Double]):System.Runtime.Intrinsics.Vector128`1[UInt64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M55737_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     q0, [fp,#16]
						;; bbWeight=1    PerfScore 2.50
G_M55737_IG02:
            ldr     q16, [fp,#16]
            fcvtnu  v16.2d, v16.2d
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 5.50
G_M55737_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=ea672646) for method AdvSimdMethods:ConvertToUInt64RoundToEvenTest(System.Runtime.Intrinsics.Vector128`1[Double]):System.Runtime.Intrinsics.Vector128`1[UInt64]
; ============================================================


```
------------------------------------------------

### 53. ConvertToUInt64RoundToEvenScalar

`Vector64<ulong> ConvertToUInt64RoundToEvenScalar(Vector64<double> value)`

Performs 'ConvertToUInt64RoundToEvenScalar' operation.

```csharp
private Vector64<ulong> ConvertToUInt64RoundToEvenScalarTest(Vector64<double> value)
{
  return AdvSimd.Arm64.ConvertToUInt64RoundToEvenScalar(value);
}
// value = <11.5>
// Result = <12>

```



See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.converttouint64roundtoevenscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ConvertToUInt64RoundToEvenScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[UInt64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M59639_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M59639_IG02:
            ldr     d16, [fp,#24]
            fcvtnu  d16, d16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 4.50
G_M59639_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 12.20, (MethodHash=0cd31708) for method AdvSimdMethods:ConvertToUInt64RoundToEvenScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[UInt64]
; ============================================================


```
------------------------------------------------

### 54. ConvertToUInt64RoundToNegativeInfinity

`Vector128<ulong> ConvertToUInt64RoundToNegativeInfinity(Vector128<double> value)`

Performs 'ConvertToUInt64RoundToNegativeInfinity' operation.

```csharp
private Vector128<ulong> ConvertToUInt64RoundToNegativeInfinityTest(Vector128<double> value)
{
  return AdvSimd.Arm64.ConvertToUInt64RoundToNegativeInfinity(value);
}
// value = <11.5, 12.5>
// Result = <11, 12>

```



See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.converttouint64roundtonegativeinfinity?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ConvertToUInt64RoundToNegativeInfinityTest(System.Runtime.Intrinsics.Vector128`1[Double]):System.Runtime.Intrinsics.Vector128`1[UInt64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M58016_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     q0, [fp,#16]
						;; bbWeight=1    PerfScore 2.50
G_M58016_IG02:
            ldr     q16, [fp,#16]
            fcvtmu  v16.2d, v16.2d
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 5.50
G_M58016_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=96581d5f) for method AdvSimdMethods:ConvertToUInt64RoundToNegativeInfinityTest(System.Runtime.Intrinsics.Vector128`1[Double]):System.Runtime.Intrinsics.Vector128`1[UInt64]
; ============================================================


```
------------------------------------------------

### 55. ConvertToUInt64RoundToNegativeInfinityScalar

`Vector64<ulong> ConvertToUInt64RoundToNegativeInfinityScalar(Vector64<double> value)`

Performs 'ConvertToUInt64RoundToNegativeInfinityScalar' operation.

```csharp
private Vector64<ulong> ConvertToUInt64RoundToNegativeInfinityScalarTest(Vector64<double> value)
{
  return AdvSimd.Arm64.ConvertToUInt64RoundToNegativeInfinityScalar(value);
}
// value = <11.5>
// Result = <11>

```



See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.converttouint64roundtonegativeinfinityscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ConvertToUInt64RoundToNegativeInfinityScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[UInt64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M23662_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M23662_IG02:
            ldr     d16, [fp,#24]
            fcvtmu  d16, d16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 4.50
G_M23662_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 12.20, (MethodHash=5a6ea391) for method AdvSimdMethods:ConvertToUInt64RoundToNegativeInfinityScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[UInt64]
; ============================================================


```
------------------------------------------------

### 56. ConvertToUInt64RoundToPositiveInfinity

`Vector128<ulong> ConvertToUInt64RoundToPositiveInfinity(Vector128<double> value)`

Performs 'ConvertToUInt64RoundToPositiveInfinity' operation.

```csharp
private Vector128<ulong> ConvertToUInt64RoundToPositiveInfinityTest(Vector128<double> value)
{
  return AdvSimd.Arm64.ConvertToUInt64RoundToPositiveInfinity(value);
}
// value = <11.5, 12.5>
// Result = <12, 13>

```



See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.converttouint64roundtopositiveinfinity?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ConvertToUInt64RoundToPositiveInfinityTest(System.Runtime.Intrinsics.Vector128`1[Double]):System.Runtime.Intrinsics.Vector128`1[UInt64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M57576_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     q0, [fp,#16]
						;; bbWeight=1    PerfScore 2.50
G_M57576_IG02:
            ldr     q16, [fp,#16]
            fcvtpu  v16.2d, v16.2d
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 5.50
G_M57576_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=ede01f17) for method AdvSimdMethods:ConvertToUInt64RoundToPositiveInfinityTest(System.Runtime.Intrinsics.Vector128`1[Double]):System.Runtime.Intrinsics.Vector128`1[UInt64]
; ============================================================


```
------------------------------------------------

### 57. ConvertToUInt64RoundToPositiveInfinityScalar

`Vector64<ulong> ConvertToUInt64RoundToPositiveInfinityScalar(Vector64<double> value)`

Performs 'ConvertToUInt64RoundToPositiveInfinityScalar' operation.

```csharp
private Vector64<ulong> ConvertToUInt64RoundToPositiveInfinityScalarTest(Vector64<double> value)
{
  return AdvSimd.Arm64.ConvertToUInt64RoundToPositiveInfinityScalar(value);
}
// value = <11.5>
// Result = <12>

```



See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.converttouint64roundtopositiveinfinityscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ConvertToUInt64RoundToPositiveInfinityScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[UInt64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M64422_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M64422_IG02:
            ldr     d16, [fp,#24]
            fcvtpu  d16, d16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 4.50
G_M64422_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 12.20, (MethodHash=45c10459) for method AdvSimdMethods:ConvertToUInt64RoundToPositiveInfinityScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[UInt64]
; ============================================================


```
------------------------------------------------

### 58. ConvertToUInt64RoundToZero

`Vector128<ulong> ConvertToUInt64RoundToZero(Vector128<double> value)`

Performs 'ConvertToUInt64RoundToZero' operation.

```csharp
private Vector128<ulong> ConvertToUInt64RoundToZeroTest(Vector128<double> value)
{
  return AdvSimd.Arm64.ConvertToUInt64RoundToZero(value);
}
// value = <11.5, 12.5>
// Result = <11, 12>

```



See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.converttouint64roundtozero?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ConvertToUInt64RoundToZeroTest(System.Runtime.Intrinsics.Vector128`1[Double]):System.Runtime.Intrinsics.Vector128`1[UInt64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M62819_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     q0, [fp,#16]
						;; bbWeight=1    PerfScore 2.50
G_M62819_IG02:
            ldr     q16, [fp,#16]
            fcvtzu  v16.2d, v16.2d
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 5.50
G_M62819_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=f7a00a9c) for method AdvSimdMethods:ConvertToUInt64RoundToZeroTest(System.Runtime.Intrinsics.Vector128`1[Double]):System.Runtime.Intrinsics.Vector128`1[UInt64]
; ============================================================


```
------------------------------------------------

### 59. ConvertToUInt64RoundToZeroScalar

`Vector64<ulong> ConvertToUInt64RoundToZeroScalar(Vector64<double> value)`

Performs 'ConvertToUInt64RoundToZeroScalar' operation.

```csharp
private Vector64<ulong> ConvertToUInt64RoundToZeroScalarTest(Vector64<double> value)
{
  return AdvSimd.Arm64.ConvertToUInt64RoundToZeroScalar(value);
}
// value = <11.5>
// Result = <11>

```



See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.converttouint64roundtozeroscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ConvertToUInt64RoundToZeroScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[UInt64]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M16685_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M16685_IG02:
            ldr     d16, [fp,#24]
            fcvtzu  d16, d16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 4.50
G_M16685_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 12.20, (MethodHash=1d66bed2) for method AdvSimdMethods:ConvertToUInt64RoundToZeroScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[UInt64]
; ============================================================


```
------------------------------------------------

### 60. Divide

`Vector64<float> Divide(Vector64<float> left, Vector64<float> right)`

Performs 'Divide' operation.

```csharp
private Vector64<float> DivideTest(Vector64<float> left, Vector64<float> right)
{
  return AdvSimd.Arm64.Divide(left, right);
}
// left = <11.5, 12.5>
// right = <21.5, 22.5>
// Result = <0.53488374, 0.5555556>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> Divide(Vector128<double> left, Vector128<double> right)
Vector128<float> Divide(Vector128<float> left, Vector128<float> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.divide?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:DivideTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M34451_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M34451_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            fdiv    v16.2s, v16.2s, v17.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 16.50
G_M34451_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 26.00, (MethodHash=e00e796c) for method AdvSimdMethods:DivideTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================

```

---
STARTlayout:post
title: Hardware Intrinsics APIs for ARM64 - Part 6
subtitle: With examples
tags: [work, arm64, intrinsics]
---

### Introduction

In my [last post](../2019-01-01-Vectorization-APIs), I describe SIMD datatypes `Vector64<T>` and `Vector128<T>` that operates on 'hardware intrisic' APIs. In this post I will describe the intrinsic APIs for ARM64 and how you can use them to optimize your code if you are writing a .NET API targetting ARM64. This is 3 post series TODO.


### API list

[ExtractNarrowingSaturateScalar](#1-extractnarrowingsaturatescalar), [ExtractNarrowingSaturateUnsignedScalar](#2-extractnarrowingsaturateunsignedscalar), [FusedMultiplyAddByScalar](#3-fusedmultiplyaddbyscalar), [FusedMultiplyAddBySelectedScalar](#4-fusedmultiplyaddbyselectedscalar), [FusedMultiplyAddScalarBySelectedScalar](#5-fusedmultiplyaddscalarbyselectedscalar), [FusedMultiplySubtractByScalar](#6-fusedmultiplysubtractbyscalar), [FusedMultiplySubtractBySelectedScalar](#7-fusedmultiplysubtractbyselectedscalar), [FusedMultiplySubtractScalarBySelectedScalar](#8-fusedmultiplysubtractscalarbyselectedscalar), [InsertSelectedScalar](#9-insertselectedscalar), [MaxAcross](#10-maxacross), [MaxNumberAcross](#11-maxnumberacross), [MaxNumberPairwise](#12-maxnumberpairwise), [MaxNumberPairwiseScalar](#13-maxnumberpairwisescalar), [MaxPairwiseScalar](#14-maxpairwisescalar), [MaxScalar](#15-maxscalar), [MinAcross](#16-minacross), [MinNumberAcross](#17-minnumberacross), [MinNumberPairwise](#18-minnumberpairwise), [MinNumberPairwiseScalar](#19-minnumberpairwisescalar), [MinPairwiseScalar](#20-minpairwisescalar), [MinScalar](#21-minscalar), [MultiplyDoublingSaturateHighScalar](#22-multiplydoublingsaturatehighscalar), [MultiplyDoublingScalarBySelectedScalarSaturateHigh](#23-multiplydoublingscalarbyselectedscalarsaturatehigh), [MultiplyDoublingWideningAndAddSaturateScalar](#24-multiplydoublingwideningandaddsaturatescalar), [MultiplyDoublingWideningAndSubtractSaturateScalar](#25-multiplydoublingwideningandsubtractsaturatescalar), [MultiplyDoublingWideningSaturateScalar](#26-multiplydoublingwideningsaturatescalar), [MultiplyDoublingWideningSaturateScalarBySelectedScalar](#27-multiplydoublingwideningsaturatescalarbyselectedscalar), [MultiplyDoublingWideningScalarBySelectedScalarAndAddSaturate](#28-multiplydoublingwideningscalarbyselectedscalarandaddsaturate), [MultiplyDoublingWideningScalarBySelectedScalarAndSubtractSaturate](#29-multiplydoublingwideningscalarbyselectedscalarandsubtractsaturate), [MultiplyExtended](#30-multiplyextended), [MultiplyExtendedByScalar](#31-multiplyextendedbyscalar), [MultiplyExtendedBySelectedScalar](#32-multiplyextendedbyselectedscalar), [MultiplyExtendedScalar](#33-multiplyextendedscalar), [MultiplyExtendedScalarBySelectedScalar](#34-multiplyextendedscalarbyselectedscalar), [MultiplyRoundedDoublingSaturateHighScalar](#35-multiplyroundeddoublingsaturatehighscalar), [MultiplyRoundedDoublingScalarBySelectedScalarSaturateHigh](#36-multiplyroundeddoublingscalarbyselectedscalarsaturatehigh), [NegateSaturateScalar](#37-negatesaturatescalar), [ReciprocalEstimateScalar](#38-reciprocalestimatescalar), [ReciprocalExponentScalar](#39-reciprocalexponentscalar), [ReciprocalSquareRootEstimateScalar](#40-reciprocalsquarerootestimatescalar), [ReciprocalSquareRootStepScalar](#41-reciprocalsquarerootstepscalar), [ReciprocalStepScalar](#42-reciprocalstepscalar), [ShiftRightArithmeticNarrowingSaturateScalar](#43-shiftrightarithmeticnarrowingsaturatescalar), [ShiftRightArithmeticNarrowingSaturateUnsignedScalar](#44-shiftrightarithmeticnarrowingsaturateunsignedscalar), [ShiftRightArithmeticRoundedNarrowingSaturateScalar](#45-shiftrightarithmeticroundednarrowingsaturatescalar), [ShiftRightArithmeticRoundedNarrowingSaturateUnsignedScalar](#46-shiftrightarithmeticroundednarrowingsaturateunsignedscalar), [ShiftRightLogicalNarrowingSaturateScalar](#47-shiftrightlogicalnarrowingsaturatescalar), [ShiftRightLogicalRoundedNarrowingSaturateScalar](#48-shiftrightlogicalroundednarrowingsaturatescalar), [Sqrt](#49-sqrt), [StorePair](#50-storepair), [StorePairNonTemporal](#51-storepairnontemporal), [StorePairScalar](#52-storepairscalar), [StorePairScalarNonTemporal](#53-storepairscalarnontemporal), [ReverseElementBits](#54-reverseelementbits), [TransposeEven](#55-transposeeven), [TransposeOdd](#56-transposeodd), [UnzipEven](#57-unzipeven), [UnzipOdd](#58-unzipodd), [ZipHigh](#59-ziphigh), [ZipLow](#60-ziplow),[...](Part6.md)






### 1. ExtractNarrowingSaturateScalar

`Vector64<byte> ExtractNarrowingSaturateScalar(Vector64<ushort> value)`

Performs 'ExtractNarrowingSaturateScalar' operation.

```csharp
private Vector64<byte> ExtractNarrowingSaturateScalarTest(Vector64<ushort> value)
{
  return AdvSimd.Arm64.ExtractNarrowingSaturateScalar(value);
}
// value = <11, 12, 13, 14>
// Result = <11, 0, 0, 0, 0, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<short> ExtractNarrowingSaturateScalar(Vector64<int> value)
Vector64<int> ExtractNarrowingSaturateScalar(Vector64<long> value)
Vector64<sbyte> ExtractNarrowingSaturateScalar(Vector64<short> value)
Vector64<ushort> ExtractNarrowingSaturateScalar(Vector64<uint> value)
Vector64<uint> ExtractNarrowingSaturateScalar(Vector64<ulong> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.extractnarrowingsaturatescalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ExtractNarrowingSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[UInt16]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M33135_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M33135_IG02:
            ldr     d16, [fp,#24]
            uqxtn   b16, h16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M33135_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=ae277e90) for method AdvSimdMethods:ExtractNarrowingSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[UInt16]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 2. ExtractNarrowingSaturateUnsignedScalar

`Vector64<byte> ExtractNarrowingSaturateUnsignedScalar(Vector64<short> value)`

Performs 'ExtractNarrowingSaturateUnsignedScalar' operation.

```csharp
private Vector64<byte> ExtractNarrowingSaturateUnsignedScalarTest(Vector64<short> value)
{
  return AdvSimd.Arm64.ExtractNarrowingSaturateUnsignedScalar(value);
}
// value = <11, 12, 13, 14>
// Result = <11, 0, 0, 0, 0, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<ushort> ExtractNarrowingSaturateUnsignedScalar(Vector64<int> value)
Vector64<uint> ExtractNarrowingSaturateUnsignedScalar(Vector64<long> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.extractnarrowingsaturateunsignedscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ExtractNarrowingSaturateUnsignedScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M51411_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M51411_IG02:
            ldr     d16, [fp,#24]
            sqxtun  b16, h16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M51411_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=c717372c) for method AdvSimdMethods:ExtractNarrowingSaturateUnsignedScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 3. FusedMultiplyAddByScalar

`Vector64<float> FusedMultiplyAddByScalar(Vector64<float> addend, Vector64<float> left, Vector64<float> right)`

Performs 'FusedMultiplyAddByScalar' operation.

```csharp
private Vector64<float> FusedMultiplyAddByScalarTest(Vector64<float> addend, Vector64<float> left, Vector64<float> right)
{
  return AdvSimd.Arm64.FusedMultiplyAddByScalar(addend, left, right);
}
// addend = <11.5, 12.5>
// left = <21.5, 22.5>
// right = <11.5, 12.5>
// Result = <258.75, 271.25>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> FusedMultiplyAddByScalar(Vector128<double> addend, Vector128<double> left, Vector64<double> right)
Vector128<float> FusedMultiplyAddByScalar(Vector128<float> addend, Vector128<float> left, Vector64<float> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.fusedmultiplyaddbyscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:FusedMultiplyAddByScalarTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x20]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M9656_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     d1, [fp,#32]
            str     d2, [fp,#24]
						;; bbWeight=1    PerfScore 4.50
G_M9656_IG02:
            ldr     d16, [fp,#40]
            ldr     d17, [fp,#32]
            ldr     d18, [fp,#24]
            fmla    v16.2s, v17.2s, v18.s[0]
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 9.50
G_M9656_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 20.80, (MethodHash=732bda47) for method AdvSimdMethods:FusedMultiplyAddByScalarTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 4. FusedMultiplyAddBySelectedScalar

`Vector64<float> FusedMultiplyAddBySelectedScalar(Vector64<float> addend, Vector64<float> left, Vector64<float> right, byte rightIndex)`

Performs 'FusedMultiplyAddBySelectedScalar' operation.

```csharp
private Vector64<float> FusedMultiplyAddBySelectedScalarTest(Vector64<float> addend, Vector64<float> left, Vector64<float> right, byte rightIndex)
{
  return AdvSimd.Arm64.FusedMultiplyAddBySelectedScalar(addend, left, right, rightIndex);
}
// addend = <11.5, 12.5>
// left = <21.5, 22.5>
// right = <11.5, 12.5>
// rightIndex = 0
// Result = <258.75, 271.25>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<float> FusedMultiplyAddBySelectedScalar(Vector64<float> addend, Vector64<float> left, Vector128<float> right, byte rightIndex)
Vector128<double> FusedMultiplyAddBySelectedScalar(Vector128<double> addend, Vector128<double> left, Vector128<double> right, byte rightIndex)
Vector128<float> FusedMultiplyAddBySelectedScalar(Vector128<float> addend, Vector128<float> left, Vector64<float> right, byte rightIndex)
Vector128<float> FusedMultiplyAddBySelectedScalar(Vector128<float> addend, Vector128<float> left, Vector128<float> right, byte rightIndex)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.fusedmultiplyaddbyselectedscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:FusedMultiplyAddBySelectedScalarTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single],ubyte):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x20]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V03 arg3         [V03,T00] (  3,  3   )   ubyte  ->   x0        
;# V04 OutArgs      [V04    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V05 tmp1         [V05,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V06 tmp2         [V06,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;  V07 tmp3         [V07,T03] (  2,  4   )   simd8  ->   d2         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 32

G_M60418_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     d1, [fp,#32]
            str     d2, [fp,#24]
						;; bbWeight=1    PerfScore 4.50
G_M60418_IG02:
            ldr     d0, [fp,#40]
            ldr     d1, [fp,#32]
            ldr     d2, [fp,#24]
            uxtb    w0, w0
            bl      Arm64:FusedMultiplyAddBySelectedScalar(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single],ubyte):System.Runtime.Intrinsics.Vector64`1[Single]
						;; bbWeight=1    PerfScore 7.50
G_M60418_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 18.80, (MethodHash=872113fd) for method AdvSimdMethods:FusedMultiplyAddBySelectedScalarTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single],ubyte):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 5. FusedMultiplyAddScalarBySelectedScalar

`Vector64<double> FusedMultiplyAddScalarBySelectedScalar(Vector64<double> addend, Vector64<double> left, Vector128<double> right, byte rightIndex)`

Performs 'FusedMultiplyAddScalarBySelectedScalar' operation.

```csharp
private Vector64<double> FusedMultiplyAddScalarBySelectedScalarTest(Vector64<double> addend, Vector64<double> left, Vector128<double> right, byte rightIndex)
{
  return AdvSimd.Arm64.FusedMultiplyAddScalarBySelectedScalar(addend, left, right, rightIndex);
}
// addend = <11.5>
// left = <11.5>
// right = <11.5, 12.5>
// rightIndex = 0
// Result = <143.75>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<float> FusedMultiplyAddScalarBySelectedScalar(Vector64<float> addend, Vector64<float> left, Vector64<float> right, byte rightIndex)
Vector64<float> FusedMultiplyAddScalarBySelectedScalar(Vector64<float> addend, Vector64<float> left, Vector128<float> right, byte rightIndex)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.fusedmultiplyaddscalarbyselectedscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:FusedMultiplyAddScalarBySelectedScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector128`1[Double],ubyte):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x20]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V03 arg3         [V03,T00] (  3,  3   )   ubyte  ->   x0        
;# V04 OutArgs      [V04    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V05 tmp1         [V05,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V06 tmp2         [V06,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;  V07 tmp3         [V07,T03] (  2,  4   )  simd16  ->   d2         HFA(simd16)  "Inlining Arg"
;
; Lcl frame size = 32

G_M26869_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     d1, [fp,#32]
            str     q2, [fp,#16]
						;; bbWeight=1    PerfScore 4.50
G_M26869_IG02:
            ldr     d0, [fp,#40]
            ldr     d1, [fp,#32]
            ldr     q2, [fp,#16]
            uxtb    w0, w0
            bl      Arm64:FusedMultiplyAddScalarBySelectedScalar(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector128`1[Double],ubyte):System.Runtime.Intrinsics.Vector64`1[Double]
						;; bbWeight=1    PerfScore 7.50
G_M26869_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 18.80, (MethodHash=4058970a) for method AdvSimdMethods:FusedMultiplyAddScalarBySelectedScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector128`1[Double],ubyte):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 6. FusedMultiplySubtractByScalar

`Vector64<float> FusedMultiplySubtractByScalar(Vector64<float> minuend, Vector64<float> left, Vector64<float> right)`

Performs 'FusedMultiplySubtractByScalar' operation.

```csharp
private Vector64<float> FusedMultiplySubtractByScalarTest(Vector64<float> minuend, Vector64<float> left, Vector64<float> right)
{
  return AdvSimd.Arm64.FusedMultiplySubtractByScalar(minuend, left, right);
}
// minuend = <11.5, 12.5>
// left = <21.5, 22.5>
// right = <11.5, 12.5>
// Result = <-235.75, -246.25>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> FusedMultiplySubtractByScalar(Vector128<double> minuend, Vector128<double> left, Vector64<double> right)
Vector128<float> FusedMultiplySubtractByScalar(Vector128<float> minuend, Vector128<float> left, Vector64<float> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.fusedmultiplysubtractbyscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:FusedMultiplySubtractByScalarTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x20]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M6573_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     d1, [fp,#32]
            str     d2, [fp,#24]
						;; bbWeight=1    PerfScore 4.50
G_M6573_IG02:
            ldr     d16, [fp,#40]
            ldr     d17, [fp,#32]
            ldr     d18, [fp,#24]
            fmls    v16.2s, v17.2s, v18.s[0]
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 9.50
G_M6573_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 20.80, (MethodHash=4149e652) for method AdvSimdMethods:FusedMultiplySubtractByScalarTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 7. FusedMultiplySubtractBySelectedScalar

`Vector64<float> FusedMultiplySubtractBySelectedScalar(Vector64<float> minuend, Vector64<float> left, Vector64<float> right, byte rightIndex)`

Performs 'FusedMultiplySubtractBySelectedScalar' operation.

```csharp
private Vector64<float> FusedMultiplySubtractBySelectedScalarTest(Vector64<float> minuend, Vector64<float> left, Vector64<float> right, byte rightIndex)
{
  return AdvSimd.Arm64.FusedMultiplySubtractBySelectedScalar(minuend, left, right, rightIndex);
}
// minuend = <11.5, 12.5>
// left = <21.5, 22.5>
// right = <11.5, 12.5>
// rightIndex = 0
// Result = <-235.75, -246.25>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<float> FusedMultiplySubtractBySelectedScalar(Vector64<float> minuend, Vector64<float> left, Vector128<float> right, byte rightIndex)
Vector128<double> FusedMultiplySubtractBySelectedScalar(Vector128<double> minuend, Vector128<double> left, Vector128<double> right, byte rightIndex)
Vector128<float> FusedMultiplySubtractBySelectedScalar(Vector128<float> minuend, Vector128<float> left, Vector64<float> right, byte rightIndex)
Vector128<float> FusedMultiplySubtractBySelectedScalar(Vector128<float> minuend, Vector128<float> left, Vector128<float> right, byte rightIndex)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.fusedmultiplysubtractbyselectedscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:FusedMultiplySubtractBySelectedScalarTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single],ubyte):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x20]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V03 arg3         [V03,T00] (  3,  3   )   ubyte  ->   x0        
;# V04 OutArgs      [V04    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V05 tmp1         [V05,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V06 tmp2         [V06,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;  V07 tmp3         [V07,T03] (  2,  4   )   simd8  ->   d2         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 32

G_M54295_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     d1, [fp,#32]
            str     d2, [fp,#24]
						;; bbWeight=1    PerfScore 4.50
G_M54295_IG02:
            ldr     d0, [fp,#40]
            ldr     d1, [fp,#32]
            ldr     d2, [fp,#24]
            uxtb    w0, w0
            bl      Arm64:FusedMultiplySubtractBySelectedScalar(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single],ubyte):System.Runtime.Intrinsics.Vector64`1[Single]
						;; bbWeight=1    PerfScore 7.50
G_M54295_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 18.80, (MethodHash=d11c2be8) for method AdvSimdMethods:FusedMultiplySubtractBySelectedScalarTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single],ubyte):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 8. FusedMultiplySubtractScalarBySelectedScalar

`Vector64<double> FusedMultiplySubtractScalarBySelectedScalar(Vector64<double> minuend, Vector64<double> left, Vector128<double> right, byte rightIndex)`

Performs 'FusedMultiplySubtractScalarBySelectedScalar' operation.

```csharp
private Vector64<double> FusedMultiplySubtractScalarBySelectedScalarTest(Vector64<double> minuend, Vector64<double> left, Vector128<double> right, byte rightIndex)
{
  return AdvSimd.Arm64.FusedMultiplySubtractScalarBySelectedScalar(minuend, left, right, rightIndex);
}
// minuend = <11.5>
// left = <11.5>
// right = <11.5, 12.5>
// rightIndex = 0
// Result = <-120.75>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<float> FusedMultiplySubtractScalarBySelectedScalar(Vector64<float> minuend, Vector64<float> left, Vector64<float> right, byte rightIndex)
Vector64<float> FusedMultiplySubtractScalarBySelectedScalar(Vector64<float> minuend, Vector64<float> left, Vector128<float> right, byte rightIndex)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.fusedmultiplysubtractscalarbyselectedscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:FusedMultiplySubtractScalarBySelectedScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector128`1[Double],ubyte):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x20]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V03 arg3         [V03,T00] (  3,  3   )   ubyte  ->   x0        
;# V04 OutArgs      [V04    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V05 tmp1         [V05,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V06 tmp2         [V06,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;  V07 tmp3         [V07,T03] (  2,  4   )  simd16  ->   d2         HFA(simd16)  "Inlining Arg"
;
; Lcl frame size = 32

G_M13376_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     d1, [fp,#32]
            str     q2, [fp,#16]
						;; bbWeight=1    PerfScore 4.50
G_M13376_IG02:
            ldr     d0, [fp,#40]
            ldr     d1, [fp,#32]
            ldr     q2, [fp,#16]
            uxtb    w0, w0
            bl      Arm64:FusedMultiplySubtractScalarBySelectedScalar(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector128`1[Double],ubyte):System.Runtime.Intrinsics.Vector64`1[Double]
						;; bbWeight=1    PerfScore 7.50
G_M13376_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 18.80, (MethodHash=855ecbbf) for method AdvSimdMethods:FusedMultiplySubtractScalarBySelectedScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector128`1[Double],ubyte):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 9. InsertSelectedScalar

`Vector64<byte> InsertSelectedScalar(Vector64<byte> result, byte resultIndex, Vector64<byte> value, byte valueIndex)`

Performs 'InsertSelectedScalar' operation.

```csharp
private Vector64<byte> InsertSelectedScalarTest(Vector64<byte> result, byte resultIndex, Vector64<byte> value, byte valueIndex)
{
  return AdvSimd.Arm64.InsertSelectedScalar(result, resultIndex, value, valueIndex);
}
// result = <11, 12, 13, 14, 15, 16, 17, 18>
// resultIndex = 0
// value = <21, 22, 23, 24, 25, 26, 27, 28>
// valueIndex = 1
// Result = <22, 12, 13, 14, 15, 16, 17, 18>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<byte> InsertSelectedScalar(Vector64<byte> result, byte resultIndex, Vector128<byte> value, byte valueIndex)
Vector64<short> InsertSelectedScalar(Vector64<short> result, byte resultIndex, Vector64<short> value, byte valueIndex)
Vector64<short> InsertSelectedScalar(Vector64<short> result, byte resultIndex, Vector128<short> value, byte valueIndex)
Vector64<int> InsertSelectedScalar(Vector64<int> result, byte resultIndex, Vector64<int> value, byte valueIndex)
Vector64<int> InsertSelectedScalar(Vector64<int> result, byte resultIndex, Vector128<int> value, byte valueIndex)
Vector64<sbyte> InsertSelectedScalar(Vector64<sbyte> result, byte resultIndex, Vector64<sbyte> value, byte valueIndex)
Vector64<sbyte> InsertSelectedScalar(Vector64<sbyte> result, byte resultIndex, Vector128<sbyte> value, byte valueIndex)
Vector64<float> InsertSelectedScalar(Vector64<float> result, byte resultIndex, Vector64<float> value, byte valueIndex)
Vector64<float> InsertSelectedScalar(Vector64<float> result, byte resultIndex, Vector128<float> value, byte valueIndex)
Vector64<ushort> InsertSelectedScalar(Vector64<ushort> result, byte resultIndex, Vector64<ushort> value, byte valueIndex)
Vector64<ushort> InsertSelectedScalar(Vector64<ushort> result, byte resultIndex, Vector128<ushort> value, byte valueIndex)
Vector64<uint> InsertSelectedScalar(Vector64<uint> result, byte resultIndex, Vector64<uint> value, byte valueIndex)
Vector64<uint> InsertSelectedScalar(Vector64<uint> result, byte resultIndex, Vector128<uint> value, byte valueIndex)
Vector128<byte> InsertSelectedScalar(Vector128<byte> result, byte resultIndex, Vector64<byte> value, byte valueIndex)
Vector128<byte> InsertSelectedScalar(Vector128<byte> result, byte resultIndex, Vector128<byte> value, byte valueIndex)
Vector128<double> InsertSelectedScalar(Vector128<double> result, byte resultIndex, Vector128<double> value, byte valueIndex)
Vector128<short> InsertSelectedScalar(Vector128<short> result, byte resultIndex, Vector64<short> value, byte valueIndex)
Vector128<short> InsertSelectedScalar(Vector128<short> result, byte resultIndex, Vector128<short> value, byte valueIndex)
Vector128<int> InsertSelectedScalar(Vector128<int> result, byte resultIndex, Vector64<int> value, byte valueIndex)
Vector128<int> InsertSelectedScalar(Vector128<int> result, byte resultIndex, Vector128<int> value, byte valueIndex)
Vector128<long> InsertSelectedScalar(Vector128<long> result, byte resultIndex, Vector128<long> value, byte valueIndex)
Vector128<sbyte> InsertSelectedScalar(Vector128<sbyte> result, byte resultIndex, Vector64<sbyte> value, byte valueIndex)
Vector128<sbyte> InsertSelectedScalar(Vector128<sbyte> result, byte resultIndex, Vector128<sbyte> value, byte valueIndex)
Vector128<float> InsertSelectedScalar(Vector128<float> result, byte resultIndex, Vector64<float> value, byte valueIndex)
Vector128<float> InsertSelectedScalar(Vector128<float> result, byte resultIndex, Vector128<float> value, byte valueIndex)
Vector128<ushort> InsertSelectedScalar(Vector128<ushort> result, byte resultIndex, Vector64<ushort> value, byte valueIndex)
Vector128<ushort> InsertSelectedScalar(Vector128<ushort> result, byte resultIndex, Vector128<ushort> value, byte valueIndex)
Vector128<uint> InsertSelectedScalar(Vector128<uint> result, byte resultIndex, Vector64<uint> value, byte valueIndex)
Vector128<uint> InsertSelectedScalar(Vector128<uint> result, byte resultIndex, Vector128<uint> value, byte valueIndex)
Vector128<ulong> InsertSelectedScalar(Vector128<ulong> result, byte resultIndex, Vector128<ulong> value, byte valueIndex)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.insertselectedscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:InsertSelectedScalarTest(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte,System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->  x19        
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V03 arg3         [V03,T01] (  3,  3   )   ubyte  ->   x1        
;# V04 OutArgs      [V04    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V05 tmp1         [V05,T03] (  2,  4   )   simd8  ->   d8         HFA(simd8)  "Inlining Arg"
;  V06 tmp2         [V06,T04] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V07 tmp3         [V07,T05] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V08 tmp4         [V08,T06] (  2,  4   )   simd8  ->   d8         HFA(simd8)  "Inlining Arg"
;  V09 tmp5         [V09,T02] (  2,  4   )   ubyte  ->   x1         "Inlining Arg"
;
; Lcl frame size = 16

G_M38144_IG01:
            stp     fp, lr, [sp,#-48]!
            str     d8, [sp,#32]
            str     x19, [sp,#40]
            mov     fp, sp
            mov     w19, w0
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 6.00
G_M38144_IG02:
            ldr     d8, [fp,#24]
            ldr     d0, [fp,#16]
            uxtb    w0, w1
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:Extract(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):ubyte
            uxtb    w1, w0
            uxtb    w0, w19
            mov     v0.8b, v8.8b
            bl      System.Runtime.Intrinsics.Arm.AdvSimd:Insert(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte,ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
						;; bbWeight=1    PerfScore 8.00
G_M38144_IG03:
            ldr     x19, [sp,#40]
            ldr     d8, [sp,#32]
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 6.00

; Total bytes of code 76, prolog size 16, PerfScore 27.60, (MethodHash=1dc16aff) for method AdvSimdMethods:InsertSelectedScalarTest(System.Runtime.Intrinsics.Vector64`1[Byte],ubyte,System.Runtime.Intrinsics.Vector64`1[Byte],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 10. MaxAcross

`Vector64<byte> MaxAcross(Vector64<byte> value)`

Performs 'MaxAcross' operation.

```csharp
private Vector64<byte> MaxAcrossTest(Vector64<byte> value)
{
  return AdvSimd.Arm64.MaxAcross(value);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// Result = <18, 0, 0, 0, 0, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<short> MaxAcross(Vector64<short> value)
Vector64<sbyte> MaxAcross(Vector64<sbyte> value)
Vector64<ushort> MaxAcross(Vector64<ushort> value)
Vector64<byte> MaxAcross(Vector128<byte> value)
Vector64<short> MaxAcross(Vector128<short> value)
Vector64<int> MaxAcross(Vector128<int> value)
Vector64<sbyte> MaxAcross(Vector128<sbyte> value)
Vector64<float> MaxAcross(Vector128<float> value)
Vector64<ushort> MaxAcross(Vector128<ushort> value)
Vector64<uint> MaxAcross(Vector128<uint> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.maxacross?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MaxAcrossTest(System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M44874_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M44874_IG02:
            ldr     d16, [fp,#24]
            umaxv   b16, v16.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M44874_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=879450b5) for method AdvSimdMethods:MaxAcrossTest(System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 11. MaxNumberAcross

`Vector64<float> MaxNumberAcross(Vector128<float> value)`

Performs 'MaxNumberAcross' operation.

```csharp
private Vector64<float> MaxNumberAcrossTest(Vector128<float> value)
{
  return AdvSimd.Arm64.MaxNumberAcross(value);
}
// value = <11.5, 12.5, 13.5, 14.5>
// Result = <14.5, 0>

```



See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.maxnumberacross?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MaxNumberAcrossTest(System.Runtime.Intrinsics.Vector128`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M55888_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     q0, [fp,#16]
						;; bbWeight=1    PerfScore 2.50
G_M55888_IG02:
            ldr     q16, [fp,#16]
            fmaxnmv s16, v16.4s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M55888_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=670225af) for method AdvSimdMethods:MaxNumberAcrossTest(System.Runtime.Intrinsics.Vector128`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 12. MaxNumberPairwise

`Vector64<float> MaxNumberPairwise(Vector64<float> left, Vector64<float> right)`

Performs 'MaxNumberPairwise' operation.

```csharp
private Vector64<float> MaxNumberPairwiseTest(Vector64<float> left, Vector64<float> right)
{
  return AdvSimd.Arm64.MaxNumberPairwise(left, right);
}
// left = <11.5, 12.5>
// right = <21.5, 22.5>
// Result = <12.5, 22.5>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> MaxNumberPairwise(Vector128<double> left, Vector128<double> right)
Vector128<float> MaxNumberPairwise(Vector128<float> left, Vector128<float> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.maxnumberpairwise?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MaxNumberPairwiseTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M25941_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M25941_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            fmaxnmp v16.2s, v16.2s, v17.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M25941_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=77549aaa) for method AdvSimdMethods:MaxNumberPairwiseTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 13. MaxNumberPairwiseScalar

`Vector64<float> MaxNumberPairwiseScalar(Vector64<float> value)`

Performs 'MaxNumberPairwiseScalar' operation.

```csharp
private Vector64<float> MaxNumberPairwiseScalarTest(Vector64<float> value)
{
  return AdvSimd.Arm64.MaxNumberPairwiseScalar(value);
}
// value = <11.5, 12.5>
// Result = <12.5, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<double> MaxNumberPairwiseScalar(Vector128<double> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.maxnumberpairwisescalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MaxNumberPairwiseScalarTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M16346_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M16346_IG02:
            ldr     d16, [fp,#24]
            fmaxnmp s16, v16.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M16346_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=ffd9c025) for method AdvSimdMethods:MaxNumberPairwiseScalarTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 14. MaxPairwiseScalar

`Vector64<float> MaxPairwiseScalar(Vector64<float> value)`

Performs 'MaxPairwiseScalar' operation.

```csharp
private Vector64<float> MaxPairwiseScalarTest(Vector64<float> value)
{
  return AdvSimd.Arm64.MaxPairwiseScalar(value);
}
// value = <11.5, 12.5>
// Result = <12.5, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<double> MaxPairwiseScalar(Vector128<double> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.maxpairwisescalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MaxPairwiseScalarTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M64665_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M64665_IG02:
            ldr     d16, [fp,#24]
            fmaxp   s16, v16.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M64665_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=eeae0366) for method AdvSimdMethods:MaxPairwiseScalarTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 15. MaxScalar

`Vector64<double> MaxScalar(Vector64<double> left, Vector64<double> right)`

Performs 'MaxScalar' operation.

```csharp
private Vector64<double> MaxScalarTest(Vector64<double> left, Vector64<double> right)
{
  return AdvSimd.Arm64.MaxScalar(left, right);
}
// left = <11.5>
// right = <11.5>
// Result = <11.5>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<float> MaxScalar(Vector64<float> left, Vector64<float> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.maxscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MaxScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M32821_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M32821_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            fmax    d16, d16, d17
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M32821_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=8eea7fca) for method AdvSimdMethods:MaxScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 16. MinAcross

`Vector64<byte> MinAcross(Vector64<byte> value)`

Performs 'MinAcross' operation.

```csharp
private Vector64<byte> MinAcrossTest(Vector64<byte> value)
{
  return AdvSimd.Arm64.MinAcross(value);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// Result = <11, 0, 0, 0, 0, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<short> MinAcross(Vector64<short> value)
Vector64<sbyte> MinAcross(Vector64<sbyte> value)
Vector64<ushort> MinAcross(Vector64<ushort> value)
Vector64<byte> MinAcross(Vector128<byte> value)
Vector64<short> MinAcross(Vector128<short> value)
Vector64<int> MinAcross(Vector128<int> value)
Vector64<sbyte> MinAcross(Vector128<sbyte> value)
Vector64<float> MinAcross(Vector128<float> value)
Vector64<ushort> MinAcross(Vector128<ushort> value)
Vector64<uint> MinAcross(Vector128<uint> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.minacross?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MinAcrossTest(System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M8724_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M8724_IG02:
            ldr     d16, [fp,#24]
            uminv   b16, v16.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M8724_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=046cddeb) for method AdvSimdMethods:MinAcrossTest(System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 17. MinNumberAcross

`Vector64<float> MinNumberAcross(Vector128<float> value)`

Performs 'MinNumberAcross' operation.

```csharp
private Vector64<float> MinNumberAcrossTest(Vector128<float> value)
{
  return AdvSimd.Arm64.MinNumberAcross(value);
}
// value = <11.5, 12.5, 13.5, 14.5>
// Result = <11.5, 0>

```



See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.minnumberacross?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MinNumberAcrossTest(System.Runtime.Intrinsics.Vector128`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M38990_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     q0, [fp,#16]
						;; bbWeight=1    PerfScore 2.50
G_M38990_IG02:
            ldr     q16, [fp,#16]
            fminnmv s16, v16.4s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M38990_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=5f7167b1) for method AdvSimdMethods:MinNumberAcrossTest(System.Runtime.Intrinsics.Vector128`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 18. MinNumberPairwise

`Vector64<float> MinNumberPairwise(Vector64<float> left, Vector64<float> right)`

Performs 'MinNumberPairwise' operation.

```csharp
private Vector64<float> MinNumberPairwiseTest(Vector64<float> left, Vector64<float> right)
{
  return AdvSimd.Arm64.MinNumberPairwise(left, right);
}
// left = <11.5, 12.5>
// right = <21.5, 22.5>
// Result = <11.5, 21.5>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> MinNumberPairwise(Vector128<double> left, Vector128<double> right)
Vector128<float> MinNumberPairwise(Vector128<float> left, Vector128<float> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.minnumberpairwise?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MinNumberPairwiseTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M53707_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M53707_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            fminnmp v16.2s, v16.2s, v17.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M53707_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=75cd2e34) for method AdvSimdMethods:MinNumberPairwiseTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 19. MinNumberPairwiseScalar

`Vector64<float> MinNumberPairwiseScalar(Vector64<float> value)`

Performs 'MinNumberPairwiseScalar' operation.

```csharp
private Vector64<float> MinNumberPairwiseScalarTest(Vector64<float> value)
{
  return AdvSimd.Arm64.MinNumberPairwiseScalar(value);
}
// value = <11.5, 12.5>
// Result = <11.5, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<double> MinNumberPairwiseScalar(Vector128<double> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.minnumberpairwisescalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MinNumberPairwiseScalarTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M11140_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M11140_IG02:
            ldr     d16, [fp,#24]
            fminnmp s16, v16.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M11140_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=41eed47b) for method AdvSimdMethods:MinNumberPairwiseScalarTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 20. MinPairwiseScalar

`Vector64<float> MinPairwiseScalar(Vector64<float> value)`

Performs 'MinPairwiseScalar' operation.

```csharp
private Vector64<float> MinPairwiseScalarTest(Vector64<float> value)
{
  return AdvSimd.Arm64.MinPairwiseScalar(value);
}
// value = <11.5, 12.5>
// Result = <11.5, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<double> MinPairwiseScalar(Vector128<double> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.minpairwisescalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MinPairwiseScalarTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M21063_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M21063_IG02:
            ldr     d16, [fp,#24]
            fminp   s16, v16.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M21063_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=4ec7adb8) for method AdvSimdMethods:MinPairwiseScalarTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 21. MinScalar

`Vector64<double> MinScalar(Vector64<double> left, Vector64<double> right)`

Performs 'MinScalar' operation.

```csharp
private Vector64<double> MinScalarTest(Vector64<double> left, Vector64<double> right)
{
  return AdvSimd.Arm64.MinScalar(left, right);
}
// left = <11.5>
// right = <11.5>
// Result = <11.5>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<float> MinScalar(Vector64<float> left, Vector64<float> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.minscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MinScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M31915_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M31915_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            fmin    d16, d16, d17
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M31915_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=6cb78354) for method AdvSimdMethods:MinScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 22. MultiplyDoublingSaturateHighScalar

`Vector64<short> MultiplyDoublingSaturateHighScalar(Vector64<short> left, Vector64<short> right)`

Performs 'MultiplyDoublingSaturateHighScalar' operation.

```csharp
private Vector64<short> MultiplyDoublingSaturateHighScalarTest(Vector64<short> left, Vector64<short> right)
{
  return AdvSimd.Arm64.MultiplyDoublingSaturateHighScalar(left, right);
}
// left = <11, 12, 13, 14>
// right = <21, 22, 23, 24>
// Result = <0, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<int> MultiplyDoublingSaturateHighScalar(Vector64<int> left, Vector64<int> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.multiplydoublingsaturatehighscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyDoublingSaturateHighScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M8803_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M8803_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            sqdmulh h16, h16, h17
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M8803_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=3700dd9c) for method AdvSimdMethods:MultiplyDoublingSaturateHighScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 23. MultiplyDoublingScalarBySelectedScalarSaturateHigh

`Vector64<short> MultiplyDoublingScalarBySelectedScalarSaturateHigh(Vector64<short> left, Vector64<short> right, byte rightIndex)`

Performs 'MultiplyDoublingScalarBySelectedScalarSaturateHigh' operation.

```csharp
private Vector64<short> MultiplyDoublingScalarBySelectedScalarSaturateHighTest(Vector64<short> left, Vector64<short> right, byte rightIndex)
{
  return AdvSimd.Arm64.MultiplyDoublingScalarBySelectedScalarSaturateHigh(left, right, rightIndex);
}
// left = <11, 12, 13, 14>
// right = <21, 22, 23, 24>
// rightIndex = 0
// Result = <0, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<short> MultiplyDoublingScalarBySelectedScalarSaturateHigh(Vector64<short> left, Vector128<short> right, byte rightIndex)
Vector64<int> MultiplyDoublingScalarBySelectedScalarSaturateHigh(Vector64<int> left, Vector64<int> right, byte rightIndex)
Vector64<int> MultiplyDoublingScalarBySelectedScalarSaturateHigh(Vector64<int> left, Vector128<int> right, byte rightIndex)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.multiplydoublingscalarbyselectedscalarsaturatehigh?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyDoublingScalarBySelectedScalarSaturateHighTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M23340_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M23340_IG02:
            ldr     d0, [fp,#24]
            ldr     d1, [fp,#16]
            uxtb    w0, w0
            bl      Arm64:MultiplyDoublingScalarBySelectedScalarSaturateHigh(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
						;; bbWeight=1    PerfScore 5.50
G_M23340_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=1406a4d3) for method AdvSimdMethods:MultiplyDoublingScalarBySelectedScalarSaturateHighTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 24. MultiplyDoublingWideningAndAddSaturateScalar

`Vector64<int> MultiplyDoublingWideningAndAddSaturateScalar(Vector64<int> addend, Vector64<short> left, Vector64<short> right)`

Performs 'MultiplyDoublingWideningAndAddSaturateScalar' operation.

```csharp
private Vector64<int> MultiplyDoublingWideningAndAddSaturateScalarTest(Vector64<int> addend, Vector64<short> left, Vector64<short> right)
{
  return AdvSimd.Arm64.MultiplyDoublingWideningAndAddSaturateScalar(addend, left, right);
}
// addend = <11, 12>
// left = <11, 12, 13, 14>
// right = <21, 22, 23, 24>
// Result = <473, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<long> MultiplyDoublingWideningAndAddSaturateScalar(Vector64<long> addend, Vector64<int> left, Vector64<int> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.multiplydoublingwideningandaddsaturatescalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyDoublingWideningAndAddSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x20]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M59801_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     d1, [fp,#32]
            str     d2, [fp,#24]
						;; bbWeight=1    PerfScore 4.50
G_M59801_IG02:
            ldr     d16, [fp,#40]
            ldr     d17, [fp,#32]
            ldr     d18, [fp,#24]
            sqdmlal s16, h17, h18
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M59801_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 18.80, (MethodHash=e38a1666) for method AdvSimdMethods:MultiplyDoublingWideningAndAddSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int32]
; ============================================================


```
------------------------------------------------

### 25. MultiplyDoublingWideningAndSubtractSaturateScalar

`Vector64<int> MultiplyDoublingWideningAndSubtractSaturateScalar(Vector64<int> minuend, Vector64<short> left, Vector64<short> right)`

Performs 'MultiplyDoublingWideningAndSubtractSaturateScalar' operation.

```csharp
private Vector64<int> MultiplyDoublingWideningAndSubtractSaturateScalarTest(Vector64<int> minuend, Vector64<short> left, Vector64<short> right)
{
  return AdvSimd.Arm64.MultiplyDoublingWideningAndSubtractSaturateScalar(minuend, left, right);
}
// minuend = <11, 12>
// left = <11, 12, 13, 14>
// right = <21, 22, 23, 24>
// Result = <-451, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<long> MultiplyDoublingWideningAndSubtractSaturateScalar(Vector64<long> minuend, Vector64<int> left, Vector64<int> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.multiplydoublingwideningandsubtractsaturatescalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyDoublingWideningAndSubtractSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x20]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M4524_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     d1, [fp,#32]
            str     d2, [fp,#24]
						;; bbWeight=1    PerfScore 4.50
G_M4524_IG02:
            ldr     d16, [fp,#40]
            ldr     d17, [fp,#32]
            ldr     d18, [fp,#24]
            sqdmlsl s16, h17, h18
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M4524_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 18.80, (MethodHash=32eeee53) for method AdvSimdMethods:MultiplyDoublingWideningAndSubtractSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int32]
; ============================================================


```
------------------------------------------------

### 26. MultiplyDoublingWideningSaturateScalar

`Vector64<int> MultiplyDoublingWideningSaturateScalar(Vector64<short> left, Vector64<short> right)`

Performs 'MultiplyDoublingWideningSaturateScalar' operation.

```csharp
private Vector64<int> MultiplyDoublingWideningSaturateScalarTest(Vector64<short> left, Vector64<short> right)
{
  return AdvSimd.Arm64.MultiplyDoublingWideningSaturateScalar(left, right);
}
// left = <11, 12, 13, 14>
// right = <21, 22, 23, 24>
// Result = <462, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<long> MultiplyDoublingWideningSaturateScalar(Vector64<int> left, Vector64<int> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.multiplydoublingwideningsaturatescalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyDoublingWideningSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M62810_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M62810_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            sqdmull s16, h16, h17
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M62810_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=15c30aa5) for method AdvSimdMethods:MultiplyDoublingWideningSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int32]
; ============================================================


```
------------------------------------------------

### 27. MultiplyDoublingWideningSaturateScalarBySelectedScalar

`Vector64<int> MultiplyDoublingWideningSaturateScalarBySelectedScalar(Vector64<short> left, Vector64<short> right, byte rightIndex)`

Performs 'MultiplyDoublingWideningSaturateScalarBySelectedScalar' operation.

```csharp
private Vector64<int> MultiplyDoublingWideningSaturateScalarBySelectedScalarTest(Vector64<short> left, Vector64<short> right, byte rightIndex)
{
  return AdvSimd.Arm64.MultiplyDoublingWideningSaturateScalarBySelectedScalar(left, right, rightIndex);
}
// left = <11, 12, 13, 14>
// right = <21, 22, 23, 24>
// rightIndex = 0
// Result = <462, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<int> MultiplyDoublingWideningSaturateScalarBySelectedScalar(Vector64<short> left, Vector128<short> right, byte rightIndex)
Vector64<long> MultiplyDoublingWideningSaturateScalarBySelectedScalar(Vector64<int> left, Vector64<int> right, byte rightIndex)
Vector64<long> MultiplyDoublingWideningSaturateScalarBySelectedScalar(Vector64<int> left, Vector128<int> right, byte rightIndex)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.multiplydoublingwideningsaturatescalarbyselectedscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyDoublingWideningSaturateScalarBySelectedScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M27861_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M27861_IG02:
            ldr     d0, [fp,#24]
            ldr     d1, [fp,#16]
            uxtb    w0, w0
            bl      Arm64:MultiplyDoublingWideningSaturateScalarBySelectedScalar(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int32]
						;; bbWeight=1    PerfScore 5.50
G_M27861_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=8079932a) for method AdvSimdMethods:MultiplyDoublingWideningSaturateScalarBySelectedScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int32]
; ============================================================


```
------------------------------------------------

### 28. MultiplyDoublingWideningScalarBySelectedScalarAndAddSaturate

`Vector64<int> MultiplyDoublingWideningScalarBySelectedScalarAndAddSaturate(Vector64<int> addend, Vector64<short> left, Vector64<short> right, byte rightIndex)`

Performs 'MultiplyDoublingWideningScalarBySelectedScalarAndAddSaturate' operation.

```csharp
private Vector64<int> MultiplyDoublingWideningScalarBySelectedScalarAndAddSaturateTest(Vector64<int> addend, Vector64<short> left, Vector64<short> right, byte rightIndex)
{
  return AdvSimd.Arm64.MultiplyDoublingWideningScalarBySelectedScalarAndAddSaturate(addend, left, right, rightIndex);
}
// addend = <11, 12>
// left = <11, 12, 13, 14>
// right = <21, 22, 23, 24>
// rightIndex = 0
// Result = <473, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<int> MultiplyDoublingWideningScalarBySelectedScalarAndAddSaturate(Vector64<int> addend, Vector64<short> left, Vector128<short> right, byte rightIndex)
Vector64<long> MultiplyDoublingWideningScalarBySelectedScalarAndAddSaturate(Vector64<long> addend, Vector64<int> left, Vector64<int> right, byte rightIndex)
Vector64<long> MultiplyDoublingWideningScalarBySelectedScalarAndAddSaturate(Vector64<long> addend, Vector64<int> left, Vector128<int> right, byte rightIndex)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.multiplydoublingwideningscalarbyselectedscalarandaddsaturate?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyDoublingWideningScalarBySelectedScalarAndAddSaturateTest(System.Runtime.Intrinsics.Vector64`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x20]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V03 arg3         [V03,T00] (  3,  3   )   ubyte  ->   x0        
;# V04 OutArgs      [V04    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V05 tmp1         [V05,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V06 tmp2         [V06,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;  V07 tmp3         [V07,T03] (  2,  4   )   simd8  ->   d2         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 32

G_M63702_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     d1, [fp,#32]
            str     d2, [fp,#24]
						;; bbWeight=1    PerfScore 4.50
G_M63702_IG02:
            ldr     d0, [fp,#40]
            ldr     d1, [fp,#32]
            ldr     d2, [fp,#24]
            uxtb    w0, w0
            bl      Arm64:MultiplyDoublingWideningScalarBySelectedScalarAndAddSaturate(System.Runtime.Intrinsics.Vector64`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int32]
						;; bbWeight=1    PerfScore 7.50
G_M63702_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 18.80, (MethodHash=bff70729) for method AdvSimdMethods:MultiplyDoublingWideningScalarBySelectedScalarAndAddSaturateTest(System.Runtime.Intrinsics.Vector64`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int32]
; ============================================================


```
------------------------------------------------

### 29. MultiplyDoublingWideningScalarBySelectedScalarAndSubtractSaturate

`Vector64<int> MultiplyDoublingWideningScalarBySelectedScalarAndSubtractSaturate(Vector64<int> minuend, Vector64<short> left, Vector64<short> right, byte rightIndex)`

Performs 'MultiplyDoublingWideningScalarBySelectedScalarAndSubtractSaturate' operation.

```csharp
private Vector64<int> MultiplyDoublingWideningScalarBySelectedScalarAndSubtractSaturateTest(Vector64<int> minuend, Vector64<short> left, Vector64<short> right, byte rightIndex)
{
  return AdvSimd.Arm64.MultiplyDoublingWideningScalarBySelectedScalarAndSubtractSaturate(minuend, left, right, rightIndex);
}
// minuend = <11, 12>
// left = <11, 12, 13, 14>
// right = <21, 22, 23, 24>
// rightIndex = 0
// Result = <-451, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<int> MultiplyDoublingWideningScalarBySelectedScalarAndSubtractSaturate(Vector64<int> minuend, Vector64<short> left, Vector128<short> right, byte rightIndex)
Vector64<long> MultiplyDoublingWideningScalarBySelectedScalarAndSubtractSaturate(Vector64<long> minuend, Vector64<int> left, Vector64<int> right, byte rightIndex)
Vector64<long> MultiplyDoublingWideningScalarBySelectedScalarAndSubtractSaturate(Vector64<long> minuend, Vector64<int> left, Vector128<int> right, byte rightIndex)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.multiplydoublingwideningscalarbyselectedscalarandsubtractsaturate?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyDoublingWideningScalarBySelectedScalarAndSubtractSaturateTest(System.Runtime.Intrinsics.Vector64`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int32]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x20]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V03 arg3         [V03,T00] (  3,  3   )   ubyte  ->   x0        
;# V04 OutArgs      [V04    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V05 tmp1         [V05,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V06 tmp2         [V06,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;  V07 tmp3         [V07,T03] (  2,  4   )   simd8  ->   d2         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 32

G_M31139_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     d1, [fp,#32]
            str     d2, [fp,#24]
						;; bbWeight=1    PerfScore 4.50
G_M31139_IG02:
            ldr     d0, [fp,#40]
            ldr     d1, [fp,#32]
            ldr     d2, [fp,#24]
            uxtb    w0, w0
            bl      Arm64:MultiplyDoublingWideningScalarBySelectedScalarAndSubtractSaturate(System.Runtime.Intrinsics.Vector64`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int32]
						;; bbWeight=1    PerfScore 7.50
G_M31139_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 48, prolog size 8, PerfScore 18.80, (MethodHash=5539865c) for method AdvSimdMethods:MultiplyDoublingWideningScalarBySelectedScalarAndSubtractSaturateTest(System.Runtime.Intrinsics.Vector64`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int32]
; ============================================================


```
------------------------------------------------

### 30. MultiplyExtended

`Vector64<float> MultiplyExtended(Vector64<float> left, Vector64<float> right)`

Performs 'MultiplyExtended' operation.

```csharp
private Vector64<float> MultiplyExtendedTest(Vector64<float> left, Vector64<float> right)
{
  return AdvSimd.Arm64.MultiplyExtended(left, right);
}
// left = <11.5, 12.5>
// right = <21.5, 22.5>
// Result = <247.25, 281.25>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> MultiplyExtended(Vector128<double> left, Vector128<double> right)
Vector128<float> MultiplyExtended(Vector128<float> left, Vector128<float> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.multiplyextended?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyExtendedTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M39019_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M39019_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            fmulx   v16.2s, v16.2s, v17.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M39019_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=21936794) for method AdvSimdMethods:MultiplyExtendedTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 31. MultiplyExtendedByScalar

`Vector128<double> MultiplyExtendedByScalar(Vector128<double> left, Vector64<double> right)`

Performs 'MultiplyExtendedByScalar' operation.

```csharp
private Vector128<double> MultiplyExtendedByScalarTest(Vector128<double> left, Vector64<double> right)
{
  return AdvSimd.Arm64.MultiplyExtendedByScalar(left, right);
}
// left = <11.5, 12.5>
// right = <11.5>
// Result = <132.25, 143.75>

```



See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.multiplyextendedbyscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyExtendedByScalarTest(System.Runtime.Intrinsics.Vector128`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector128`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )  simd16  ->  [fp+0x20]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 32

G_M5169_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     q0, [fp,#32]
            str     d1, [fp,#24]
						;; bbWeight=1    PerfScore 3.50
G_M5169_IG02:
            ldr     q16, [fp,#32]
            ldr     d17, [fp,#24]
            fmulx   v16.2d, v16.2d, v17.d[0]
            mov     v0.16b, v16.16b
						;; bbWeight=1    PerfScore 7.50
G_M5169_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=3e51ebce) for method AdvSimdMethods:MultiplyExtendedByScalarTest(System.Runtime.Intrinsics.Vector128`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector128`1[Double]
; ============================================================


```
------------------------------------------------

### 32. MultiplyExtendedBySelectedScalar

`Vector64<float> MultiplyExtendedBySelectedScalar(Vector64<float> left, Vector64<float> right, byte rightIndex)`

Performs 'MultiplyExtendedBySelectedScalar' operation.

```csharp
private Vector64<float> MultiplyExtendedBySelectedScalarTest(Vector64<float> left, Vector64<float> right, byte rightIndex)
{
  return AdvSimd.Arm64.MultiplyExtendedBySelectedScalar(left, right, rightIndex);
}
// left = <11.5, 12.5>
// right = <21.5, 22.5>
// rightIndex = 0
// Result = <247.25, 268.75>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<float> MultiplyExtendedBySelectedScalar(Vector64<float> left, Vector128<float> right, byte rightIndex)
Vector128<double> MultiplyExtendedBySelectedScalar(Vector128<double> left, Vector128<double> right, byte rightIndex)
Vector128<float> MultiplyExtendedBySelectedScalar(Vector128<float> left, Vector64<float> right, byte rightIndex)
Vector128<float> MultiplyExtendedBySelectedScalar(Vector128<float> left, Vector128<float> right, byte rightIndex)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.multiplyextendedbyselectedscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyExtendedBySelectedScalarTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single],ubyte):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M61700_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M61700_IG02:
            ldr     d0, [fp,#24]
            ldr     d1, [fp,#16]
            uxtb    w0, w0
            bl      Arm64:MultiplyExtendedBySelectedScalar(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single],ubyte):System.Runtime.Intrinsics.Vector64`1[Single]
						;; bbWeight=1    PerfScore 5.50
G_M61700_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=592a0efb) for method AdvSimdMethods:MultiplyExtendedBySelectedScalarTest(System.Runtime.Intrinsics.Vector64`1[Single],System.Runtime.Intrinsics.Vector64`1[Single],ubyte):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================


```
------------------------------------------------

### 33. MultiplyExtendedScalar

`Vector64<double> MultiplyExtendedScalar(Vector64<double> left, Vector64<double> right)`

Performs 'MultiplyExtendedScalar' operation.

```csharp
private Vector64<double> MultiplyExtendedScalarTest(Vector64<double> left, Vector64<double> right)
{
  return AdvSimd.Arm64.MultiplyExtendedScalar(left, right);
}
// left = <11.5>
// right = <11.5>
// Result = <132.25>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<float> MultiplyExtendedScalar(Vector64<float> left, Vector64<float> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.multiplyextendedscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyExtendedScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M34730_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M34730_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            fmulx   d16, d16, d17
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M34730_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=985e7855) for method AdvSimdMethods:MultiplyExtendedScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 34. MultiplyExtendedScalarBySelectedScalar

`Vector64<double> MultiplyExtendedScalarBySelectedScalar(Vector64<double> left, Vector128<double> right, byte rightIndex)`

Performs 'MultiplyExtendedScalarBySelectedScalar' operation.

```csharp
private Vector64<double> MultiplyExtendedScalarBySelectedScalarTest(Vector64<double> left, Vector128<double> right, byte rightIndex)
{
  return AdvSimd.Arm64.MultiplyExtendedScalarBySelectedScalar(left, right, rightIndex);
}
// left = <11.5>
// right = <11.5, 12.5>
// rightIndex = 0
// Result = <132.25>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<float> MultiplyExtendedScalarBySelectedScalar(Vector64<float> left, Vector64<float> right, byte rightIndex)
Vector64<float> MultiplyExtendedScalarBySelectedScalar(Vector64<float> left, Vector128<float> right, byte rightIndex)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.multiplyextendedscalarbyselectedscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyExtendedScalarBySelectedScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector128`1[Double],ubyte):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x28]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )  simd16  ->  [fp+0x10]   HFA(simd16)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T02] (  2,  4   )  simd16  ->   d1         HFA(simd16)  "Inlining Arg"
;
; Lcl frame size = 32

G_M34108_IG01:
            stp     fp, lr, [sp,#-48]!
            mov     fp, sp
            str     d0, [fp,#40]
            str     q1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M34108_IG02:
            ldr     d0, [fp,#40]
            ldr     q1, [fp,#16]
            uxtb    w0, w0
            bl      Arm64:MultiplyExtendedScalarBySelectedScalar(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector128`1[Double],ubyte):System.Runtime.Intrinsics.Vector64`1[Double]
						;; bbWeight=1    PerfScore 5.50
G_M34108_IG03:
            ldp     fp, lr, [sp],#48
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=05e07ac3) for method AdvSimdMethods:MultiplyExtendedScalarBySelectedScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector128`1[Double],ubyte):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 35. MultiplyRoundedDoublingSaturateHighScalar

`Vector64<short> MultiplyRoundedDoublingSaturateHighScalar(Vector64<short> left, Vector64<short> right)`

Performs 'MultiplyRoundedDoublingSaturateHighScalar' operation.

```csharp
private Vector64<short> MultiplyRoundedDoublingSaturateHighScalarTest(Vector64<short> left, Vector64<short> right)
{
  return AdvSimd.Arm64.MultiplyRoundedDoublingSaturateHighScalar(left, right);
}
// left = <11, 12, 13, 14>
// right = <21, 22, 23, 24>
// Result = <0, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<int> MultiplyRoundedDoublingSaturateHighScalar(Vector64<int> left, Vector64<int> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.multiplyroundeddoublingsaturatehighscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyRoundedDoublingSaturateHighScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M19808_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M19808_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            sqrdmulh h16, h16, h17
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M19808_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=c960b29f) for method AdvSimdMethods:MultiplyRoundedDoublingSaturateHighScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 36. MultiplyRoundedDoublingScalarBySelectedScalarSaturateHigh

`Vector64<short> MultiplyRoundedDoublingScalarBySelectedScalarSaturateHigh(Vector64<short> left, Vector64<short> right, byte rightIndex)`

Performs 'MultiplyRoundedDoublingScalarBySelectedScalarSaturateHigh' operation.

```csharp
private Vector64<short> MultiplyRoundedDoublingScalarBySelectedScalarSaturateHighTest(Vector64<short> left, Vector64<short> right, byte rightIndex)
{
  return AdvSimd.Arm64.MultiplyRoundedDoublingScalarBySelectedScalarSaturateHigh(left, right, rightIndex);
}
// left = <11, 12, 13, 14>
// right = <21, 22, 23, 24>
// rightIndex = 0
// Result = <0, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<short> MultiplyRoundedDoublingScalarBySelectedScalarSaturateHigh(Vector64<short> left, Vector128<short> right, byte rightIndex)
Vector64<int> MultiplyRoundedDoublingScalarBySelectedScalarSaturateHigh(Vector64<int> left, Vector64<int> right, byte rightIndex)
Vector64<int> MultiplyRoundedDoublingScalarBySelectedScalarSaturateHigh(Vector64<int> left, Vector128<int> right, byte rightIndex)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.multiplyroundeddoublingscalarbyselectedscalarsaturatehigh?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:MultiplyRoundedDoublingScalarBySelectedScalarSaturateHighTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02,T00] (  3,  3   )   ubyte  ->   x0        
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V04 tmp1         [V04,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;  V05 tmp2         [V05,T02] (  2,  4   )   simd8  ->   d1         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M5999_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M5999_IG02:
            ldr     d0, [fp,#24]
            ldr     d1, [fp,#16]
            uxtb    w0, w0
            bl      Arm64:MultiplyRoundedDoublingScalarBySelectedScalarSaturateHigh(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
						;; bbWeight=1    PerfScore 5.50
G_M5999_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=42f7e890) for method AdvSimdMethods:MultiplyRoundedDoublingScalarBySelectedScalarSaturateHighTest(System.Runtime.Intrinsics.Vector64`1[Int16],System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 37. NegateSaturateScalar

`Vector64<short> NegateSaturateScalar(Vector64<short> value)`

Performs 'NegateSaturateScalar' operation.

```csharp
private Vector64<short> NegateSaturateScalarTest(Vector64<short> value)
{
  return AdvSimd.Arm64.NegateSaturateScalar(value);
}
// value = <11, 12, 13, 14>
// Result = <-11, 0, 0, 0>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<int> NegateSaturateScalar(Vector64<int> value)
Vector64<long> NegateSaturateScalar(Vector64<long> value)
Vector64<sbyte> NegateSaturateScalar(Vector64<sbyte> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.negatesaturatescalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:NegateSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M11298_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M11298_IG02:
            ldr     d16, [fp,#24]
            sqneg   h16, h16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 4.50
G_M11298_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 12.20, (MethodHash=490ed3dd) for method AdvSimdMethods:NegateSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16]):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 38. ReciprocalEstimateScalar

`Vector64<double> ReciprocalEstimateScalar(Vector64<double> value)`

Performs 'ReciprocalEstimateScalar' operation.

```csharp
private Vector64<double> ReciprocalEstimateScalarTest(Vector64<double> value)
{
  return AdvSimd.Arm64.ReciprocalEstimateScalar(value);
}
// value = <11.5>
// Result = <0.0869140625>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<float> ReciprocalEstimateScalar(Vector64<float> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.reciprocalestimatescalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ReciprocalEstimateScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M53095_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M53095_IG02:
            ldr     d16, [fp,#24]
            frecpe  d16, d16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M53095_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=fb743098) for method AdvSimdMethods:ReciprocalEstimateScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 39. ReciprocalExponentScalar

`Vector64<double> ReciprocalExponentScalar(Vector64<double> value)`

Performs 'ReciprocalExponentScalar' operation.

```csharp
private Vector64<double> ReciprocalExponentScalarTest(Vector64<double> value)
{
  return AdvSimd.Arm64.ReciprocalExponentScalar(value);
}
// value = <11.5>
// Result = <0.25>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<float> ReciprocalExponentScalar(Vector64<float> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.reciprocalexponentscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ReciprocalExponentScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M17186_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M17186_IG02:
            ldr     d16, [fp,#24]
            frecpx  d16, d16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M17186_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=c12dbcdd) for method AdvSimdMethods:ReciprocalExponentScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 40. ReciprocalSquareRootEstimateScalar

`Vector64<double> ReciprocalSquareRootEstimateScalar(Vector64<double> value)`

Performs 'ReciprocalSquareRootEstimateScalar' operation.

```csharp
private Vector64<double> ReciprocalSquareRootEstimateScalarTest(Vector64<double> value)
{
  return AdvSimd.Arm64.ReciprocalSquareRootEstimateScalar(value);
}
// value = <11.5>
// Result = <0.294921875>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<float> ReciprocalSquareRootEstimateScalar(Vector64<float> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.reciprocalsquarerootestimatescalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ReciprocalSquareRootEstimateScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M57056_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M57056_IG02:
            ldr     d16, [fp,#24]
            frsqrte d16, d16
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M57056_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 13.20, (MethodHash=c33e211f) for method AdvSimdMethods:ReciprocalSquareRootEstimateScalarTest(System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 41. ReciprocalSquareRootStepScalar

`Vector64<double> ReciprocalSquareRootStepScalar(Vector64<double> left, Vector64<double> right)`

Performs 'ReciprocalSquareRootStepScalar' operation.

```csharp
private Vector64<double> ReciprocalSquareRootStepScalarTest(Vector64<double> left, Vector64<double> right)
{
  return AdvSimd.Arm64.ReciprocalSquareRootStepScalar(left, right);
}
// left = <11.5>
// right = <11.5>
// Result = <-64.625>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<float> ReciprocalSquareRootStepScalar(Vector64<float> left, Vector64<float> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.reciprocalsquarerootstepscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ReciprocalSquareRootStepScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M41706_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M41706_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            frsqrts d16, d16, d17
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M41706_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=bfce5d15) for method AdvSimdMethods:ReciprocalSquareRootStepScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 42. ReciprocalStepScalar

`Vector64<double> ReciprocalStepScalar(Vector64<double> left, Vector64<double> right)`

Performs 'ReciprocalStepScalar' operation.

```csharp
private Vector64<double> ReciprocalStepScalarTest(Vector64<double> left, Vector64<double> right)
{
  return AdvSimd.Arm64.ReciprocalStepScalar(left, right);
}
// left = <11.5>
// right = <11.5>
// Result = <-130.25>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<float> ReciprocalStepScalar(Vector64<float> left, Vector64<float> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.reciprocalstepscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ReciprocalStepScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M46733_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M46733_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            frecps  d16, d16, d17
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 7.50
G_M46733_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 17.00, (MethodHash=a4b44972) for method AdvSimdMethods:ReciprocalStepScalarTest(System.Runtime.Intrinsics.Vector64`1[Double],System.Runtime.Intrinsics.Vector64`1[Double]):System.Runtime.Intrinsics.Vector64`1[Double]
; ============================================================


```
------------------------------------------------

### 43. ShiftRightArithmeticNarrowingSaturateScalar

`Vector64<short> ShiftRightArithmeticNarrowingSaturateScalar(Vector64<int> value, byte count)`

Performs 'ShiftRightArithmeticNarrowingSaturateScalar' operation.

```csharp
private Vector64<short> ShiftRightArithmeticNarrowingSaturateScalarTest(Vector64<int> value, byte count)
{
  return AdvSimd.Arm64.ShiftRightArithmeticNarrowingSaturateScalar(value, count);
}
// value = <11, 12>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<int> ShiftRightArithmeticNarrowingSaturateScalar(Vector64<long> value, byte count)
Vector64<sbyte> ShiftRightArithmeticNarrowingSaturateScalar(Vector64<short> value, byte count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.shiftrightarithmeticnarrowingsaturatescalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftRightArithmeticNarrowingSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[Int32],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M27980_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M27980_IG02:
            ldr     d0, [fp,#24]
            uxtb    w0, w0
            bl      Arm64:ShiftRightArithmeticNarrowingSaturateScalar(System.Runtime.Intrinsics.Vector64`1[Int32],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
						;; bbWeight=1    PerfScore 3.50
G_M27980_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=079392b3) for method AdvSimdMethods:ShiftRightArithmeticNarrowingSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[Int32],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 44. ShiftRightArithmeticNarrowingSaturateUnsignedScalar

`Vector64<byte> ShiftRightArithmeticNarrowingSaturateUnsignedScalar(Vector64<short> value, byte count)`

Performs 'ShiftRightArithmeticNarrowingSaturateUnsignedScalar' operation.

```csharp
private Vector64<byte> ShiftRightArithmeticNarrowingSaturateUnsignedScalarTest(Vector64<short> value, byte count)
{
  return AdvSimd.Arm64.ShiftRightArithmeticNarrowingSaturateUnsignedScalar(value, count);
}
// value = <11, 12, 13, 14>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<ushort> ShiftRightArithmeticNarrowingSaturateUnsignedScalar(Vector64<int> value, byte count)
Vector64<uint> ShiftRightArithmeticNarrowingSaturateUnsignedScalar(Vector64<long> value, byte count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.shiftrightarithmeticnarrowingsaturateunsignedscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftRightArithmeticNarrowingSaturateUnsignedScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M41341_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M41341_IG02:
            ldr     d0, [fp,#24]
            uxtb    w0, w0
            bl      Arm64:ShiftRightArithmeticNarrowingSaturateUnsignedScalar(System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
						;; bbWeight=1    PerfScore 3.50
G_M41341_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=bd5d5e82) for method AdvSimdMethods:ShiftRightArithmeticNarrowingSaturateUnsignedScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 45. ShiftRightArithmeticRoundedNarrowingSaturateScalar

`Vector64<short> ShiftRightArithmeticRoundedNarrowingSaturateScalar(Vector64<int> value, byte count)`

Performs 'ShiftRightArithmeticRoundedNarrowingSaturateScalar' operation.

```csharp
private Vector64<short> ShiftRightArithmeticRoundedNarrowingSaturateScalarTest(Vector64<int> value, byte count)
{
  return AdvSimd.Arm64.ShiftRightArithmeticRoundedNarrowingSaturateScalar(value, count);
}
// value = <11, 12>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<int> ShiftRightArithmeticRoundedNarrowingSaturateScalar(Vector64<long> value, byte count)
Vector64<sbyte> ShiftRightArithmeticRoundedNarrowingSaturateScalar(Vector64<short> value, byte count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.shiftrightarithmeticroundednarrowingsaturatescalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftRightArithmeticRoundedNarrowingSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[Int32],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M48431_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M48431_IG02:
            ldr     d0, [fp,#24]
            uxtb    w0, w0
            bl      Arm64:ShiftRightArithmeticRoundedNarrowingSaturateScalar(System.Runtime.Intrinsics.Vector64`1[Int32],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
						;; bbWeight=1    PerfScore 3.50
G_M48431_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=4eac42d0) for method AdvSimdMethods:ShiftRightArithmeticRoundedNarrowingSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[Int32],ubyte):System.Runtime.Intrinsics.Vector64`1[Int16]
; ============================================================


```
------------------------------------------------

### 46. ShiftRightArithmeticRoundedNarrowingSaturateUnsignedScalar

`Vector64<byte> ShiftRightArithmeticRoundedNarrowingSaturateUnsignedScalar(Vector64<short> value, byte count)`

Performs 'ShiftRightArithmeticRoundedNarrowingSaturateUnsignedScalar' operation.

```csharp
private Vector64<byte> ShiftRightArithmeticRoundedNarrowingSaturateUnsignedScalarTest(Vector64<short> value, byte count)
{
  return AdvSimd.Arm64.ShiftRightArithmeticRoundedNarrowingSaturateUnsignedScalar(value, count);
}
// value = <11, 12, 13, 14>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<ushort> ShiftRightArithmeticRoundedNarrowingSaturateUnsignedScalar(Vector64<int> value, byte count)
Vector64<uint> ShiftRightArithmeticRoundedNarrowingSaturateUnsignedScalar(Vector64<long> value, byte count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.shiftrightarithmeticroundednarrowingsaturateunsignedscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftRightArithmeticRoundedNarrowingSaturateUnsignedScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M52798_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M52798_IG02:
            ldr     d0, [fp,#24]
            uxtb    w0, w0
            bl      Arm64:ShiftRightArithmeticRoundedNarrowingSaturateUnsignedScalar(System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
						;; bbWeight=1    PerfScore 3.50
G_M52798_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=fb1131c1) for method AdvSimdMethods:ShiftRightArithmeticRoundedNarrowingSaturateUnsignedScalarTest(System.Runtime.Intrinsics.Vector64`1[Int16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 47. ShiftRightLogicalNarrowingSaturateScalar

`Vector64<byte> ShiftRightLogicalNarrowingSaturateScalar(Vector64<ushort> value, byte count)`

Performs 'ShiftRightLogicalNarrowingSaturateScalar' operation.

```csharp
private Vector64<byte> ShiftRightLogicalNarrowingSaturateScalarTest(Vector64<ushort> value, byte count)
{
  return AdvSimd.Arm64.ShiftRightLogicalNarrowingSaturateScalar(value, count);
}
// value = <11, 12, 13, 14>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<short> ShiftRightLogicalNarrowingSaturateScalar(Vector64<int> value, byte count)
Vector64<int> ShiftRightLogicalNarrowingSaturateScalar(Vector64<long> value, byte count)
Vector64<sbyte> ShiftRightLogicalNarrowingSaturateScalar(Vector64<short> value, byte count)
Vector64<ushort> ShiftRightLogicalNarrowingSaturateScalar(Vector64<uint> value, byte count)
Vector64<uint> ShiftRightLogicalNarrowingSaturateScalar(Vector64<ulong> value, byte count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.shiftrightlogicalnarrowingsaturatescalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftRightLogicalNarrowingSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[UInt16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M24082_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M24082_IG02:
            ldr     d0, [fp,#24]
            uxtb    w0, w0
            bl      Arm64:ShiftRightLogicalNarrowingSaturateScalar(System.Runtime.Intrinsics.Vector64`1[UInt16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
						;; bbWeight=1    PerfScore 3.50
G_M24082_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=724ea1ed) for method AdvSimdMethods:ShiftRightLogicalNarrowingSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[UInt16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 48. ShiftRightLogicalRoundedNarrowingSaturateScalar

`Vector64<byte> ShiftRightLogicalRoundedNarrowingSaturateScalar(Vector64<ushort> value, byte count)`

Performs 'ShiftRightLogicalRoundedNarrowingSaturateScalar' operation.

```csharp
private Vector64<byte> ShiftRightLogicalRoundedNarrowingSaturateScalarTest(Vector64<ushort> value, byte count)
{
  return AdvSimd.Arm64.ShiftRightLogicalRoundedNarrowingSaturateScalar(value, count);
}
// value = <11, 12, 13, 14>
// count = 0
// Result = TODO

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<short> ShiftRightLogicalRoundedNarrowingSaturateScalar(Vector64<int> value, byte count)
Vector64<int> ShiftRightLogicalRoundedNarrowingSaturateScalar(Vector64<long> value, byte count)
Vector64<sbyte> ShiftRightLogicalRoundedNarrowingSaturateScalar(Vector64<short> value, byte count)
Vector64<ushort> ShiftRightLogicalRoundedNarrowingSaturateScalar(Vector64<uint> value, byte count)
Vector64<uint> ShiftRightLogicalRoundedNarrowingSaturateScalar(Vector64<ulong> value, byte count)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.shiftrightlogicalroundednarrowingsaturatescalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ShiftRightLogicalRoundedNarrowingSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[UInt16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01,T00] (  3,  3   )   ubyte  ->   x0        
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;  V03 tmp1         [V03,T01] (  2,  4   )   simd8  ->   d0         HFA(simd8)  "Inlining Arg"
;
; Lcl frame size = 16

G_M29009_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M29009_IG02:
            ldr     d0, [fp,#24]
            uxtb    w0, w0
            bl      Arm64:ShiftRightLogicalRoundedNarrowingSaturateScalar(System.Runtime.Intrinsics.Vector64`1[UInt16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
						;; bbWeight=1    PerfScore 3.50
G_M29009_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=61a88eae) for method AdvSimdMethods:ShiftRightLogicalRoundedNarrowingSaturateScalarTest(System.Runtime.Intrinsics.Vector64`1[UInt16],ubyte):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 49. Sqrt

`Vector64<float> Sqrt(Vector64<float> value)`

Performs 'Sqrt' operation.

```csharp
private Vector64<float> SqrtTest(Vector64<float> value)
{
  return AdvSimd.Arm64.Sqrt(value);
}
// value = <11.5, 12.5>
// Result = <3.391165, 3.535534>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector128<double> Sqrt(Vector128<double> value)
Vector128<float> Sqrt(Vector128<float> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.sqrt?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:SqrtTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M40773_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M40773_IG02:
            ldr     d16, [fp,#24]
            fsqrt   v16.2s, v16.2s
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 12.50
G_M40773_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 20.20, (MethodHash=0ed260ba) for method AdvSimdMethods:SqrtTest(System.Runtime.Intrinsics.Vector64`1[Single]):System.Runtime.Intrinsics.Vector64`1[Single]
; ============================================================

; Assembly listing for method AdvSimdMethods:StorePairTest(long,System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte])
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00,T00] (  3,  3   )    long  ->   x0        
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M5284_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M5284_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            stp     d16, d17, [x0]
						;; bbWeight=1    PerfScore 5.00
G_M5284_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 36, prolog size 8, PerfScore 14.10, (MethodHash=59e5eb5b) for method AdvSimdMethods:StorePairTest(long,System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte])
; ============================================================


```
------------------------------------------------

### 50. StorePair

`void StorePair(byte* address, Vector64<byte> value1, Vector64<byte> value2)`

Performs 'StorePair' operation.

```csharp
private void StorePairTest(byte* address, Vector64<byte> value1, Vector64<byte> value2)
{
  AdvSimd.Arm64.StorePair(address, value1, value2);
}
// address = <address>
// value1 = <11, 12, 13, 14, 15, 16, 17, 18>
// value2 = <21, 22, 23, 24, 25, 26, 27, 28>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
void StorePair(double* address, Vector64<double> value1, Vector64<double> value2)
void StorePair(short* address, Vector64<short> value1, Vector64<short> value2)
void StorePair(int* address, Vector64<int> value1, Vector64<int> value2)
void StorePair(long* address, Vector64<long> value1, Vector64<long> value2)
void StorePair(sbyte* address, Vector64<sbyte> value1, Vector64<sbyte> value2)
void StorePair(float* address, Vector64<float> value1, Vector64<float> value2)
void StorePair(ushort* address, Vector64<ushort> value1, Vector64<ushort> value2)
void StorePair(uint* address, Vector64<uint> value1, Vector64<uint> value2)
void StorePair(ulong* address, Vector64<ulong> value1, Vector64<ulong> value2)
void StorePair(byte* address, Vector128<byte> value1, Vector128<byte> value2)
void StorePair(double* address, Vector128<double> value1, Vector128<double> value2)
void StorePair(short* address, Vector128<short> value1, Vector128<short> value2)
void StorePair(int* address, Vector128<int> value1, Vector128<int> value2)
void StorePair(long* address, Vector128<long> value1, Vector128<long> value2)
void StorePair(sbyte* address, Vector128<sbyte> value1, Vector128<sbyte> value2)
void StorePair(float* address, Vector128<float> value1, Vector128<float> value2)
void StorePair(ushort* address, Vector128<ushort> value1, Vector128<ushort> value2)
void StorePair(uint* address, Vector128<uint> value1, Vector128<uint> value2)
void StorePair(ulong* address, Vector128<ulong> value1, Vector128<ulong> value2)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.storepair?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:StorePairNonTemporalTest(long,System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte])
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00,T00] (  3,  3   )    long  ->   x0        
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M18903_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M18903_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            stnp    d16, d17, [x0]
						;; bbWeight=1    PerfScore 5.00
G_M18903_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 36, prolog size 8, PerfScore 14.10, (MethodHash=5233b628) for method AdvSimdMethods:StorePairNonTemporalTest(long,System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte])
; ============================================================


```
------------------------------------------------

### 51. StorePairNonTemporal

`void StorePairNonTemporal(byte* address, Vector64<byte> value1, Vector64<byte> value2)`

Performs 'StorePairNonTemporal' operation.

```csharp
private void StorePairNonTemporalTest(byte* address, Vector64<byte> value1, Vector64<byte> value2)
{
  AdvSimd.Arm64.StorePairNonTemporal(address, value1, value2);
}
// address = <address>
// value1 = <11, 12, 13, 14, 15, 16, 17, 18>
// value2 = <21, 22, 23, 24, 25, 26, 27, 28>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
void StorePairNonTemporal(double* address, Vector64<double> value1, Vector64<double> value2)
void StorePairNonTemporal(short* address, Vector64<short> value1, Vector64<short> value2)
void StorePairNonTemporal(int* address, Vector64<int> value1, Vector64<int> value2)
void StorePairNonTemporal(long* address, Vector64<long> value1, Vector64<long> value2)
void StorePairNonTemporal(sbyte* address, Vector64<sbyte> value1, Vector64<sbyte> value2)
void StorePairNonTemporal(float* address, Vector64<float> value1, Vector64<float> value2)
void StorePairNonTemporal(ushort* address, Vector64<ushort> value1, Vector64<ushort> value2)
void StorePairNonTemporal(uint* address, Vector64<uint> value1, Vector64<uint> value2)
void StorePairNonTemporal(ulong* address, Vector64<ulong> value1, Vector64<ulong> value2)
void StorePairNonTemporal(byte* address, Vector128<byte> value1, Vector128<byte> value2)
void StorePairNonTemporal(double* address, Vector128<double> value1, Vector128<double> value2)
void StorePairNonTemporal(short* address, Vector128<short> value1, Vector128<short> value2)
void StorePairNonTemporal(int* address, Vector128<int> value1, Vector128<int> value2)
void StorePairNonTemporal(long* address, Vector128<long> value1, Vector128<long> value2)
void StorePairNonTemporal(sbyte* address, Vector128<sbyte> value1, Vector128<sbyte> value2)
void StorePairNonTemporal(float* address, Vector128<float> value1, Vector128<float> value2)
void StorePairNonTemporal(ushort* address, Vector128<ushort> value1, Vector128<ushort> value2)
void StorePairNonTemporal(uint* address, Vector128<uint> value1, Vector128<uint> value2)
void StorePairNonTemporal(ulong* address, Vector128<ulong> value1, Vector128<ulong> value2)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.storepairnontemporal?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:StorePairScalarTest(long,System.Runtime.Intrinsics.Vector64`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int32])
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00,T00] (  3,  3   )    long  ->   x0        
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M6474_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M6474_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            stp     s16, s17, [x0]
						;; bbWeight=1    PerfScore 5.00
G_M6474_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 36, prolog size 8, PerfScore 14.10, (MethodHash=2812e6b5) for method AdvSimdMethods:StorePairScalarTest(long,System.Runtime.Intrinsics.Vector64`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int32])
; ============================================================


```
------------------------------------------------

### 52. StorePairScalar

`void StorePairScalar(int* address, Vector64<int> value1, Vector64<int> value2)`

Performs 'StorePairScalar' operation.

```csharp
private void StorePairScalarTest(int* address, Vector64<int> value1, Vector64<int> value2)
{
  AdvSimd.Arm64.StorePairScalar(address, value1, value2);
}
// address = <address>
// value1 = <11, 12>
// value2 = <21, 22>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
void StorePairScalar(float* address, Vector64<float> value1, Vector64<float> value2)
void StorePairScalar(uint* address, Vector64<uint> value1, Vector64<uint> value2)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.storepairscalar?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:StorePairScalarNonTemporalTest(long,System.Runtime.Intrinsics.Vector64`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int32])
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00,T00] (  3,  3   )    long  ->   x0        
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V02 arg2         [V02    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V03 OutArgs      [V03    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M1721_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M1721_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            stnp    s16, s17, [x0]
						;; bbWeight=1    PerfScore 5.00
G_M1721_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 36, prolog size 8, PerfScore 14.10, (MethodHash=6f1ef946) for method AdvSimdMethods:StorePairScalarNonTemporalTest(long,System.Runtime.Intrinsics.Vector64`1[Int32],System.Runtime.Intrinsics.Vector64`1[Int32])
; ============================================================


```
------------------------------------------------

### 53. StorePairScalarNonTemporal

`void StorePairScalarNonTemporal(int* address, Vector64<int> value1, Vector64<int> value2)`

Performs 'StorePairScalarNonTemporal' operation.

```csharp
private void StorePairScalarNonTemporalTest(int* address, Vector64<int> value1, Vector64<int> value2)
{
  AdvSimd.Arm64.StorePairScalarNonTemporal(address, value1, value2);
}
// address = <address>
// value1 = <11, 12>
// value2 = <21, 22>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
void StorePairScalarNonTemporal(float* address, Vector64<float> value1, Vector64<float> value2)
void StorePairScalarNonTemporal(uint* address, Vector64<uint> value1, Vector64<uint> value2)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.storepairscalarnontemporal?view=net-5.0).

Assembly generated:

```



```
------------------------------------------------

### 54. ReverseElementBits

`Vector64<byte> ReverseElementBits(Vector64<byte> value)`

Performs 'ReverseElementBits' operation.

```csharp
private Vector64<byte> ReverseElementBitsTest(Vector64<byte> value)
{
  return AdvSimd.Arm64.ReverseElementBits(value);
}
// value = <11, 12, 13, 14, 15, 16, 17, 18>
// Result = <208, 48, 176, 112, 240, 8, 136, 72>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<sbyte> ReverseElementBits(Vector64<sbyte> value)
Vector128<byte> ReverseElementBits(Vector128<byte> value)
Vector128<sbyte> ReverseElementBits(Vector128<sbyte> value)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.reverseelementbits?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ReverseElementBitsTest(System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M33011_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
						;; bbWeight=1    PerfScore 2.50
G_M33011_IG02:
            ldr     d16, [fp,#24]
            rbit    v16.8b, v16.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 3.50
G_M33011_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 32, prolog size 8, PerfScore 11.20, (MethodHash=06ea7f0c) for method AdvSimdMethods:ReverseElementBitsTest(System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 55. TransposeEven

`Vector64<byte> TransposeEven(Vector64<byte> left, Vector64<byte> right)`

Performs 'TransposeEven' operation.

```csharp
private Vector64<byte> TransposeEvenTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.Arm64.TransposeEven(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <11, 21, 13, 23, 15, 25, 17, 27>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<short> TransposeEven(Vector64<short> left, Vector64<short> right)
Vector64<int> TransposeEven(Vector64<int> left, Vector64<int> right)
Vector64<sbyte> TransposeEven(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<float> TransposeEven(Vector64<float> left, Vector64<float> right)
Vector64<ushort> TransposeEven(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> TransposeEven(Vector64<uint> left, Vector64<uint> right)
Vector128<byte> TransposeEven(Vector128<byte> left, Vector128<byte> right)
Vector128<double> TransposeEven(Vector128<double> left, Vector128<double> right)
Vector128<short> TransposeEven(Vector128<short> left, Vector128<short> right)
Vector128<int> TransposeEven(Vector128<int> left, Vector128<int> right)
Vector128<long> TransposeEven(Vector128<long> left, Vector128<long> right)
Vector128<sbyte> TransposeEven(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<float> TransposeEven(Vector128<float> left, Vector128<float> right)
Vector128<ushort> TransposeEven(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> TransposeEven(Vector128<uint> left, Vector128<uint> right)
Vector128<ulong> TransposeEven(Vector128<ulong> left, Vector128<ulong> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.transposeeven?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:TransposeEvenTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M3131_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M3131_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            trn1    v16.8b, v16.8b, v17.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M3131_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=8fa7f3c4) for method AdvSimdMethods:TransposeEvenTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 56. TransposeOdd

`Vector64<byte> TransposeOdd(Vector64<byte> left, Vector64<byte> right)`

Performs 'TransposeOdd' operation.

```csharp
private Vector64<byte> TransposeOddTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.Arm64.TransposeOdd(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <12, 22, 14, 24, 16, 26, 18, 28>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<short> TransposeOdd(Vector64<short> left, Vector64<short> right)
Vector64<int> TransposeOdd(Vector64<int> left, Vector64<int> right)
Vector64<sbyte> TransposeOdd(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<float> TransposeOdd(Vector64<float> left, Vector64<float> right)
Vector64<ushort> TransposeOdd(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> TransposeOdd(Vector64<uint> left, Vector64<uint> right)
Vector128<byte> TransposeOdd(Vector128<byte> left, Vector128<byte> right)
Vector128<double> TransposeOdd(Vector128<double> left, Vector128<double> right)
Vector128<short> TransposeOdd(Vector128<short> left, Vector128<short> right)
Vector128<int> TransposeOdd(Vector128<int> left, Vector128<int> right)
Vector128<long> TransposeOdd(Vector128<long> left, Vector128<long> right)
Vector128<sbyte> TransposeOdd(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<float> TransposeOdd(Vector128<float> left, Vector128<float> right)
Vector128<ushort> TransposeOdd(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> TransposeOdd(Vector128<uint> left, Vector128<uint> right)
Vector128<ulong> TransposeOdd(Vector128<ulong> left, Vector128<ulong> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.transposeodd?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:TransposeOddTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M49932_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M49932_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            trn2    v16.8b, v16.8b, v17.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M49932_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=a22e3cf3) for method AdvSimdMethods:TransposeOddTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 57. UnzipEven

`Vector64<byte> UnzipEven(Vector64<byte> left, Vector64<byte> right)`

Performs 'UnzipEven' operation.

```csharp
private Vector64<byte> UnzipEvenTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.Arm64.UnzipEven(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <11, 13, 15, 17, 21, 23, 25, 27>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<short> UnzipEven(Vector64<short> left, Vector64<short> right)
Vector64<int> UnzipEven(Vector64<int> left, Vector64<int> right)
Vector64<sbyte> UnzipEven(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<float> UnzipEven(Vector64<float> left, Vector64<float> right)
Vector64<ushort> UnzipEven(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> UnzipEven(Vector64<uint> left, Vector64<uint> right)
Vector128<byte> UnzipEven(Vector128<byte> left, Vector128<byte> right)
Vector128<double> UnzipEven(Vector128<double> left, Vector128<double> right)
Vector128<short> UnzipEven(Vector128<short> left, Vector128<short> right)
Vector128<int> UnzipEven(Vector128<int> left, Vector128<int> right)
Vector128<long> UnzipEven(Vector128<long> left, Vector128<long> right)
Vector128<sbyte> UnzipEven(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<float> UnzipEven(Vector128<float> left, Vector128<float> right)
Vector128<ushort> UnzipEven(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> UnzipEven(Vector128<uint> left, Vector128<uint> right)
Vector128<ulong> UnzipEven(Vector128<ulong> left, Vector128<ulong> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.unzipeven?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:UnzipEvenTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M51568_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M51568_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            uzp1    v16.8b, v16.8b, v17.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M51568_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=9001368f) for method AdvSimdMethods:UnzipEvenTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 58. UnzipOdd

`Vector64<byte> UnzipOdd(Vector64<byte> left, Vector64<byte> right)`

Performs 'UnzipOdd' operation.

```csharp
private Vector64<byte> UnzipOddTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.Arm64.UnzipOdd(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <12, 14, 16, 18, 22, 24, 26, 28>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<short> UnzipOdd(Vector64<short> left, Vector64<short> right)
Vector64<int> UnzipOdd(Vector64<int> left, Vector64<int> right)
Vector64<sbyte> UnzipOdd(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<float> UnzipOdd(Vector64<float> left, Vector64<float> right)
Vector64<ushort> UnzipOdd(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> UnzipOdd(Vector64<uint> left, Vector64<uint> right)
Vector128<byte> UnzipOdd(Vector128<byte> left, Vector128<byte> right)
Vector128<double> UnzipOdd(Vector128<double> left, Vector128<double> right)
Vector128<short> UnzipOdd(Vector128<short> left, Vector128<short> right)
Vector128<int> UnzipOdd(Vector128<int> left, Vector128<int> right)
Vector128<long> UnzipOdd(Vector128<long> left, Vector128<long> right)
Vector128<sbyte> UnzipOdd(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<float> UnzipOdd(Vector128<float> left, Vector128<float> right)
Vector128<ushort> UnzipOdd(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> UnzipOdd(Vector128<uint> left, Vector128<uint> right)
Vector128<ulong> UnzipOdd(Vector128<ulong> left, Vector128<ulong> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.unzipodd?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:UnzipOddTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M13863_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M13863_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            uzp2    v16.8b, v16.8b, v17.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M13863_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=71fdc9d8) for method AdvSimdMethods:UnzipOddTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 59. ZipHigh

`Vector64<byte> ZipHigh(Vector64<byte> left, Vector64<byte> right)`

Performs 'ZipHigh' operation.

```csharp
private Vector64<byte> ZipHighTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.Arm64.ZipHigh(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <15, 25, 16, 26, 17, 27, 18, 28>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<short> ZipHigh(Vector64<short> left, Vector64<short> right)
Vector64<int> ZipHigh(Vector64<int> left, Vector64<int> right)
Vector64<sbyte> ZipHigh(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<float> ZipHigh(Vector64<float> left, Vector64<float> right)
Vector64<ushort> ZipHigh(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> ZipHigh(Vector64<uint> left, Vector64<uint> right)
Vector128<byte> ZipHigh(Vector128<byte> left, Vector128<byte> right)
Vector128<double> ZipHigh(Vector128<double> left, Vector128<double> right)
Vector128<short> ZipHigh(Vector128<short> left, Vector128<short> right)
Vector128<int> ZipHigh(Vector128<int> left, Vector128<int> right)
Vector128<long> ZipHigh(Vector128<long> left, Vector128<long> right)
Vector128<sbyte> ZipHigh(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<float> ZipHigh(Vector128<float> left, Vector128<float> right)
Vector128<ushort> ZipHigh(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> ZipHigh(Vector128<uint> left, Vector128<uint> right)
Vector128<ulong> ZipHigh(Vector128<ulong> left, Vector128<ulong> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.ziphigh?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ZipHighTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M44509_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M44509_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            zip2    v16.8b, v16.8b, v17.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M44509_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=ba165222) for method AdvSimdMethods:ZipHighTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================


```
------------------------------------------------

### 60. ZipLow

`Vector64<byte> ZipLow(Vector64<byte> left, Vector64<byte> right)`

Performs 'ZipLow' operation.

```csharp
private Vector64<byte> ZipLowTest(Vector64<byte> left, Vector64<byte> right)
{
  return AdvSimd.Arm64.ZipLow(left, right);
}
// left = <11, 12, 13, 14, 15, 16, 17, 18>
// right = <21, 22, 23, 24, 25, 26, 27, 28>
// Result = <11, 21, 12, 22, 13, 23, 14, 24>

```

Similar APIs that operate on different sizes:

```csharp
// class System.Runtime.Intrinisics.AdvSimd.Arm64
Vector64<short> ZipLow(Vector64<short> left, Vector64<short> right)
Vector64<int> ZipLow(Vector64<int> left, Vector64<int> right)
Vector64<sbyte> ZipLow(Vector64<sbyte> left, Vector64<sbyte> right)
Vector64<float> ZipLow(Vector64<float> left, Vector64<float> right)
Vector64<ushort> ZipLow(Vector64<ushort> left, Vector64<ushort> right)
Vector64<uint> ZipLow(Vector64<uint> left, Vector64<uint> right)
Vector128<byte> ZipLow(Vector128<byte> left, Vector128<byte> right)
Vector128<double> ZipLow(Vector128<double> left, Vector128<double> right)
Vector128<short> ZipLow(Vector128<short> left, Vector128<short> right)
Vector128<int> ZipLow(Vector128<int> left, Vector128<int> right)
Vector128<long> ZipLow(Vector128<long> left, Vector128<long> right)
Vector128<sbyte> ZipLow(Vector128<sbyte> left, Vector128<sbyte> right)
Vector128<float> ZipLow(Vector128<float> left, Vector128<float> right)
Vector128<ushort> ZipLow(Vector128<ushort> left, Vector128<ushort> right)
Vector128<uint> ZipLow(Vector128<uint> left, Vector128<uint> right)
Vector128<ulong> ZipLow(Vector128<ulong> left, Vector128<ulong> right)
```


See MSDN reference [here](https://docs.microsoft.com/en-us/dotNet/api/system.runtime.intrinsics.arm.advsimd.arm64.ziplow?view=net-5.0).

Assembly generated:

```


; Assembly listing for method AdvSimdMethods:ZipLowTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; Emitting BLENDED_CODE for generic ARM64 CPU - Windows
; optimized code
; fp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  3,  3   )   simd8  ->  [fp+0x18]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;  V01 arg1         [V01    ] (  3,  3   )   simd8  ->  [fp+0x10]   HFA(simd8)  do-not-enreg[XS] addr-exposed
;# V02 OutArgs      [V02    ] (  1,  1   )  lclBlk ( 0) [sp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 16

G_M18919_IG01:
            stp     fp, lr, [sp,#-32]!
            mov     fp, sp
            str     d0, [fp,#24]
            str     d1, [fp,#16]
						;; bbWeight=1    PerfScore 3.50
G_M18919_IG02:
            ldr     d16, [fp,#24]
            ldr     d17, [fp,#16]
            zip1    v16.8b, v16.8b, v17.8b
            mov     v0.8b, v16.8b
						;; bbWeight=1    PerfScore 5.50
G_M18919_IG03:
            ldp     fp, lr, [sp],#32
            ret     lr
						;; bbWeight=1    PerfScore 2.00

; Total bytes of code 40, prolog size 8, PerfScore 15.00, (MethodHash=41beb618) for method AdvSimdMethods:ZipLowTest(System.Runtime.Intrinsics.Vector64`1[Byte],System.Runtime.Intrinsics.Vector64`1[Byte]):System.Runtime.Intrinsics.Vector64`1[Byte]
; ============================================================

